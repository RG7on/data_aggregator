<html lang="en"><head>
	<title>Cisco Unified Intelligence Center</title>
	<script>
		(function(w){
			w.deepCompare = function (a,b) {
			  return JSON.stringify(a) === JSON.stringify(b);
			}
			w.cdContextPath = "/cuicui";
			w.cdTimestamp = "1758049574067";
			w.cdUniqueUrl = "?nocache=1758049574067";
			var tmpcdLayout = '{"assets":{"url":["/cuicui/components/launcher.css","/cuicui/scripts/js/jquery.min.js"]},"configs":[{"key":"title","value":"Cisco Unified Intelligence Center"}],"header":{"leftAlignedColumns":[{"gadget":null,"component":[{"attributes":{"id":"cd-logo","order":"1"},"url":"/cuicui/scripts/js/logo.js","stylesheet":null}],"width":"420px"}],"rightAlignedColumns":[{"gadget":[{"attributes":{"id":"identity_gadget","order":"2"},"url":"http://localhost:8081/cuicui/gadgets/identity/identity.xml"}],"component":null,"width":"235px"}]},"page":{"navstype":null,"contentarea":null,"navs":[{"url":"#/home","deferLoad":null,"label":"cuicui.home","icon":"icon-home","iconUrl":null,"contentarea":{"rows":[{"columns":[{"gadget":[{"attributes":{"id":"home_gadget","order":"3"},"url":"http://localhost:8081/cuicui/gadgets/home/home.xml"}],"component":null,"width":"100%"}],"height":"100%"}],"height":null},"navs":null},{"url":"#/dashboards","deferLoad":null,"label":"cuicui.dashboards","icon":"icon-call-rate","iconUrl":null,"contentarea":{"rows":[{"columns":[{"gadget":[{"attributes":{"id":"dashboard_gadget","order":"4"},"url":"http://localhost:8081/cuicui/gadgets/dashboard/dashboardgadget.xml"}],"component":null,"width":"100%"}],"height":"100%"}],"height":null},"navs":null},{"url":"#/reports","deferLoad":null,"label":"cuicui.reports","icon":"icon-report","iconUrl":null,"contentarea":{"rows":[{"columns":[{"gadget":[{"attributes":{"id":"report_gadget","order":"5"},"url":"http://localhost:8081/cuicui/gadgets/report/reportgadget.xml"}],"component":null,"width":"100%"}],"height":"100%"}],"height":null},"navs":null},{"url":"#/reportdefinitions","deferLoad":null,"label":"cuicui.reportDefinitions","icon":"icon-report-definition","iconUrl":null,"contentarea":{"rows":[{"columns":[{"gadget":null,"component":[{"attributes":{"id":"report_definition_component","order":"6"},"url":"/cuicui/components/launcher.jsp?pageId=report_definition_component&page=rd&dev=false","stylesheet":null}],"width":"100%"}],"height":"100%"}],"height":null},"navs":null},{"url":"#/vl","deferLoad":null,"label":"CUIC.Drawer.ValueList.name","icon":"icon-list-view","iconUrl":null,"contentarea":{"rows":[{"columns":[{"gadget":null,"component":[{"attributes":{"id":"vl_component","order":"7"},"url":"/cuicui/components/launcher.jsp?pageId=vl_component&page=vl&dev=false","stylesheet":null}],"width":"100%"}],"height":"100%"}],"height":null},"navs":null},{"url":null,"deferLoad":null,"label":"cuicui.configure","icon":"icon-settings","iconUrl":null,"contentarea":null,"navs":[{"url":"#/userpermissions","deferLoad":null,"label":"JSP.Security.permissionsLabel","icon":null,"iconUrl":null,"contentarea":{"rows":[{"columns":[{"gadget":null,"component":[{"attributes":{"id":"userpermissions_component","order":"8"},"url":"/cuicui/components/launcher.jsp?pageId=userpermissions_component&page=userpermissions&dev=false","stylesheet":null}],"width":"100%"}],"height":"100%"}],"height":null},"navs":null},{"url":"#/users","deferLoad":null,"label":"cuicui.users","icon":"icon-user","iconUrl":null,"contentarea":{"rows":[{"columns":[{"gadget":null,"component":[{"attributes":{"id":"users_list_component","order":"9"},"url":"/cuicui/components/launcher.jsp?pageId=users_list_component&page=users&dev=false","stylesheet":null}],"width":"100%"}],"height":"100%"}],"height":null},"navs":null},{"url":"#/groups","deferLoad":null,"label":"JSP.SecurityEditorAddEditUserList.parentGroups","icon":"icon-groups","iconUrl":null,"contentarea":{"rows":[{"columns":[{"gadget":null,"component":[{"attributes":{"id":"groups_components","order":"10"},"url":"/cuicui/components/launcher.jsp?pageId=groups_components&page=groups&dev=false","stylesheet":null}],"width":"100%"}],"height":"100%"}],"height":null},"navs":null},{"url":"#/datasources","deferLoad":null,"label":"cuicui.datasources","icon":"icon-data","iconUrl":null,"contentarea":{"rows":[{"columns":[{"gadget":null,"component":[{"attributes":{"id":"ds_list_component","order":"11"},"url":"/cuicui/components/launcher.jsp?pageId=ds_list_component&page=datasources&dev=false","stylesheet":null}],"width":"100%"}],"height":"100%"}],"height":null},"navs":null}]},{"url":"#/schedulers","deferLoad":null,"label":"cuicui.schedules","icon":"icon-time","iconUrl":null,"contentarea":{"rows":[{"columns":[{"gadget":null,"component":[{"attributes":{"id":"schedulers_component","order":"12"},"url":"/cuicui/components/launcher.jsp?pageId=schedulers_component&page=schedulers&dev=false","stylesheet":null}],"width":"100%"}],"height":"100%"}],"height":null},"navs":null}]},"footer":null}';
			if(typeof tmpcdLayout === "string") {
				tmpcdLayout = JSON.parse(tmpcdLayout);
			}
			var PREVIOUS_CD_LAYOUT = localStorage.getItem("PREVIOUS_CD_LAYOUT");
			var previousCdLayout = JSON.parse(PREVIOUS_CD_LAYOUT);
			if(previousCdLayout) delete previousCdLayout.hashId;
			if(PREVIOUS_CD_LAYOUT && w.deepCompare(tmpcdLayout, previousCdLayout)) {
				tmpcdLayout = JSON.parse(PREVIOUS_CD_LAYOUT);
			} else {
				/* 
				 Generating the unique HASH ID using JS time stamp
				 which is always unique.
				*/
				tmpcdLayout.hashId = new Date().valueOf();
				localStorage.setItem("PREVIOUS_CD_LAYOUT", JSON.stringify(tmpcdLayout));
			}
			w.cdLayout = tmpcdLayout;
		})(window);
	</script>
	<link rel="icon" href="favicon.ico">
<script type="text/javascript" src="/gadgets/js/shindig-container:osapi:pubsub-2:loadingindicator.js?c=1&amp;debug=1"></script><script type="text/javascript" src="/cuicui/scripts/js/cd.layout.vendor.js?nocache=1758049574067"></script><script type="text/javascript" src="/cuicui/scripts/js/cd.layout.js?nocache=1758049574067"></script><link rel="stylesheet" type="text/css" href="/cuicui/components/launcher.css"><script type="text/javascript" src="/cuicui/scripts/js/jquery.min.js"></script><style id="erd_scroll_detection_scrollbar_style">/* Created by the element-resize-detector library. */
.erd_scroll_detection_container > div::-webkit-scrollbar { display: none; }

.erd_scroll_detection_container_animation_active { -webkit-animation-duration: 0.1s; animation-duration: 0.1s; -webkit-animation-name: erd_scroll_detection_container_animation; animation-name: erd_scroll_detection_container_animation; }
@-webkit-keyframes erd_scroll_detection_container_animation { 0% { opacity: 1; } 50% { opacity: 0; } 100% { opacity: 1; } }
@keyframes erd_scroll_detection_container_animation { 0% { opacity: 1; } 50% { opacity: 0; } 100% { opacity: 1; } }</style><script type="text/javascript" src="/cuicui/scripts/js/logo.js"></script><script type="text/javascript" src="/cuicui/components/launcher.jsp?pageId=report_definition_component&amp;page=rd&amp;dev=false"></script><script type="text/javascript" src="/cuicui/components/launcher.jsp?pageId=vl_component&amp;page=vl&amp;dev=false"></script><script type="text/javascript" src="/cuicui/components/launcher.jsp?pageId=userpermissions_component&amp;page=userpermissions&amp;dev=false"></script><script type="text/javascript" src="/cuicui/components/launcher.jsp?pageId=users_list_component&amp;page=users&amp;dev=false"></script><script type="text/javascript" src="/cuicui/components/launcher.jsp?pageId=groups_components&amp;page=groups&amp;dev=false"></script><script type="text/javascript" src="/cuicui/components/launcher.jsp?pageId=ds_list_component&amp;page=datasources&amp;dev=false"></script><script type="text/javascript" src="/cuicui/components/launcher.jsp?pageId=schedulers_component&amp;page=schedulers&amp;dev=false"></script><style type="text/css"></style><script type="text/javascript">/*!
 * Socket.IO v2.2.0
 * (c) 2014-2018 Guillermo Rauch
 * Released under the MIT License.
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["io"] = factory();
	else
		root["io"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	/**
	 * Module dependencies.
	 */
	
	var url = __webpack_require__(1);
	var parser = __webpack_require__(7);
	var Manager = __webpack_require__(12);
	var debug = __webpack_require__(3)('socket.io-client');
	
	/**
	 * Module exports.
	 */
	
	module.exports = exports = lookup;
	
	/**
	 * Managers cache.
	 */
	
	var cache = exports.managers = {};
	
	/**
	 * Looks up an existing `Manager` for multiplexing.
	 * If the user summons:
	 *
	 *   `io('http://localhost/a');`
	 *   `io('http://localhost/b');`
	 *
	 * We reuse the existing instance based on same scheme/port/host,
	 * and we initialize sockets for each namespace.
	 *
	 * @api public
	 */
	
	function lookup(uri, opts) {
	  if ((typeof uri === 'undefined' ? 'undefined' : _typeof(uri)) === 'object') {
	    opts = uri;
	    uri = undefined;
	  }
	
	  opts = opts || {};
	
	  var parsed = url(uri);
	  var source = parsed.source;
	  var id = parsed.id;
	  var path = parsed.path;
	  var sameNamespace = cache[id] && path in cache[id].nsps;
	  var newConnection = opts.forceNew || opts['force new connection'] || false === opts.multiplex || sameNamespace;
	
	  var io;
	
	  if (newConnection) {
	    debug('ignoring socket cache for %s', source);
	    io = Manager(source, opts);
	  } else {
	    if (!cache[id]) {
	      debug('new io instance for %s', source);
	      cache[id] = Manager(source, opts);
	    }
	    io = cache[id];
	  }
	  if (parsed.query && !opts.query) {
	    opts.query = parsed.query;
	  }
	  return io.socket(parsed.path, opts);
	}
	
	/**
	 * Protocol version.
	 *
	 * @api public
	 */
	
	exports.protocol = parser.protocol;
	
	/**
	 * `connect`.
	 *
	 * @param {String} uri
	 * @api public
	 */
	
	exports.connect = lookup;
	
	/**
	 * Expose constructors for standalone build.
	 *
	 * @api public
	 */
	
	exports.Manager = __webpack_require__(12);
	exports.Socket = __webpack_require__(36);

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 * Module dependencies.
	 */
	
	var parseuri = __webpack_require__(2);
	var debug = __webpack_require__(3)('socket.io-client:url');
	
	/**
	 * Module exports.
	 */
	
	module.exports = url;
	
	/**
	 * URL parser.
	 *
	 * @param {String} url
	 * @param {Object} An object meant to mimic window.location.
	 *                 Defaults to window.location.
	 * @api public
	 */
	
	function url(uri, loc) {
	  var obj = uri;
	
	  // default to window.location
	  loc = loc || typeof location !== 'undefined' && location;
	  if (null == uri) uri = loc.protocol + '//' + loc.host;
	
	  // relative path support
	  if ('string' === typeof uri) {
	    if ('/' === uri.charAt(0)) {
	      if ('/' === uri.charAt(1)) {
	        uri = loc.protocol + uri;
	      } else {
	        uri = loc.host + uri;
	      }
	    }
	
	    if (!/^(https?|wss?):\/\//.test(uri)) {
	      debug('protocol-less url %s', uri);
	      if ('undefined' !== typeof loc) {
	        uri = loc.protocol + '//' + uri;
	      } else {
	        uri = 'https://' + uri;
	      }
	    }
	
	    // parse
	    debug('parse %s', uri);
	    obj = parseuri(uri);
	  }
	
	  // make sure we treat `localhost:80` and `localhost` equally
	  if (!obj.port) {
	    if (/^(http|ws)$/.test(obj.protocol)) {
	      obj.port = '80';
	    } else if (/^(http|ws)s$/.test(obj.protocol)) {
	      obj.port = '443';
	    }
	  }
	
	  obj.path = obj.path || '/';
	
	  var ipv6 = obj.host.indexOf(':') !== -1;
	  var host = ipv6 ? '[' + obj.host + ']' : obj.host;
	
	  // define unique id
	  obj.id = obj.protocol + '://' + host + ':' + obj.port;
	  // define href
	  obj.href = obj.protocol + '://' + host + (loc && loc.port === obj.port ? '' : ':' + obj.port);
	
	  return obj;
	}

/***/ }),
/* 2 */
/***/ (function(module, exports) {

	/**
	 * Parses an URI
	 *
	 * @author Steven Levithan <stevenlevithan.com> (MIT license)
	 * @api private
	 */
	
	var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
	
	var parts = [
	    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'
	];
	
	module.exports = function parseuri(str) {
	    var src = str,
	        b = str.indexOf('['),
	        e = str.indexOf(']');
	
	    if (b != -1 && e != -1) {
	        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);
	    }
	
	    var m = re.exec(str || ''),
	        uri = {},
	        i = 14;
	
	    while (i--) {
	        uri[parts[i]] = m[i] || '';
	    }
	
	    if (b != -1 && e != -1) {
	        uri.source = src;
	        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');
	        uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');
	        uri.ipv6uri = true;
	    }
	
	    return uri;
	};


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * This is the web browser implementation of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */
	
	exports = module.exports = __webpack_require__(5);
	exports.log = log;
	exports.formatArgs = formatArgs;
	exports.save = save;
	exports.load = load;
	exports.useColors = useColors;
	exports.storage = 'undefined' != typeof chrome
	               && 'undefined' != typeof chrome.storage
	                  ? chrome.storage.local
	                  : localstorage();
	
	/**
	 * Colors.
	 */
	
	exports.colors = [
	  '#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC',
	  '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF',
	  '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC',
	  '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF',
	  '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC',
	  '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033',
	  '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366',
	  '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933',
	  '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC',
	  '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF',
	  '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'
	];
	
	/**
	 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
	 * and the Firebug extension (any Firefox version) are known
	 * to support "%c" CSS customizations.
	 *
	 * TODO: add a `localStorage` variable to explicitly enable/disable colors
	 */
	
	function useColors() {
	  // NB: In an Electron preload script, document will be defined but not fully
	  // initialized. Since we know we're in Chrome, we'll just detect this case
	  // explicitly
	  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
	    return true;
	  }
	
	  // Internet Explorer and Edge do not support colors.
	  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
	    return false;
	  }
	
	  // is webkit? http://stackoverflow.com/a/16459606/376773
	  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
	    // is firebug? http://stackoverflow.com/a/398120/376773
	    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
	    // is firefox >= v31?
	    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
	    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
	    // double check webkit in userAgent just in case we are in a worker
	    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
	}
	
	/**
	 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
	 */
	
	exports.formatters.j = function(v) {
	  try {
	    return JSON.stringify(v);
	  } catch (err) {
	    return '[UnexpectedJSONParseError]: ' + err.message;
	  }
	};
	
	
	/**
	 * Colorize log arguments if enabled.
	 *
	 * @api public
	 */
	
	function formatArgs(args) {
	  var useColors = this.useColors;
	
	  args[0] = (useColors ? '%c' : '')
	    + this.namespace
	    + (useColors ? ' %c' : ' ')
	    + args[0]
	    + (useColors ? '%c ' : ' ')
	    + '+' + exports.humanize(this.diff);
	
	  if (!useColors) return;
	
	  var c = 'color: ' + this.color;
	  args.splice(1, 0, c, 'color: inherit')
	
	  // the final "%c" is somewhat tricky, because there could be other
	  // arguments passed either before or after the %c, so we need to
	  // figure out the correct index to insert the CSS into
	  var index = 0;
	  var lastC = 0;
	  args[0].replace(/%[a-zA-Z%]/g, function(match) {
	    if ('%%' === match) return;
	    index++;
	    if ('%c' === match) {
	      // we only are interested in the *last* %c
	      // (the user may have provided their own)
	      lastC = index;
	    }
	  });
	
	  args.splice(lastC, 0, c);
	}
	
	/**
	 * Invokes `console.log()` when available.
	 * No-op when `console.log` is not a "function".
	 *
	 * @api public
	 */
	
	function log() {
	  // this hackery is required for IE8/9, where
	  // the `console.log` function doesn't have 'apply'
	  return 'object' === typeof console
	    && console.log
	    && Function.prototype.apply.call(console.log, console, arguments);
	}
	
	/**
	 * Save `namespaces`.
	 *
	 * @param {String} namespaces
	 * @api private
	 */
	
	function save(namespaces) {
	  try {
	    if (null == namespaces) {
	      exports.storage.removeItem('debug');
	    } else {
	      exports.storage.debug = namespaces;
	    }
	  } catch(e) {}
	}
	
	/**
	 * Load `namespaces`.
	 *
	 * @return {String} returns the previously persisted debug modes
	 * @api private
	 */
	
	function load() {
	  var r;
	  try {
	    r = exports.storage.debug;
	  } catch(e) {}
	
	  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	  if (!r && typeof process !== 'undefined' && 'env' in process) {
	    r = process.env.DEBUG;
	  }
	
	  return r;
	}
	
	/**
	 * Enable namespaces listed in `localStorage.debug` initially.
	 */
	
	exports.enable(load());
	
	/**
	 * Localstorage attempts to return the localstorage.
	 *
	 * This is necessary because safari throws
	 * when a user disables cookies/localstorage
	 * and you attempt to access it.
	 *
	 * @return {LocalStorage}
	 * @api private
	 */
	
	function localstorage() {
	  try {
	    return window.localStorage;
	  } catch (e) {}
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ }),
/* 4 */
/***/ (function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};
	
	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.
	
	var cachedSetTimeout;
	var cachedClearTimeout;
	
	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }
	
	
	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }
	
	
	
	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	process.prependListener = noop;
	process.prependOnceListener = noop;
	
	process.listeners = function (name) { return [] }
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

	
	/**
	 * This is the common logic for both the Node.js and web browser
	 * implementations of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */
	
	exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
	exports.coerce = coerce;
	exports.disable = disable;
	exports.enable = enable;
	exports.enabled = enabled;
	exports.humanize = __webpack_require__(6);
	
	/**
	 * Active `debug` instances.
	 */
	exports.instances = [];
	
	/**
	 * The currently active debug mode names, and names to skip.
	 */
	
	exports.names = [];
	exports.skips = [];
	
	/**
	 * Map of special "%n" handling functions, for the debug "format" argument.
	 *
	 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	 */
	
	exports.formatters = {};
	
	/**
	 * Select a color.
	 * @param {String} namespace
	 * @return {Number}
	 * @api private
	 */
	
	function selectColor(namespace) {
	  var hash = 0, i;
	
	  for (i in namespace) {
	    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
	    hash |= 0; // Convert to 32bit integer
	  }
	
	  return exports.colors[Math.abs(hash) % exports.colors.length];
	}
	
	/**
	 * Create a debugger with the given `namespace`.
	 *
	 * @param {String} namespace
	 * @return {Function}
	 * @api public
	 */
	
	function createDebug(namespace) {
	
	  var prevTime;
	
	  function debug() {
	    // disabled?
	    if (!debug.enabled) return;
	
	    var self = debug;
	
	    // set `diff` timestamp
	    var curr = +new Date();
	    var ms = curr - (prevTime || curr);
	    self.diff = ms;
	    self.prev = prevTime;
	    self.curr = curr;
	    prevTime = curr;
	
	    // turn the `arguments` into a proper Array
	    var args = new Array(arguments.length);
	    for (var i = 0; i < args.length; i++) {
	      args[i] = arguments[i];
	    }
	
	    args[0] = exports.coerce(args[0]);
	
	    if ('string' !== typeof args[0]) {
	      // anything else let's inspect with %O
	      args.unshift('%O');
	    }
	
	    // apply any `formatters` transformations
	    var index = 0;
	    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
	      // if we encounter an escaped % then don't increase the array index
	      if (match === '%%') return match;
	      index++;
	      var formatter = exports.formatters[format];
	      if ('function' === typeof formatter) {
	        var val = args[index];
	        match = formatter.call(self, val);
	
	        // now we need to remove `args[index]` since it's inlined in the `format`
	        args.splice(index, 1);
	        index--;
	      }
	      return match;
	    });
	
	    // apply env-specific formatting (colors, etc.)
	    exports.formatArgs.call(self, args);
	
	    var logFn = debug.log || exports.log || console.log.bind(console);
	    logFn.apply(self, args);
	  }
	
	  debug.namespace = namespace;
	  debug.enabled = exports.enabled(namespace);
	  debug.useColors = exports.useColors();
	  debug.color = selectColor(namespace);
	  debug.destroy = destroy;
	
	  // env-specific initialization logic for debug instances
	  if ('function' === typeof exports.init) {
	    exports.init(debug);
	  }
	
	  exports.instances.push(debug);
	
	  return debug;
	}
	
	function destroy () {
	  var index = exports.instances.indexOf(this);
	  if (index !== -1) {
	    exports.instances.splice(index, 1);
	    return true;
	  } else {
	    return false;
	  }
	}
	
	/**
	 * Enables a debug mode by namespaces. This can include modes
	 * separated by a colon and wildcards.
	 *
	 * @param {String} namespaces
	 * @api public
	 */
	
	function enable(namespaces) {
	  exports.save(namespaces);
	
	  exports.names = [];
	  exports.skips = [];
	
	  var i;
	  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
	  var len = split.length;
	
	  for (i = 0; i < len; i++) {
	    if (!split[i]) continue; // ignore empty strings
	    namespaces = split[i].replace(/\*/g, '.*?');
	    if (namespaces[0] === '-') {
	      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
	    } else {
	      exports.names.push(new RegExp('^' + namespaces + '$'));
	    }
	  }
	
	  for (i = 0; i < exports.instances.length; i++) {
	    var instance = exports.instances[i];
	    instance.enabled = exports.enabled(instance.namespace);
	  }
	}
	
	/**
	 * Disable debug output.
	 *
	 * @api public
	 */
	
	function disable() {
	  exports.enable('');
	}
	
	/**
	 * Returns true if the given mode name is enabled, false otherwise.
	 *
	 * @param {String} name
	 * @return {Boolean}
	 * @api public
	 */
	
	function enabled(name) {
	  if (name[name.length - 1] === '*') {
	    return true;
	  }
	  var i, len;
	  for (i = 0, len = exports.skips.length; i < len; i++) {
	    if (exports.skips[i].test(name)) {
	      return false;
	    }
	  }
	  for (i = 0, len = exports.names.length; i < len; i++) {
	    if (exports.names[i].test(name)) {
	      return true;
	    }
	  }
	  return false;
	}
	
	/**
	 * Coerce `val`.
	 *
	 * @param {Mixed} val
	 * @return {Mixed}
	 * @api private
	 */
	
	function coerce(val) {
	  if (val instanceof Error) return val.stack || val.message;
	  return val;
	}


/***/ }),
/* 6 */
/***/ (function(module, exports) {

	/**
	 * Helpers.
	 */
	
	var s = 1000;
	var m = s * 60;
	var h = m * 60;
	var d = h * 24;
	var y = d * 365.25;
	
	/**
	 * Parse or format the given `val`.
	 *
	 * Options:
	 *
	 *  - `long` verbose formatting [false]
	 *
	 * @param {String|Number} val
	 * @param {Object} [options]
	 * @throws {Error} throw an error if val is not a non-empty string or a number
	 * @return {String|Number}
	 * @api public
	 */
	
	module.exports = function(val, options) {
	  options = options || {};
	  var type = typeof val;
	  if (type === 'string' && val.length > 0) {
	    return parse(val);
	  } else if (type === 'number' && isNaN(val) === false) {
	    return options.long ? fmtLong(val) : fmtShort(val);
	  }
	  throw new Error(
	    'val is not a non-empty string or a valid number. val=' +
	      JSON.stringify(val)
	  );
	};
	
	/**
	 * Parse the given `str` and return milliseconds.
	 *
	 * @param {String} str
	 * @return {Number}
	 * @api private
	 */
	
	function parse(str) {
	  str = String(str);
	  if (str.length > 100) {
	    return;
	  }
	  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
	    str
	  );
	  if (!match) {
	    return;
	  }
	  var n = parseFloat(match[1]);
	  var type = (match[2] || 'ms').toLowerCase();
	  switch (type) {
	    case 'years':
	    case 'year':
	    case 'yrs':
	    case 'yr':
	    case 'y':
	      return n * y;
	    case 'days':
	    case 'day':
	    case 'd':
	      return n * d;
	    case 'hours':
	    case 'hour':
	    case 'hrs':
	    case 'hr':
	    case 'h':
	      return n * h;
	    case 'minutes':
	    case 'minute':
	    case 'mins':
	    case 'min':
	    case 'm':
	      return n * m;
	    case 'seconds':
	    case 'second':
	    case 'secs':
	    case 'sec':
	    case 's':
	      return n * s;
	    case 'milliseconds':
	    case 'millisecond':
	    case 'msecs':
	    case 'msec':
	    case 'ms':
	      return n;
	    default:
	      return undefined;
	  }
	}
	
	/**
	 * Short format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */
	
	function fmtShort(ms) {
	  if (ms >= d) {
	    return Math.round(ms / d) + 'd';
	  }
	  if (ms >= h) {
	    return Math.round(ms / h) + 'h';
	  }
	  if (ms >= m) {
	    return Math.round(ms / m) + 'm';
	  }
	  if (ms >= s) {
	    return Math.round(ms / s) + 's';
	  }
	  return ms + 'ms';
	}
	
	/**
	 * Long format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */
	
	function fmtLong(ms) {
	  return plural(ms, d, 'day') ||
	    plural(ms, h, 'hour') ||
	    plural(ms, m, 'minute') ||
	    plural(ms, s, 'second') ||
	    ms + ' ms';
	}
	
	/**
	 * Pluralization helper.
	 */
	
	function plural(ms, n, name) {
	  if (ms < n) {
	    return;
	  }
	  if (ms < n * 1.5) {
	    return Math.floor(ms / n) + ' ' + name;
	  }
	  return Math.ceil(ms / n) + ' ' + name + 's';
	}


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

	
	/**
	 * Module dependencies.
	 */
	
	var debug = __webpack_require__(3)('socket.io-parser');
	var Emitter = __webpack_require__(8);
	var binary = __webpack_require__(9);
	var isArray = __webpack_require__(10);
	var isBuf = __webpack_require__(11);
	
	/**
	 * Protocol version.
	 *
	 * @api public
	 */
	
	exports.protocol = 4;
	
	/**
	 * Packet types.
	 *
	 * @api public
	 */
	
	exports.types = [
	  'CONNECT',
	  'DISCONNECT',
	  'EVENT',
	  'ACK',
	  'ERROR',
	  'BINARY_EVENT',
	  'BINARY_ACK'
	];
	
	/**
	 * Packet type `connect`.
	 *
	 * @api public
	 */
	
	exports.CONNECT = 0;
	
	/**
	 * Packet type `disconnect`.
	 *
	 * @api public
	 */
	
	exports.DISCONNECT = 1;
	
	/**
	 * Packet type `event`.
	 *
	 * @api public
	 */
	
	exports.EVENT = 2;
	
	/**
	 * Packet type `ack`.
	 *
	 * @api public
	 */
	
	exports.ACK = 3;
	
	/**
	 * Packet type `error`.
	 *
	 * @api public
	 */
	
	exports.ERROR = 4;
	
	/**
	 * Packet type 'binary event'
	 *
	 * @api public
	 */
	
	exports.BINARY_EVENT = 5;
	
	/**
	 * Packet type `binary ack`. For acks with binary arguments.
	 *
	 * @api public
	 */
	
	exports.BINARY_ACK = 6;
	
	/**
	 * Encoder constructor.
	 *
	 * @api public
	 */
	
	exports.Encoder = Encoder;
	
	/**
	 * Decoder constructor.
	 *
	 * @api public
	 */
	
	exports.Decoder = Decoder;
	
	/**
	 * A socket.io Encoder instance
	 *
	 * @api public
	 */
	
	function Encoder() {}
	
	var ERROR_PACKET = exports.ERROR + '"encode error"';
	
	/**
	 * Encode a packet as a single string if non-binary, or as a
	 * buffer sequence, depending on packet type.
	 *
	 * @param {Object} obj - packet object
	 * @param {Function} callback - function to handle encodings (likely engine.write)
	 * @return Calls callback with Array of encodings
	 * @api public
	 */
	
	Encoder.prototype.encode = function(obj, callback){
	  debug('encoding packet %j', obj);
	
	  if (exports.BINARY_EVENT === obj.type || exports.BINARY_ACK === obj.type) {
	    encodeAsBinary(obj, callback);
	  } else {
	    var encoding = encodeAsString(obj);
	    callback([encoding]);
	  }
	};
	
	/**
	 * Encode packet as string.
	 *
	 * @param {Object} packet
	 * @return {String} encoded
	 * @api private
	 */
	
	function encodeAsString(obj) {
	
	  // first is type
	  var str = '' + obj.type;
	
	  // attachments if we have them
	  if (exports.BINARY_EVENT === obj.type || exports.BINARY_ACK === obj.type) {
	    str += obj.attachments + '-';
	  }
	
	  // if we have a namespace other than `/`
	  // we append it followed by a comma `,`
	  if (obj.nsp && '/' !== obj.nsp) {
	    str += obj.nsp + ',';
	  }
	
	  // immediately followed by the id
	  if (null != obj.id) {
	    str += obj.id;
	  }
	
	  // json data
	  if (null != obj.data) {
	    var payload = tryStringify(obj.data);
	    if (payload !== false) {
	      str += payload;
	    } else {
	      return ERROR_PACKET;
	    }
	  }
	
	  debug('encoded %j as %s', obj, str);
	  return str;
	}
	
	function tryStringify(str) {
	  try {
	    return JSON.stringify(str);
	  } catch(e){
	    return false;
	  }
	}
	
	/**
	 * Encode packet as 'buffer sequence' by removing blobs, and
	 * deconstructing packet into object with placeholders and
	 * a list of buffers.
	 *
	 * @param {Object} packet
	 * @return {Buffer} encoded
	 * @api private
	 */
	
	function encodeAsBinary(obj, callback) {
	
	  function writeEncoding(bloblessData) {
	    var deconstruction = binary.deconstructPacket(bloblessData);
	    var pack = encodeAsString(deconstruction.packet);
	    var buffers = deconstruction.buffers;
	
	    buffers.unshift(pack); // add packet info to beginning of data list
	    callback(buffers); // write all the buffers
	  }
	
	  binary.removeBlobs(obj, writeEncoding);
	}
	
	/**
	 * A socket.io Decoder instance
	 *
	 * @return {Object} decoder
	 * @api public
	 */
	
	function Decoder() {
	  this.reconstructor = null;
	}
	
	/**
	 * Mix in `Emitter` with Decoder.
	 */
	
	Emitter(Decoder.prototype);
	
	/**
	 * Decodes an encoded packet string into packet JSON.
	 *
	 * @param {String} obj - encoded packet
	 * @return {Object} packet
	 * @api public
	 */
	
	Decoder.prototype.add = function(obj) {
	  var packet;
	  if (typeof obj === 'string') {
	    packet = decodeString(obj);
	    if (exports.BINARY_EVENT === packet.type || exports.BINARY_ACK === packet.type) { // binary packet's json
	      this.reconstructor = new BinaryReconstructor(packet);
	
	      // no attachments, labeled binary but no binary data to follow
	      if (this.reconstructor.reconPack.attachments === 0) {
	        this.emit('decoded', packet);
	      }
	    } else { // non-binary full packet
	      this.emit('decoded', packet);
	    }
	  } else if (isBuf(obj) || obj.base64) { // raw binary data
	    if (!this.reconstructor) {
	      throw new Error('got binary data when not reconstructing a packet');
	    } else {
	      packet = this.reconstructor.takeBinaryData(obj);
	      if (packet) { // received final buffer
	        this.reconstructor = null;
	        this.emit('decoded', packet);
	      }
	    }
	  } else {
	    throw new Error('Unknown type: ' + obj);
	  }
	};
	
	/**
	 * Decode a packet String (JSON data)
	 *
	 * @param {String} str
	 * @return {Object} packet
	 * @api private
	 */
	
	function decodeString(str) {
	  var i = 0;
	  // look up type
	  var p = {
	    type: Number(str.charAt(0))
	  };
	
	  if (null == exports.types[p.type]) {
	    return error('unknown packet type ' + p.type);
	  }
	
	  // look up attachments if type binary
	  if (exports.BINARY_EVENT === p.type || exports.BINARY_ACK === p.type) {
	    var buf = '';
	    while (str.charAt(++i) !== '-') {
	      buf += str.charAt(i);
	      if (i == str.length) break;
	    }
	    if (buf != Number(buf) || str.charAt(i) !== '-') {
	      throw new Error('Illegal attachments');
	    }
	    p.attachments = Number(buf);
	  }
	
	  // look up namespace (if any)
	  if ('/' === str.charAt(i + 1)) {
	    p.nsp = '';
	    while (++i) {
	      var c = str.charAt(i);
	      if (',' === c) break;
	      p.nsp += c;
	      if (i === str.length) break;
	    }
	  } else {
	    p.nsp = '/';
	  }
	
	  // look up id
	  var next = str.charAt(i + 1);
	  if ('' !== next && Number(next) == next) {
	    p.id = '';
	    while (++i) {
	      var c = str.charAt(i);
	      if (null == c || Number(c) != c) {
	        --i;
	        break;
	      }
	      p.id += str.charAt(i);
	      if (i === str.length) break;
	    }
	    p.id = Number(p.id);
	  }
	
	  // look up json data
	  if (str.charAt(++i)) {
	    var payload = tryParse(str.substr(i));
	    var isPayloadValid = payload !== false && (p.type === exports.ERROR || isArray(payload));
	    if (isPayloadValid) {
	      p.data = payload;
	    } else {
	      return error('invalid payload');
	    }
	  }
	
	  debug('decoded %s as %j', str, p);
	  return p;
	}
	
	function tryParse(str) {
	  try {
	    return JSON.parse(str);
	  } catch(e){
	    return false;
	  }
	}
	
	/**
	 * Deallocates a parser's resources
	 *
	 * @api public
	 */
	
	Decoder.prototype.destroy = function() {
	  if (this.reconstructor) {
	    this.reconstructor.finishedReconstruction();
	  }
	};
	
	/**
	 * A manager of a binary event's 'buffer sequence'. Should
	 * be constructed whenever a packet of type BINARY_EVENT is
	 * decoded.
	 *
	 * @param {Object} packet
	 * @return {BinaryReconstructor} initialized reconstructor
	 * @api private
	 */
	
	function BinaryReconstructor(packet) {
	  this.reconPack = packet;
	  this.buffers = [];
	}
	
	/**
	 * Method to be called when binary data received from connection
	 * after a BINARY_EVENT packet.
	 *
	 * @param {Buffer | ArrayBuffer} binData - the raw binary data received
	 * @return {null | Object} returns null if more binary data is expected or
	 *   a reconstructed packet object if all buffers have been received.
	 * @api private
	 */
	
	BinaryReconstructor.prototype.takeBinaryData = function(binData) {
	  this.buffers.push(binData);
	  if (this.buffers.length === this.reconPack.attachments) { // done with buffer list
	    var packet = binary.reconstructPacket(this.reconPack, this.buffers);
	    this.finishedReconstruction();
	    return packet;
	  }
	  return null;
	};
	
	/**
	 * Cleans up binary packet reconstruction variables.
	 *
	 * @api private
	 */
	
	BinaryReconstructor.prototype.finishedReconstruction = function() {
	  this.reconPack = null;
	  this.buffers = [];
	};
	
	function error(msg) {
	  return {
	    type: exports.ERROR,
	    data: 'parser error: ' + msg
	  };
	}


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

	
	/**
	 * Expose `Emitter`.
	 */
	
	if (true) {
	  module.exports = Emitter;
	}
	
	/**
	 * Initialize a new `Emitter`.
	 *
	 * @api public
	 */
	
	function Emitter(obj) {
	  if (obj) return mixin(obj);
	};
	
	/**
	 * Mixin the emitter properties.
	 *
	 * @param {Object} obj
	 * @return {Object}
	 * @api private
	 */
	
	function mixin(obj) {
	  for (var key in Emitter.prototype) {
	    obj[key] = Emitter.prototype[key];
	  }
	  return obj;
	}
	
	/**
	 * Listen on the given `event` with `fn`.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */
	
	Emitter.prototype.on =
	Emitter.prototype.addEventListener = function(event, fn){
	  this._callbacks = this._callbacks || {};
	  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
	    .push(fn);
	  return this;
	};
	
	/**
	 * Adds an `event` listener that will be invoked a single
	 * time then automatically removed.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */
	
	Emitter.prototype.once = function(event, fn){
	  function on() {
	    this.off(event, on);
	    fn.apply(this, arguments);
	  }
	
	  on.fn = fn;
	  this.on(event, on);
	  return this;
	};
	
	/**
	 * Remove the given callback for `event` or all
	 * registered callbacks.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */
	
	Emitter.prototype.off =
	Emitter.prototype.removeListener =
	Emitter.prototype.removeAllListeners =
	Emitter.prototype.removeEventListener = function(event, fn){
	  this._callbacks = this._callbacks || {};
	
	  // all
	  if (0 == arguments.length) {
	    this._callbacks = {};
	    return this;
	  }
	
	  // specific event
	  var callbacks = this._callbacks['$' + event];
	  if (!callbacks) return this;
	
	  // remove all handlers
	  if (1 == arguments.length) {
	    delete this._callbacks['$' + event];
	    return this;
	  }
	
	  // remove specific handler
	  var cb;
	  for (var i = 0; i < callbacks.length; i++) {
	    cb = callbacks[i];
	    if (cb === fn || cb.fn === fn) {
	      callbacks.splice(i, 1);
	      break;
	    }
	  }
	  return this;
	};
	
	/**
	 * Emit `event` with the given args.
	 *
	 * @param {String} event
	 * @param {Mixed} ...
	 * @return {Emitter}
	 */
	
	Emitter.prototype.emit = function(event){
	  this._callbacks = this._callbacks || {};
	  var args = [].slice.call(arguments, 1)
	    , callbacks = this._callbacks['$' + event];
	
	  if (callbacks) {
	    callbacks = callbacks.slice(0);
	    for (var i = 0, len = callbacks.length; i < len; ++i) {
	      callbacks[i].apply(this, args);
	    }
	  }
	
	  return this;
	};
	
	/**
	 * Return array of callbacks for `event`.
	 *
	 * @param {String} event
	 * @return {Array}
	 * @api public
	 */
	
	Emitter.prototype.listeners = function(event){
	  this._callbacks = this._callbacks || {};
	  return this._callbacks['$' + event] || [];
	};
	
	/**
	 * Check if this emitter has `event` handlers.
	 *
	 * @param {String} event
	 * @return {Boolean}
	 * @api public
	 */
	
	Emitter.prototype.hasListeners = function(event){
	  return !! this.listeners(event).length;
	};


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

	/*global Blob,File*/
	
	/**
	 * Module requirements
	 */
	
	var isArray = __webpack_require__(10);
	var isBuf = __webpack_require__(11);
	var toString = Object.prototype.toString;
	var withNativeBlob = typeof Blob === 'function' || (typeof Blob !== 'undefined' && toString.call(Blob) === '[object BlobConstructor]');
	var withNativeFile = typeof File === 'function' || (typeof File !== 'undefined' && toString.call(File) === '[object FileConstructor]');
	
	/**
	 * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.
	 * Anything with blobs or files should be fed through removeBlobs before coming
	 * here.
	 *
	 * @param {Object} packet - socket.io event packet
	 * @return {Object} with deconstructed packet and list of buffers
	 * @api public
	 */
	
	exports.deconstructPacket = function(packet) {
	  var buffers = [];
	  var packetData = packet.data;
	  var pack = packet;
	  pack.data = _deconstructPacket(packetData, buffers);
	  pack.attachments = buffers.length; // number of binary 'attachments'
	  return {packet: pack, buffers: buffers};
	};
	
	function _deconstructPacket(data, buffers) {
	  if (!data) return data;
	
	  if (isBuf(data)) {
	    var placeholder = { _placeholder: true, num: buffers.length };
	    buffers.push(data);
	    return placeholder;
	  } else if (isArray(data)) {
	    var newData = new Array(data.length);
	    for (var i = 0; i < data.length; i++) {
	      newData[i] = _deconstructPacket(data[i], buffers);
	    }
	    return newData;
	  } else if (typeof data === 'object' && !(data instanceof Date)) {
	    var newData = {};
	    for (var key in data) {
	      newData[key] = _deconstructPacket(data[key], buffers);
	    }
	    return newData;
	  }
	  return data;
	}
	
	/**
	 * Reconstructs a binary packet from its placeholder packet and buffers
	 *
	 * @param {Object} packet - event packet with placeholders
	 * @param {Array} buffers - binary buffers to put in placeholder positions
	 * @return {Object} reconstructed packet
	 * @api public
	 */
	
	exports.reconstructPacket = function(packet, buffers) {
	  packet.data = _reconstructPacket(packet.data, buffers);
	  packet.attachments = undefined; // no longer useful
	  return packet;
	};
	
	function _reconstructPacket(data, buffers) {
	  if (!data) return data;
	
	  if (data && data._placeholder) {
	    return buffers[data.num]; // appropriate buffer (should be natural order anyway)
	  } else if (isArray(data)) {
	    for (var i = 0; i < data.length; i++) {
	      data[i] = _reconstructPacket(data[i], buffers);
	    }
	  } else if (typeof data === 'object') {
	    for (var key in data) {
	      data[key] = _reconstructPacket(data[key], buffers);
	    }
	  }
	
	  return data;
	}
	
	/**
	 * Asynchronously removes Blobs or Files from data via
	 * FileReader's readAsArrayBuffer method. Used before encoding
	 * data as msgpack. Calls callback with the blobless data.
	 *
	 * @param {Object} data
	 * @param {Function} callback
	 * @api private
	 */
	
	exports.removeBlobs = function(data, callback) {
	  function _removeBlobs(obj, curKey, containingObject) {
	    if (!obj) return obj;
	
	    // convert any blob
	    if ((withNativeBlob && obj instanceof Blob) ||
	        (withNativeFile && obj instanceof File)) {
	      pendingBlobs++;
	
	      // async filereader
	      var fileReader = new FileReader();
	      fileReader.onload = function() { // this.result == arraybuffer
	        if (containingObject) {
	          containingObject[curKey] = this.result;
	        }
	        else {
	          bloblessData = this.result;
	        }
	
	        // if nothing pending its callback time
	        if(! --pendingBlobs) {
	          callback(bloblessData);
	        }
	      };
	
	      fileReader.readAsArrayBuffer(obj); // blob -> arraybuffer
	    } else if (isArray(obj)) { // handle array
	      for (var i = 0; i < obj.length; i++) {
	        _removeBlobs(obj[i], i, obj);
	      }
	    } else if (typeof obj === 'object' && !isBuf(obj)) { // and object
	      for (var key in obj) {
	        _removeBlobs(obj[key], key, obj);
	      }
	    }
	  }
	
	  var pendingBlobs = 0;
	  var bloblessData = data;
	  _removeBlobs(bloblessData);
	  if (!pendingBlobs) {
	    callback(bloblessData);
	  }
	};


/***/ }),
/* 10 */
/***/ (function(module, exports) {

	var toString = {}.toString;
	
	module.exports = Array.isArray || function (arr) {
	  return toString.call(arr) == '[object Array]';
	};


/***/ }),
/* 11 */
/***/ (function(module, exports) {

	
	module.exports = isBuf;
	
	var withNativeBuffer = typeof Buffer === 'function' && typeof Buffer.isBuffer === 'function';
	var withNativeArrayBuffer = typeof ArrayBuffer === 'function';
	
	var isView = function (obj) {
	  return typeof ArrayBuffer.isView === 'function' ? ArrayBuffer.isView(obj) : (obj.buffer instanceof ArrayBuffer);
	};
	
	/**
	 * Returns true if obj is a buffer or an arraybuffer.
	 *
	 * @api private
	 */
	
	function isBuf(obj) {
	  return (withNativeBuffer && Buffer.isBuffer(obj)) ||
	          (withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj)));
	}


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	/**
	 * Module dependencies.
	 */
	
	var eio = __webpack_require__(13);
	var Socket = __webpack_require__(36);
	var Emitter = __webpack_require__(8);
	var parser = __webpack_require__(7);
	var on = __webpack_require__(38);
	var bind = __webpack_require__(39);
	var debug = __webpack_require__(3)('socket.io-client:manager');
	var indexOf = __webpack_require__(35);
	var Backoff = __webpack_require__(40);
	
	/**
	 * IE6+ hasOwnProperty
	 */
	
	var has = Object.prototype.hasOwnProperty;
	
	/**
	 * Module exports
	 */
	
	module.exports = Manager;
	
	/**
	 * `Manager` constructor.
	 *
	 * @param {String} engine instance or engine uri/opts
	 * @param {Object} options
	 * @api public
	 */
	
	function Manager(uri, opts) {
	  if (!(this instanceof Manager)) return new Manager(uri, opts);
	  if (uri && 'object' === (typeof uri === 'undefined' ? 'undefined' : _typeof(uri))) {
	    opts = uri;
	    uri = undefined;
	  }
	  opts = opts || {};
	
	  opts.path = opts.path || '/socket.io';
	  this.nsps = {};
	  this.subs = [];
	  this.opts = opts;
	  this.reconnection(opts.reconnection !== false);
	  this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
	  this.reconnectionDelay(opts.reconnectionDelay || 1000);
	  this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);
	  this.randomizationFactor(opts.randomizationFactor || 0.5);
	  this.backoff = new Backoff({
	    min: this.reconnectionDelay(),
	    max: this.reconnectionDelayMax(),
	    jitter: this.randomizationFactor()
	  });
	  this.timeout(null == opts.timeout ? 20000 : opts.timeout);
	  this.readyState = 'closed';
	  this.uri = uri;
	  this.connecting = [];
	  this.lastPing = null;
	  this.encoding = false;
	  this.packetBuffer = [];
	  var _parser = opts.parser || parser;
	  this.encoder = new _parser.Encoder();
	  this.decoder = new _parser.Decoder();
	  this.autoConnect = opts.autoConnect !== false;
	  if (this.autoConnect) this.open();
	}
	
	/**
	 * Propagate given event to sockets and emit on `this`
	 *
	 * @api private
	 */
	
	Manager.prototype.emitAll = function () {
	  this.emit.apply(this, arguments);
	  for (var nsp in this.nsps) {
	    if (has.call(this.nsps, nsp)) {
	      this.nsps[nsp].emit.apply(this.nsps[nsp], arguments);
	    }
	  }
	};
	
	/**
	 * Update `socket.id` of all sockets
	 *
	 * @api private
	 */
	
	Manager.prototype.updateSocketIds = function () {
	  for (var nsp in this.nsps) {
	    if (has.call(this.nsps, nsp)) {
	      this.nsps[nsp].id = this.generateId(nsp);
	    }
	  }
	};
	
	/**
	 * generate `socket.id` for the given `nsp`
	 *
	 * @param {String} nsp
	 * @return {String}
	 * @api private
	 */
	
	Manager.prototype.generateId = function (nsp) {
	  return (nsp === '/' ? '' : nsp + '#') + this.engine.id;
	};
	
	/**
	 * Mix in `Emitter`.
	 */
	
	Emitter(Manager.prototype);
	
	/**
	 * Sets the `reconnection` config.
	 *
	 * @param {Boolean} true/false if it should automatically reconnect
	 * @return {Manager} self or value
	 * @api public
	 */
	
	Manager.prototype.reconnection = function (v) {
	  if (!arguments.length) return this._reconnection;
	  this._reconnection = !!v;
	  return this;
	};
	
	/**
	 * Sets the reconnection attempts config.
	 *
	 * @param {Number} max reconnection attempts before giving up
	 * @return {Manager} self or value
	 * @api public
	 */
	
	Manager.prototype.reconnectionAttempts = function (v) {
	  if (!arguments.length) return this._reconnectionAttempts;
	  this._reconnectionAttempts = v;
	  return this;
	};
	
	/**
	 * Sets the delay between reconnections.
	 *
	 * @param {Number} delay
	 * @return {Manager} self or value
	 * @api public
	 */
	
	Manager.prototype.reconnectionDelay = function (v) {
	  if (!arguments.length) return this._reconnectionDelay;
	  this._reconnectionDelay = v;
	  this.backoff && this.backoff.setMin(v);
	  return this;
	};
	
	Manager.prototype.randomizationFactor = function (v) {
	  if (!arguments.length) return this._randomizationFactor;
	  this._randomizationFactor = v;
	  this.backoff && this.backoff.setJitter(v);
	  return this;
	};
	
	/**
	 * Sets the maximum delay between reconnections.
	 *
	 * @param {Number} delay
	 * @return {Manager} self or value
	 * @api public
	 */
	
	Manager.prototype.reconnectionDelayMax = function (v) {
	  if (!arguments.length) return this._reconnectionDelayMax;
	  this._reconnectionDelayMax = v;
	  this.backoff && this.backoff.setMax(v);
	  return this;
	};
	
	/**
	 * Sets the connection timeout. `false` to disable
	 *
	 * @return {Manager} self or value
	 * @api public
	 */
	
	Manager.prototype.timeout = function (v) {
	  if (!arguments.length) return this._timeout;
	  this._timeout = v;
	  return this;
	};
	
	/**
	 * Starts trying to reconnect if reconnection is enabled and we have not
	 * started reconnecting yet
	 *
	 * @api private
	 */
	
	Manager.prototype.maybeReconnectOnOpen = function () {
	  // Only try to reconnect if it's the first time we're connecting
	  if (!this.reconnecting && this._reconnection && this.backoff.attempts === 0) {
	    // keeps reconnection from firing twice for the same reconnection loop
	    this.reconnect();
	  }
	};
	
	/**
	 * Sets the current transport `socket`.
	 *
	 * @param {Function} optional, callback
	 * @return {Manager} self
	 * @api public
	 */
	
	Manager.prototype.open = Manager.prototype.connect = function (fn, opts) {
	  debug('readyState %s', this.readyState);
	  if (~this.readyState.indexOf('open')) return this;
	
	  debug('opening %s', this.uri);
	  this.engine = eio(this.uri, this.opts);
	  var socket = this.engine;
	  var self = this;
	  this.readyState = 'opening';
	  this.skipReconnect = false;
	
	  // emit `open`
	  var openSub = on(socket, 'open', function () {
	    self.onopen();
	    fn && fn();
	  });
	
	  // emit `connect_error`
	  var errorSub = on(socket, 'error', function (data) {
	    debug('connect_error');
	    self.cleanup();
	    self.readyState = 'closed';
	    self.emitAll('connect_error', data);
	    if (fn) {
	      var err = new Error('Connection error');
	      err.data = data;
	      fn(err);
	    } else {
	      // Only do this if there is no fn to handle the error
	      self.maybeReconnectOnOpen();
	    }
	  });
	
	  // emit `connect_timeout`
	  if (false !== this._timeout) {
	    var timeout = this._timeout;
	    debug('connect attempt will timeout after %d', timeout);
	
	    // set timer
	    var timer = setTimeout(function () {
	      debug('connect attempt timed out after %d', timeout);
	      openSub.destroy();
	      socket.close();
	      socket.emit('error', 'timeout');
	      self.emitAll('connect_timeout', timeout);
	    }, timeout);
	
	    this.subs.push({
	      destroy: function destroy() {
	        clearTimeout(timer);
	      }
	    });
	  }
	
	  this.subs.push(openSub);
	  this.subs.push(errorSub);
	
	  return this;
	};
	
	/**
	 * Called upon transport open.
	 *
	 * @api private
	 */
	
	Manager.prototype.onopen = function () {
	  debug('open');
	
	  // clear old subs
	  this.cleanup();
	
	  // mark as open
	  this.readyState = 'open';
	  this.emit('open');
	
	  // add new subs
	  var socket = this.engine;
	  this.subs.push(on(socket, 'data', bind(this, 'ondata')));
	  this.subs.push(on(socket, 'ping', bind(this, 'onping')));
	  this.subs.push(on(socket, 'pong', bind(this, 'onpong')));
	  this.subs.push(on(socket, 'error', bind(this, 'onerror')));
	  this.subs.push(on(socket, 'close', bind(this, 'onclose')));
	  this.subs.push(on(this.decoder, 'decoded', bind(this, 'ondecoded')));
	};
	
	/**
	 * Called upon a ping.
	 *
	 * @api private
	 */
	
	Manager.prototype.onping = function () {
	  this.lastPing = new Date();
	  this.emitAll('ping');
	};
	
	/**
	 * Called upon a packet.
	 *
	 * @api private
	 */
	
	Manager.prototype.onpong = function () {
	  this.emitAll('pong', new Date() - this.lastPing);
	};
	
	/**
	 * Called with data.
	 *
	 * @api private
	 */
	
	Manager.prototype.ondata = function (data) {
	  this.decoder.add(data);
	};
	
	/**
	 * Called when parser fully decodes a packet.
	 *
	 * @api private
	 */
	
	Manager.prototype.ondecoded = function (packet) {
	  this.emit('packet', packet);
	};
	
	/**
	 * Called upon socket error.
	 *
	 * @api private
	 */
	
	Manager.prototype.onerror = function (err) {
	  debug('error', err);
	  this.emitAll('error', err);
	};
	
	/**
	 * Creates a new socket for the given `nsp`.
	 *
	 * @return {Socket}
	 * @api public
	 */
	
	Manager.prototype.socket = function (nsp, opts) {
	  var socket = this.nsps[nsp];
	  if (!socket) {
	    socket = new Socket(this, nsp, opts);
	    this.nsps[nsp] = socket;
	    var self = this;
	    socket.on('connecting', onConnecting);
	    socket.on('connect', function () {
	      socket.id = self.generateId(nsp);
	    });
	
	    if (this.autoConnect) {
	      // manually call here since connecting event is fired before listening
	      onConnecting();
	    }
	  }
	
	  function onConnecting() {
	    if (!~indexOf(self.connecting, socket)) {
	      self.connecting.push(socket);
	    }
	  }
	
	  return socket;
	};
	
	/**
	 * Called upon a socket close.
	 *
	 * @param {Socket} socket
	 */
	
	Manager.prototype.destroy = function (socket) {
	  var index = indexOf(this.connecting, socket);
	  if (~index) this.connecting.splice(index, 1);
	  if (this.connecting.length) return;
	
	  this.close();
	};
	
	/**
	 * Writes a packet.
	 *
	 * @param {Object} packet
	 * @api private
	 */
	
	Manager.prototype.packet = function (packet) {
	  debug('writing packet %j', packet);
	  var self = this;
	  if (packet.query && packet.type === 0) packet.nsp += '?' + packet.query;
	
	  if (!self.encoding) {
	    // encode, then write to engine with result
	    self.encoding = true;
	    this.encoder.encode(packet, function (encodedPackets) {
	      for (var i = 0; i < encodedPackets.length; i++) {
	        self.engine.write(encodedPackets[i], packet.options);
	      }
	      self.encoding = false;
	      self.processPacketQueue();
	    });
	  } else {
	    // add packet to the queue
	    self.packetBuffer.push(packet);
	  }
	};
	
	/**
	 * If packet buffer is non-empty, begins encoding the
	 * next packet in line.
	 *
	 * @api private
	 */
	
	Manager.prototype.processPacketQueue = function () {
	  if (this.packetBuffer.length > 0 && !this.encoding) {
	    var pack = this.packetBuffer.shift();
	    this.packet(pack);
	  }
	};
	
	/**
	 * Clean up transport subscriptions and packet buffer.
	 *
	 * @api private
	 */
	
	Manager.prototype.cleanup = function () {
	  debug('cleanup');
	
	  var subsLength = this.subs.length;
	  for (var i = 0; i < subsLength; i++) {
	    var sub = this.subs.shift();
	    sub.destroy();
	  }
	
	  this.packetBuffer = [];
	  this.encoding = false;
	  this.lastPing = null;
	
	  this.decoder.destroy();
	};
	
	/**
	 * Close the current socket.
	 *
	 * @api private
	 */
	
	Manager.prototype.close = Manager.prototype.disconnect = function () {
	  debug('disconnect');
	  this.skipReconnect = true;
	  this.reconnecting = false;
	  if ('opening' === this.readyState) {
	    // `onclose` will not fire because
	    // an open event never happened
	    this.cleanup();
	  }
	  this.backoff.reset();
	  this.readyState = 'closed';
	  if (this.engine) this.engine.close();
	};
	
	/**
	 * Called upon engine close.
	 *
	 * @api private
	 */
	
	Manager.prototype.onclose = function (reason) {
	  debug('onclose');
	
	  this.cleanup();
	  this.backoff.reset();
	  this.readyState = 'closed';
	  this.emit('close', reason);
	
	  if (this._reconnection && !this.skipReconnect) {
	    this.reconnect();
	  }
	};
	
	/**
	 * Attempt a reconnection.
	 *
	 * @api private
	 */
	
	Manager.prototype.reconnect = function () {
	  if (this.reconnecting || this.skipReconnect) return this;
	
	  var self = this;
	
	  if (this.backoff.attempts >= this._reconnectionAttempts) {
	    debug('reconnect failed');
	    this.backoff.reset();
	    this.emitAll('reconnect_failed');
	    this.reconnecting = false;
	  } else {
	    var delay = this.backoff.duration();
	    debug('will wait %dms before reconnect attempt', delay);
	
	    this.reconnecting = true;
	    var timer = setTimeout(function () {
	      if (self.skipReconnect) return;
	
	      debug('attempting reconnect');
	      self.emitAll('reconnect_attempt', self.backoff.attempts);
	      self.emitAll('reconnecting', self.backoff.attempts);
	
	      // check again for the case socket closed in above events
	      if (self.skipReconnect) return;
	
	      self.open(function (err) {
	        if (err) {
	          debug('reconnect attempt error');
	          self.reconnecting = false;
	          self.reconnect();
	          self.emitAll('reconnect_error', err.data);
	        } else {
	          debug('reconnect success');
	          self.onreconnect();
	        }
	      });
	    }, delay);
	
	    this.subs.push({
	      destroy: function destroy() {
	        clearTimeout(timer);
	      }
	    });
	  }
	};
	
	/**
	 * Called upon successful reconnect.
	 *
	 * @api private
	 */
	
	Manager.prototype.onreconnect = function () {
	  var attempt = this.backoff.attempts;
	  this.reconnecting = false;
	  this.backoff.reset();
	  this.updateSocketIds();
	  this.emitAll('reconnect', attempt);
	};

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

	
	module.exports = __webpack_require__(14);
	
	/**
	 * Exports parser
	 *
	 * @api public
	 *
	 */
	module.exports.parser = __webpack_require__(21);


/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Module dependencies.
	 */
	
	var transports = __webpack_require__(15);
	var Emitter = __webpack_require__(8);
	var debug = __webpack_require__(3)('engine.io-client:socket');
	var index = __webpack_require__(35);
	var parser = __webpack_require__(21);
	var parseuri = __webpack_require__(2);
	var parseqs = __webpack_require__(29);
	
	/**
	 * Module exports.
	 */
	
	module.exports = Socket;
	
	/**
	 * Socket constructor.
	 *
	 * @param {String|Object} uri or options
	 * @param {Object} options
	 * @api public
	 */
	
	function Socket (uri, opts) {
	  if (!(this instanceof Socket)) return new Socket(uri, opts);
	
	  opts = opts || {};
	
	  if (uri && 'object' === typeof uri) {
	    opts = uri;
	    uri = null;
	  }
	
	  if (uri) {
	    uri = parseuri(uri);
	    opts.hostname = uri.host;
	    opts.secure = uri.protocol === 'https' || uri.protocol === 'wss';
	    opts.port = uri.port;
	    if (uri.query) opts.query = uri.query;
	  } else if (opts.host) {
	    opts.hostname = parseuri(opts.host).host;
	  }
	
	  this.secure = null != opts.secure ? opts.secure
	    : (typeof location !== 'undefined' && 'https:' === location.protocol);
	
	  if (opts.hostname && !opts.port) {
	    // if no port is specified manually, use the protocol default
	    opts.port = this.secure ? '443' : '80';
	  }
	
	  this.agent = opts.agent || false;
	  this.hostname = opts.hostname ||
	    (typeof location !== 'undefined' ? location.hostname : 'localhost');
	  this.port = opts.port || (typeof location !== 'undefined' && location.port
	      ? location.port
	      : (this.secure ? 443 : 80));
	  this.query = opts.query || {};
	  if ('string' === typeof this.query) this.query = parseqs.decode(this.query);
	  this.upgrade = false !== opts.upgrade;
	  this.path = (opts.path || '/engine.io').replace(/\/$/, '') + '/';
	  this.forceJSONP = !!opts.forceJSONP;
	  this.jsonp = false !== opts.jsonp;
	  this.forceBase64 = !!opts.forceBase64;
	  this.enablesXDR = !!opts.enablesXDR;
	  this.timestampParam = opts.timestampParam || 't';
	  this.timestampRequests = opts.timestampRequests;
	  this.transports = opts.transports || ['polling', 'websocket'];
	  this.transportOptions = opts.transportOptions || {};
	  this.readyState = '';
	  this.writeBuffer = [];
	  this.prevBufferLen = 0;
	  this.policyPort = opts.policyPort || 843;
	  this.rememberUpgrade = opts.rememberUpgrade || false;
	  this.binaryType = null;
	  this.onlyBinaryUpgrades = opts.onlyBinaryUpgrades;
	  this.perMessageDeflate = false !== opts.perMessageDeflate ? (opts.perMessageDeflate || {}) : false;
	
	  if (true === this.perMessageDeflate) this.perMessageDeflate = {};
	  if (this.perMessageDeflate && null == this.perMessageDeflate.threshold) {
	    this.perMessageDeflate.threshold = 1024;
	  }
	
	  // SSL options for Node.js client
	  this.pfx = opts.pfx || null;
	  this.key = opts.key || null;
	  this.passphrase = opts.passphrase || null;
	  this.cert = opts.cert || null;
	  this.ca = opts.ca || null;
	  this.ciphers = opts.ciphers || null;
	  this.rejectUnauthorized = opts.rejectUnauthorized === undefined ? true : opts.rejectUnauthorized;
	  this.forceNode = !!opts.forceNode;
	
	  // detect ReactNative environment
	  this.isReactNative = (typeof navigator !== 'undefined' && typeof navigator.product === 'string' && navigator.product.toLowerCase() === 'reactnative');
	
	  // other options for Node.js or ReactNative client
	  if (typeof self === 'undefined' || this.isReactNative) {
	    if (opts.extraHeaders && Object.keys(opts.extraHeaders).length > 0) {
	      this.extraHeaders = opts.extraHeaders;
	    }
	
	    if (opts.localAddress) {
	      this.localAddress = opts.localAddress;
	    }
	  }
	
	  // set on handshake
	  this.id = null;
	  this.upgrades = null;
	  this.pingInterval = null;
	  this.pingTimeout = null;
	
	  // set on heartbeat
	  this.pingIntervalTimer = null;
	  this.pingTimeoutTimer = null;
	
	  this.open();
	}
	
	Socket.priorWebsocketSuccess = false;
	
	/**
	 * Mix in `Emitter`.
	 */
	
	Emitter(Socket.prototype);
	
	/**
	 * Protocol version.
	 *
	 * @api public
	 */
	
	Socket.protocol = parser.protocol; // this is an int
	
	/**
	 * Expose deps for legacy compatibility
	 * and standalone browser access.
	 */
	
	Socket.Socket = Socket;
	Socket.Transport = __webpack_require__(20);
	Socket.transports = __webpack_require__(15);
	Socket.parser = __webpack_require__(21);
	
	/**
	 * Creates transport of the given type.
	 *
	 * @param {String} transport name
	 * @return {Transport}
	 * @api private
	 */
	
	Socket.prototype.createTransport = function (name) {
	  debug('creating transport "%s"', name);
	  var query = clone(this.query);
	
	  // append engine.io protocol identifier
	  query.EIO = parser.protocol;
	
	  // transport name
	  query.transport = name;
	
	  // per-transport options
	  var options = this.transportOptions[name] || {};
	
	  // session id if we already have one
	  if (this.id) query.sid = this.id;
	
	  var transport = new transports[name]({
	    query: query,
	    socket: this,
	    agent: options.agent || this.agent,
	    hostname: options.hostname || this.hostname,
	    port: options.port || this.port,
	    secure: options.secure || this.secure,
	    path: options.path || this.path,
	    forceJSONP: options.forceJSONP || this.forceJSONP,
	    jsonp: options.jsonp || this.jsonp,
	    forceBase64: options.forceBase64 || this.forceBase64,
	    enablesXDR: options.enablesXDR || this.enablesXDR,
	    timestampRequests: options.timestampRequests || this.timestampRequests,
	    timestampParam: options.timestampParam || this.timestampParam,
	    policyPort: options.policyPort || this.policyPort,
	    pfx: options.pfx || this.pfx,
	    key: options.key || this.key,
	    passphrase: options.passphrase || this.passphrase,
	    cert: options.cert || this.cert,
	    ca: options.ca || this.ca,
	    ciphers: options.ciphers || this.ciphers,
	    rejectUnauthorized: options.rejectUnauthorized || this.rejectUnauthorized,
	    perMessageDeflate: options.perMessageDeflate || this.perMessageDeflate,
	    extraHeaders: options.extraHeaders || this.extraHeaders,
	    forceNode: options.forceNode || this.forceNode,
	    localAddress: options.localAddress || this.localAddress,
	    requestTimeout: options.requestTimeout || this.requestTimeout,
	    protocols: options.protocols || void (0),
	    isReactNative: this.isReactNative
	  });
	
	  return transport;
	};
	
	function clone (obj) {
	  var o = {};
	  for (var i in obj) {
	    if (obj.hasOwnProperty(i)) {
	      o[i] = obj[i];
	    }
	  }
	  return o;
	}
	
	/**
	 * Initializes transport to use and starts probe.
	 *
	 * @api private
	 */
	Socket.prototype.open = function () {
	  var transport;
	  if (this.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf('websocket') !== -1) {
	    transport = 'websocket';
	  } else if (0 === this.transports.length) {
	    // Emit error on next tick so it can be listened to
	    var self = this;
	    setTimeout(function () {
	      self.emit('error', 'No transports available');
	    }, 0);
	    return;
	  } else {
	    transport = this.transports[0];
	  }
	  this.readyState = 'opening';
	
	  // Retry with the next transport if the transport is disabled (jsonp: false)
	  try {
	    transport = this.createTransport(transport);
	  } catch (e) {
	    this.transports.shift();
	    this.open();
	    return;
	  }
	
	  transport.open();
	  this.setTransport(transport);
	};
	
	/**
	 * Sets the current transport. Disables the existing one (if any).
	 *
	 * @api private
	 */
	
	Socket.prototype.setTransport = function (transport) {
	  debug('setting transport %s', transport.name);
	  var self = this;
	
	  if (this.transport) {
	    debug('clearing existing transport %s', this.transport.name);
	    this.transport.removeAllListeners();
	  }
	
	  // set up transport
	  this.transport = transport;
	
	  // set up transport listeners
	  transport
	  .on('drain', function () {
	    self.onDrain();
	  })
	  .on('packet', function (packet) {
	    self.onPacket(packet);
	  })
	  .on('error', function (e) {
	    self.onError(e);
	  })
	  .on('close', function () {
	    self.onClose('transport close');
	  });
	};
	
	/**
	 * Probes a transport.
	 *
	 * @param {String} transport name
	 * @api private
	 */
	
	Socket.prototype.probe = function (name) {
	  debug('probing transport "%s"', name);
	  var transport = this.createTransport(name, { probe: 1 });
	  var failed = false;
	  var self = this;
	
	  Socket.priorWebsocketSuccess = false;
	
	  function onTransportOpen () {
	    if (self.onlyBinaryUpgrades) {
	      var upgradeLosesBinary = !this.supportsBinary && self.transport.supportsBinary;
	      failed = failed || upgradeLosesBinary;
	    }
	    if (failed) return;
	
	    debug('probe transport "%s" opened', name);
	    transport.send([{ type: 'ping', data: 'probe' }]);
	    transport.once('packet', function (msg) {
	      if (failed) return;
	      if ('pong' === msg.type && 'probe' === msg.data) {
	        debug('probe transport "%s" pong', name);
	        self.upgrading = true;
	        self.emit('upgrading', transport);
	        if (!transport) return;
	        Socket.priorWebsocketSuccess = 'websocket' === transport.name;
	
	        debug('pausing current transport "%s"', self.transport.name);
	        self.transport.pause(function () {
	          if (failed) return;
	          if ('closed' === self.readyState) return;
	          debug('changing transport and sending upgrade packet');
	
	          cleanup();
	
	          self.setTransport(transport);
	          transport.send([{ type: 'upgrade' }]);
	          self.emit('upgrade', transport);
	          transport = null;
	          self.upgrading = false;
	          self.flush();
	        });
	      } else {
	        debug('probe transport "%s" failed', name);
	        var err = new Error('probe error');
	        err.transport = transport.name;
	        self.emit('upgradeError', err);
	      }
	    });
	  }
	
	  function freezeTransport () {
	    if (failed) return;
	
	    // Any callback called by transport should be ignored since now
	    failed = true;
	
	    cleanup();
	
	    transport.close();
	    transport = null;
	  }
	
	  // Handle any error that happens while probing
	  function onerror (err) {
	    var error = new Error('probe error: ' + err);
	    error.transport = transport.name;
	
	    freezeTransport();
	
	    debug('probe transport "%s" failed because of error: %s', name, err);
	
	    self.emit('upgradeError', error);
	  }
	
	  function onTransportClose () {
	    onerror('transport closed');
	  }
	
	  // When the socket is closed while we're probing
	  function onclose () {
	    onerror('socket closed');
	  }
	
	  // When the socket is upgraded while we're probing
	  function onupgrade (to) {
	    if (transport && to.name !== transport.name) {
	      debug('"%s" works - aborting "%s"', to.name, transport.name);
	      freezeTransport();
	    }
	  }
	
	  // Remove all listeners on the transport and on self
	  function cleanup () {
	    transport.removeListener('open', onTransportOpen);
	    transport.removeListener('error', onerror);
	    transport.removeListener('close', onTransportClose);
	    self.removeListener('close', onclose);
	    self.removeListener('upgrading', onupgrade);
	  }
	
	  transport.once('open', onTransportOpen);
	  transport.once('error', onerror);
	  transport.once('close', onTransportClose);
	
	  this.once('close', onclose);
	  this.once('upgrading', onupgrade);
	
	  transport.open();
	};
	
	/**
	 * Called when connection is deemed open.
	 *
	 * @api public
	 */
	
	Socket.prototype.onOpen = function () {
	  debug('socket open');
	  this.readyState = 'open';
	  Socket.priorWebsocketSuccess = 'websocket' === this.transport.name;
	  this.emit('open');
	  this.flush();
	
	  // we check for `readyState` in case an `open`
	  // listener already closed the socket
	  if ('open' === this.readyState && this.upgrade && this.transport.pause) {
	    debug('starting upgrade probes');
	    for (var i = 0, l = this.upgrades.length; i < l; i++) {
	      this.probe(this.upgrades[i]);
	    }
	  }
	};
	
	/**
	 * Handles a packet.
	 *
	 * @api private
	 */
	
	Socket.prototype.onPacket = function (packet) {
	  if ('opening' === this.readyState || 'open' === this.readyState ||
	      'closing' === this.readyState) {
	    debug('socket receive: type "%s", data "%s"', packet.type, packet.data);
	
	    this.emit('packet', packet);
	
	    // Socket is live - any packet counts
	    this.emit('heartbeat');
	
	    switch (packet.type) {
	      case 'open':
	        this.onHandshake(JSON.parse(packet.data));
	        break;
	
	      case 'pong':
	        this.setPing();
	        this.emit('pong');
	        break;
	
	      case 'error':
	        var err = new Error('server error');
	        err.code = packet.data;
	        this.onError(err);
	        break;
	
	      case 'message':
	        this.emit('data', packet.data);
	        this.emit('message', packet.data);
	        break;
	    }
	  } else {
	    debug('packet received with socket readyState "%s"', this.readyState);
	  }
	};
	
	/**
	 * Called upon handshake completion.
	 *
	 * @param {Object} handshake obj
	 * @api private
	 */
	
	Socket.prototype.onHandshake = function (data) {
	  this.emit('handshake', data);
	  this.id = data.sid;
	  this.transport.query.sid = data.sid;
	  this.upgrades = this.filterUpgrades(data.upgrades);
	  this.pingInterval = data.pingInterval;
	  this.pingTimeout = data.pingTimeout;
	  this.onOpen();
	  // In case open handler closes socket
	  if ('closed' === this.readyState) return;
	  this.setPing();
	
	  // Prolong liveness of socket on heartbeat
	  this.removeListener('heartbeat', this.onHeartbeat);
	  this.on('heartbeat', this.onHeartbeat);
	};
	
	/**
	 * Resets ping timeout.
	 *
	 * @api private
	 */
	
	Socket.prototype.onHeartbeat = function (timeout) {
	  clearTimeout(this.pingTimeoutTimer);
	  var self = this;
	  self.pingTimeoutTimer = setTimeout(function () {
	    if ('closed' === self.readyState) return;
	    self.onClose('ping timeout');
	  }, timeout || (self.pingInterval + self.pingTimeout));
	};
	
	/**
	 * Pings server every `this.pingInterval` and expects response
	 * within `this.pingTimeout` or closes connection.
	 *
	 * @api private
	 */
	
	Socket.prototype.setPing = function () {
	  var self = this;
	  clearTimeout(self.pingIntervalTimer);
	  self.pingIntervalTimer = setTimeout(function () {
	    debug('writing ping packet - expecting pong within %sms', self.pingTimeout);
	    self.ping();
	    self.onHeartbeat(self.pingTimeout);
	  }, self.pingInterval);
	};
	
	/**
	* Sends a ping packet.
	*
	* @api private
	*/
	
	Socket.prototype.ping = function () {
	  var self = this;
	  this.sendPacket('ping', function () {
	    self.emit('ping');
	  });
	};
	
	/**
	 * Called on `drain` event
	 *
	 * @api private
	 */
	
	Socket.prototype.onDrain = function () {
	  this.writeBuffer.splice(0, this.prevBufferLen);
	
	  // setting prevBufferLen = 0 is very important
	  // for example, when upgrading, upgrade packet is sent over,
	  // and a nonzero prevBufferLen could cause problems on `drain`
	  this.prevBufferLen = 0;
	
	  if (0 === this.writeBuffer.length) {
	    this.emit('drain');
	  } else {
	    this.flush();
	  }
	};
	
	/**
	 * Flush write buffers.
	 *
	 * @api private
	 */
	
	Socket.prototype.flush = function () {
	  if ('closed' !== this.readyState && this.transport.writable &&
	    !this.upgrading && this.writeBuffer.length) {
	    debug('flushing %d packets in socket', this.writeBuffer.length);
	    this.transport.send(this.writeBuffer);
	    // keep track of current length of writeBuffer
	    // splice writeBuffer and callbackBuffer on `drain`
	    this.prevBufferLen = this.writeBuffer.length;
	    this.emit('flush');
	  }
	};
	
	/**
	 * Sends a message.
	 *
	 * @param {String} message.
	 * @param {Function} callback function.
	 * @param {Object} options.
	 * @return {Socket} for chaining.
	 * @api public
	 */
	
	Socket.prototype.write =
	Socket.prototype.send = function (msg, options, fn) {
	  this.sendPacket('message', msg, options, fn);
	  return this;
	};
	
	/**
	 * Sends a packet.
	 *
	 * @param {String} packet type.
	 * @param {String} data.
	 * @param {Object} options.
	 * @param {Function} callback function.
	 * @api private
	 */
	
	Socket.prototype.sendPacket = function (type, data, options, fn) {
	  if ('function' === typeof data) {
	    fn = data;
	    data = undefined;
	  }
	
	  if ('function' === typeof options) {
	    fn = options;
	    options = null;
	  }
	
	  if ('closing' === this.readyState || 'closed' === this.readyState) {
	    return;
	  }
	
	  options = options || {};
	  options.compress = false !== options.compress;
	
	  var packet = {
	    type: type,
	    data: data,
	    options: options
	  };
	  this.emit('packetCreate', packet);
	  this.writeBuffer.push(packet);
	  if (fn) this.once('flush', fn);
	  this.flush();
	};
	
	/**
	 * Closes the connection.
	 *
	 * @api private
	 */
	
	Socket.prototype.close = function () {
	  if ('opening' === this.readyState || 'open' === this.readyState) {
	    this.readyState = 'closing';
	
	    var self = this;
	
	    if (this.writeBuffer.length) {
	      this.once('drain', function () {
	        if (this.upgrading) {
	          waitForUpgrade();
	        } else {
	          close();
	        }
	      });
	    } else if (this.upgrading) {
	      waitForUpgrade();
	    } else {
	      close();
	    }
	  }
	
	  function close () {
	    self.onClose('forced close');
	    debug('socket closing - telling transport to close');
	    self.transport.close();
	  }
	
	  function cleanupAndClose () {
	    self.removeListener('upgrade', cleanupAndClose);
	    self.removeListener('upgradeError', cleanupAndClose);
	    close();
	  }
	
	  function waitForUpgrade () {
	    // wait for upgrade to finish since we can't send packets while pausing a transport
	    self.once('upgrade', cleanupAndClose);
	    self.once('upgradeError', cleanupAndClose);
	  }
	
	  return this;
	};
	
	/**
	 * Called upon transport error
	 *
	 * @api private
	 */
	
	Socket.prototype.onError = function (err) {
	  debug('socket error %j', err);
	  Socket.priorWebsocketSuccess = false;
	  this.emit('error', err);
	  this.onClose('transport error', err);
	};
	
	/**
	 * Called upon transport close.
	 *
	 * @api private
	 */
	
	Socket.prototype.onClose = function (reason, desc) {
	  if ('opening' === this.readyState || 'open' === this.readyState || 'closing' === this.readyState) {
	    debug('socket close with reason: "%s"', reason);
	    var self = this;
	
	    // clear timers
	    clearTimeout(this.pingIntervalTimer);
	    clearTimeout(this.pingTimeoutTimer);
	
	    // stop event from firing again for transport
	    this.transport.removeAllListeners('close');
	
	    // ensure transport won't stay open
	    this.transport.close();
	
	    // ignore further transport communication
	    this.transport.removeAllListeners();
	
	    // set ready state
	    this.readyState = 'closed';
	
	    // clear session id
	    this.id = null;
	
	    // emit close event
	    this.emit('close', reason, desc);
	
	    // clean buffers after, so users can still
	    // grab the buffers on `close` event
	    self.writeBuffer = [];
	    self.prevBufferLen = 0;
	  }
	};
	
	/**
	 * Filters upgrades, returning only those matching client transports.
	 *
	 * @param {Array} server upgrades
	 * @api private
	 *
	 */
	
	Socket.prototype.filterUpgrades = function (upgrades) {
	  var filteredUpgrades = [];
	  for (var i = 0, j = upgrades.length; i < j; i++) {
	    if (~index(this.transports, upgrades[i])) filteredUpgrades.push(upgrades[i]);
	  }
	  return filteredUpgrades;
	};


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Module dependencies
	 */
	
	var XMLHttpRequest = __webpack_require__(16);
	var XHR = __webpack_require__(18);
	var JSONP = __webpack_require__(32);
	var websocket = __webpack_require__(33);
	
	/**
	 * Export transports.
	 */
	
	exports.polling = polling;
	exports.websocket = websocket;
	
	/**
	 * Polling transport polymorphic constructor.
	 * Decides on xhr vs jsonp based on feature detection.
	 *
	 * @api private
	 */
	
	function polling (opts) {
	  var xhr;
	  var xd = false;
	  var xs = false;
	  var jsonp = false !== opts.jsonp;
	
	  if (typeof location !== 'undefined') {
	    var isSSL = 'https:' === location.protocol;
	    var port = location.port;
	
	    // some user agents have empty `location.port`
	    if (!port) {
	      port = isSSL ? 443 : 80;
	    }
	
	    xd = opts.hostname !== location.hostname || port !== opts.port;
	    xs = opts.secure !== isSSL;
	  }
	
	  opts.xdomain = xd;
	  opts.xscheme = xs;
	  xhr = new XMLHttpRequest(opts);
	
	  if ('open' in xhr && !opts.forceJSONP) {
	    return new XHR(opts);
	  } else {
	    if (!jsonp) throw new Error('JSONP disabled');
	    return new JSONP(opts);
	  }
	}


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

	// browser shim for xmlhttprequest module
	
	var hasCORS = __webpack_require__(17);
	
	module.exports = function (opts) {
	  var xdomain = opts.xdomain;
	
	  // scheme must be same when usign XDomainRequest
	  // http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx
	  var xscheme = opts.xscheme;
	
	  // XDomainRequest has a flow of not sending cookie, therefore it should be disabled as a default.
	  // https://github.com/Automattic/engine.io-client/pull/217
	  var enablesXDR = opts.enablesXDR;
	
	  // XMLHttpRequest can be disabled on IE
	  try {
	    if ('undefined' !== typeof XMLHttpRequest && (!xdomain || hasCORS)) {
	      return new XMLHttpRequest();
	    }
	  } catch (e) { }
	
	  // Use XDomainRequest for IE8 if enablesXDR is true
	  // because loading bar keeps flashing when using jsonp-polling
	  // https://github.com/yujiosaka/socke.io-ie8-loading-example
	  try {
	    if ('undefined' !== typeof XDomainRequest && !xscheme && enablesXDR) {
	      return new XDomainRequest();
	    }
	  } catch (e) { }
	
	  if (!xdomain) {
	    try {
	      return new self[['Active'].concat('Object').join('X')]('Microsoft.XMLHTTP');
	    } catch (e) { }
	  }
	};


/***/ }),
/* 17 */
/***/ (function(module, exports) {

	
	/**
	 * Module exports.
	 *
	 * Logic borrowed from Modernizr:
	 *
	 *   - https://github.com/Modernizr/Modernizr/blob/master/feature-detects/cors.js
	 */
	
	try {
	  module.exports = typeof XMLHttpRequest !== 'undefined' &&
	    'withCredentials' in new XMLHttpRequest();
	} catch (err) {
	  // if XMLHttp support is disabled in IE then it will throw
	  // when trying to create
	  module.exports = false;
	}


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

	/* global attachEvent */
	
	/**
	 * Module requirements.
	 */
	
	var XMLHttpRequest = __webpack_require__(16);
	var Polling = __webpack_require__(19);
	var Emitter = __webpack_require__(8);
	var inherit = __webpack_require__(30);
	var debug = __webpack_require__(3)('engine.io-client:polling-xhr');
	
	/**
	 * Module exports.
	 */
	
	module.exports = XHR;
	module.exports.Request = Request;
	
	/**
	 * Empty function
	 */
	
	function empty () {}
	
	/**
	 * XHR Polling constructor.
	 *
	 * @param {Object} opts
	 * @api public
	 */
	
	function XHR (opts) {
	  Polling.call(this, opts);
	  this.requestTimeout = opts.requestTimeout;
	  this.extraHeaders = opts.extraHeaders;
	
	  if (typeof location !== 'undefined') {
	    var isSSL = 'https:' === location.protocol;
	    var port = location.port;
	
	    // some user agents have empty `location.port`
	    if (!port) {
	      port = isSSL ? 443 : 80;
	    }
	
	    this.xd = (typeof location !== 'undefined' && opts.hostname !== location.hostname) ||
	      port !== opts.port;
	    this.xs = opts.secure !== isSSL;
	  }
	}
	
	/**
	 * Inherits from Polling.
	 */
	
	inherit(XHR, Polling);
	
	/**
	 * XHR supports binary
	 */
	
	XHR.prototype.supportsBinary = true;
	
	/**
	 * Creates a request.
	 *
	 * @param {String} method
	 * @api private
	 */
	
	XHR.prototype.request = function (opts) {
	  opts = opts || {};
	  opts.uri = this.uri();
	  opts.xd = this.xd;
	  opts.xs = this.xs;
	  opts.agent = this.agent || false;
	  opts.supportsBinary = this.supportsBinary;
	  opts.enablesXDR = this.enablesXDR;
	
	  // SSL options for Node.js client
	  opts.pfx = this.pfx;
	  opts.key = this.key;
	  opts.passphrase = this.passphrase;
	  opts.cert = this.cert;
	  opts.ca = this.ca;
	  opts.ciphers = this.ciphers;
	  opts.rejectUnauthorized = this.rejectUnauthorized;
	  opts.requestTimeout = this.requestTimeout;
	
	  // other options for Node.js client
	  opts.extraHeaders = this.extraHeaders;
	
	  return new Request(opts);
	};
	
	/**
	 * Sends data.
	 *
	 * @param {String} data to send.
	 * @param {Function} called upon flush.
	 * @api private
	 */
	
	XHR.prototype.doWrite = function (data, fn) {
	  var isBinary = typeof data !== 'string' && data !== undefined;
	  var req = this.request({ method: 'POST', data: data, isBinary: isBinary });
	  var self = this;
	  req.on('success', fn);
	  req.on('error', function (err) {
	    self.onError('xhr post error', err);
	  });
	  this.sendXhr = req;
	};
	
	/**
	 * Starts a poll cycle.
	 *
	 * @api private
	 */
	
	XHR.prototype.doPoll = function () {
	  debug('xhr poll');
	  var req = this.request();
	  var self = this;
	  req.on('data', function (data) {
	    self.onData(data);
	  });
	  req.on('error', function (err) {
	    self.onError('xhr poll error', err);
	  });
	  this.pollXhr = req;
	};
	
	/**
	 * Request constructor
	 *
	 * @param {Object} options
	 * @api public
	 */
	
	function Request (opts) {
	  this.method = opts.method || 'GET';
	  this.uri = opts.uri;
	  this.xd = !!opts.xd;
	  this.xs = !!opts.xs;
	  this.async = false !== opts.async;
	  this.data = undefined !== opts.data ? opts.data : null;
	  this.agent = opts.agent;
	  this.isBinary = opts.isBinary;
	  this.supportsBinary = opts.supportsBinary;
	  this.enablesXDR = opts.enablesXDR;
	  this.requestTimeout = opts.requestTimeout;
	
	  // SSL options for Node.js client
	  this.pfx = opts.pfx;
	  this.key = opts.key;
	  this.passphrase = opts.passphrase;
	  this.cert = opts.cert;
	  this.ca = opts.ca;
	  this.ciphers = opts.ciphers;
	  this.rejectUnauthorized = opts.rejectUnauthorized;
	
	  // other options for Node.js client
	  this.extraHeaders = opts.extraHeaders;
	
	  this.create();
	}
	
	/**
	 * Mix in `Emitter`.
	 */
	
	Emitter(Request.prototype);
	
	/**
	 * Creates the XHR object and sends the request.
	 *
	 * @api private
	 */
	
	Request.prototype.create = function () {
	  var opts = { agent: this.agent, xdomain: this.xd, xscheme: this.xs, enablesXDR: this.enablesXDR };
	
	  // SSL options for Node.js client
	  opts.pfx = this.pfx;
	  opts.key = this.key;
	  opts.passphrase = this.passphrase;
	  opts.cert = this.cert;
	  opts.ca = this.ca;
	  opts.ciphers = this.ciphers;
	  opts.rejectUnauthorized = this.rejectUnauthorized;
	
	  var xhr = this.xhr = new XMLHttpRequest(opts);
	  var self = this;
	
	  try {
	    debug('xhr open %s: %s', this.method, this.uri);
	    xhr.open(this.method, this.uri, this.async);
	    try {
	      if (this.extraHeaders) {
	        xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);
	        for (var i in this.extraHeaders) {
	          if (this.extraHeaders.hasOwnProperty(i)) {
	            xhr.setRequestHeader(i, this.extraHeaders[i]);
	          }
	        }
	      }
	    } catch (e) {}
	
	    if ('POST' === this.method) {
	      try {
	        if (this.isBinary) {
	          xhr.setRequestHeader('Content-type', 'application/octet-stream');
	        } else {
	          xhr.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');
	        }
	      } catch (e) {}
	    }
	
	    try {
	      xhr.setRequestHeader('Accept', '*/*');
	    } catch (e) {}
	
	    // ie6 check
	    if ('withCredentials' in xhr) {
	      xhr.withCredentials = true;
	    }
	
	    if (this.requestTimeout) {
	      xhr.timeout = this.requestTimeout;
	    }
	
	    if (this.hasXDR()) {
	      xhr.onload = function () {
	        self.onLoad();
	      };
	      xhr.onerror = function () {
	        self.onError(xhr.responseText);
	      };
	    } else {
	      xhr.onreadystatechange = function () {
	        if (xhr.readyState === 2) {
	          try {
	            var contentType = xhr.getResponseHeader('Content-Type');
	            if (self.supportsBinary && contentType === 'application/octet-stream') {
	              xhr.responseType = 'arraybuffer';
	            }
	          } catch (e) {}
	        }
	        if (4 !== xhr.readyState) return;
	        if (200 === xhr.status || 1223 === xhr.status) {
	          self.onLoad();
	        } else {
	          // make sure the `error` event handler that's user-set
	          // does not throw in the same tick and gets caught here
	          setTimeout(function () {
	            self.onError(xhr.status);
	          }, 0);
	        }
	      };
	    }
	
	    debug('xhr data %s', this.data);
	    xhr.send(this.data);
	  } catch (e) {
	    // Need to defer since .create() is called directly fhrom the constructor
	    // and thus the 'error' event can only be only bound *after* this exception
	    // occurs.  Therefore, also, we cannot throw here at all.
	    setTimeout(function () {
	      self.onError(e);
	    }, 0);
	    return;
	  }
	
	  if (typeof document !== 'undefined') {
	    this.index = Request.requestsCount++;
	    Request.requests[this.index] = this;
	  }
	};
	
	/**
	 * Called upon successful response.
	 *
	 * @api private
	 */
	
	Request.prototype.onSuccess = function () {
	  this.emit('success');
	  this.cleanup();
	};
	
	/**
	 * Called if we have data.
	 *
	 * @api private
	 */
	
	Request.prototype.onData = function (data) {
	  this.emit('data', data);
	  this.onSuccess();
	};
	
	/**
	 * Called upon error.
	 *
	 * @api private
	 */
	
	Request.prototype.onError = function (err) {
	  this.emit('error', err);
	  this.cleanup(true);
	};
	
	/**
	 * Cleans up house.
	 *
	 * @api private
	 */
	
	Request.prototype.cleanup = function (fromError) {
	  if ('undefined' === typeof this.xhr || null === this.xhr) {
	    return;
	  }
	  // xmlhttprequest
	  if (this.hasXDR()) {
	    this.xhr.onload = this.xhr.onerror = empty;
	  } else {
	    this.xhr.onreadystatechange = empty;
	  }
	
	  if (fromError) {
	    try {
	      this.xhr.abort();
	    } catch (e) {}
	  }
	
	  if (typeof document !== 'undefined') {
	    delete Request.requests[this.index];
	  }
	
	  this.xhr = null;
	};
	
	/**
	 * Called upon load.
	 *
	 * @api private
	 */
	
	Request.prototype.onLoad = function () {
	  var data;
	  try {
	    var contentType;
	    try {
	      contentType = this.xhr.getResponseHeader('Content-Type');
	    } catch (e) {}
	    if (contentType === 'application/octet-stream') {
	      data = this.xhr.response || this.xhr.responseText;
	    } else {
	      data = this.xhr.responseText;
	    }
	  } catch (e) {
	    this.onError(e);
	  }
	  if (null != data) {
	    this.onData(data);
	  }
	};
	
	/**
	 * Check if it has XDomainRequest.
	 *
	 * @api private
	 */
	
	Request.prototype.hasXDR = function () {
	  return typeof XDomainRequest !== 'undefined' && !this.xs && this.enablesXDR;
	};
	
	/**
	 * Aborts the request.
	 *
	 * @api public
	 */
	
	Request.prototype.abort = function () {
	  this.cleanup();
	};
	
	/**
	 * Aborts pending requests when unloading the window. This is needed to prevent
	 * memory leaks (e.g. when using IE) and to ensure that no spurious error is
	 * emitted.
	 */
	
	Request.requestsCount = 0;
	Request.requests = {};
	
	if (typeof document !== 'undefined') {
	  if (typeof attachEvent === 'function') {
	    attachEvent('onunload', unloadHandler);
	  } else if (typeof addEventListener === 'function') {
	    var terminationEvent = 'onpagehide' in self ? 'pagehide' : 'unload';
	    addEventListener(terminationEvent, unloadHandler, false);
	  }
	}
	
	function unloadHandler () {
	  for (var i in Request.requests) {
	    if (Request.requests.hasOwnProperty(i)) {
	      Request.requests[i].abort();
	    }
	  }
	}


/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Module dependencies.
	 */
	
	var Transport = __webpack_require__(20);
	var parseqs = __webpack_require__(29);
	var parser = __webpack_require__(21);
	var inherit = __webpack_require__(30);
	var yeast = __webpack_require__(31);
	var debug = __webpack_require__(3)('engine.io-client:polling');
	
	/**
	 * Module exports.
	 */
	
	module.exports = Polling;
	
	/**
	 * Is XHR2 supported?
	 */
	
	var hasXHR2 = (function () {
	  var XMLHttpRequest = __webpack_require__(16);
	  var xhr = new XMLHttpRequest({ xdomain: false });
	  return null != xhr.responseType;
	})();
	
	/**
	 * Polling interface.
	 *
	 * @param {Object} opts
	 * @api private
	 */
	
	function Polling (opts) {
	  var forceBase64 = (opts && opts.forceBase64);
	  if (!hasXHR2 || forceBase64) {
	    this.supportsBinary = false;
	  }
	  Transport.call(this, opts);
	}
	
	/**
	 * Inherits from Transport.
	 */
	
	inherit(Polling, Transport);
	
	/**
	 * Transport name.
	 */
	
	Polling.prototype.name = 'polling';
	
	/**
	 * Opens the socket (triggers polling). We write a PING message to determine
	 * when the transport is open.
	 *
	 * @api private
	 */
	
	Polling.prototype.doOpen = function () {
	  this.poll();
	};
	
	/**
	 * Pauses polling.
	 *
	 * @param {Function} callback upon buffers are flushed and transport is paused
	 * @api private
	 */
	
	Polling.prototype.pause = function (onPause) {
	  var self = this;
	
	  this.readyState = 'pausing';
	
	  function pause () {
	    debug('paused');
	    self.readyState = 'paused';
	    onPause();
	  }
	
	  if (this.polling || !this.writable) {
	    var total = 0;
	
	    if (this.polling) {
	      debug('we are currently polling - waiting to pause');
	      total++;
	      this.once('pollComplete', function () {
	        debug('pre-pause polling complete');
	        --total || pause();
	      });
	    }
	
	    if (!this.writable) {
	      debug('we are currently writing - waiting to pause');
	      total++;
	      this.once('drain', function () {
	        debug('pre-pause writing complete');
	        --total || pause();
	      });
	    }
	  } else {
	    pause();
	  }
	};
	
	/**
	 * Starts polling cycle.
	 *
	 * @api public
	 */
	
	Polling.prototype.poll = function () {
	  debug('polling');
	  this.polling = true;
	  this.doPoll();
	  this.emit('poll');
	};
	
	/**
	 * Overloads onData to detect payloads.
	 *
	 * @api private
	 */
	
	Polling.prototype.onData = function (data) {
	  var self = this;
	  debug('polling got data %s', data);
	  var callback = function (packet, index, total) {
	    // if its the first message we consider the transport open
	    if ('opening' === self.readyState) {
	      self.onOpen();
	    }
	
	    // if its a close packet, we close the ongoing requests
	    if ('close' === packet.type) {
	      self.onClose();
	      return false;
	    }
	
	    // otherwise bypass onData and handle the message
	    self.onPacket(packet);
	  };
	
	  // decode payload
	  parser.decodePayload(data, this.socket.binaryType, callback);
	
	  // if an event did not trigger closing
	  if ('closed' !== this.readyState) {
	    // if we got data we're not polling
	    this.polling = false;
	    this.emit('pollComplete');
	
	    if ('open' === this.readyState) {
	      this.poll();
	    } else {
	      debug('ignoring poll - transport state "%s"', this.readyState);
	    }
	  }
	};
	
	/**
	 * For polling, send a close packet.
	 *
	 * @api private
	 */
	
	Polling.prototype.doClose = function () {
	  var self = this;
	
	  function close () {
	    debug('writing close packet');
	    self.write([{ type: 'close' }]);
	  }
	
	  if ('open' === this.readyState) {
	    debug('transport open - closing');
	    close();
	  } else {
	    // in case we're trying to close while
	    // handshaking is in progress (GH-164)
	    debug('transport not open - deferring close');
	    this.once('open', close);
	  }
	};
	
	/**
	 * Writes a packets payload.
	 *
	 * @param {Array} data packets
	 * @param {Function} drain callback
	 * @api private
	 */
	
	Polling.prototype.write = function (packets) {
	  var self = this;
	  this.writable = false;
	  var callbackfn = function () {
	    self.writable = true;
	    self.emit('drain');
	  };
	
	  parser.encodePayload(packets, this.supportsBinary, function (data) {
	    self.doWrite(data, callbackfn);
	  });
	};
	
	/**
	 * Generates uri for connection.
	 *
	 * @api private
	 */
	
	Polling.prototype.uri = function () {
	  var query = this.query || {};
	  var schema = this.secure ? 'https' : 'http';
	  var port = '';
	
	  // cache busting is forced
	  if (false !== this.timestampRequests) {
	    query[this.timestampParam] = yeast();
	  }
	
	  if (!this.supportsBinary && !query.sid) {
	    query.b64 = 1;
	  }
	
	  query = parseqs.encode(query);
	
	  // avoid port if default for schema
	  if (this.port && (('https' === schema && Number(this.port) !== 443) ||
	     ('http' === schema && Number(this.port) !== 80))) {
	    port = ':' + this.port;
	  }
	
	  // prepend ? to query
	  if (query.length) {
	    query = '?' + query;
	  }
	
	  var ipv6 = this.hostname.indexOf(':') !== -1;
	  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
	};


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Module dependencies.
	 */
	
	var parser = __webpack_require__(21);
	var Emitter = __webpack_require__(8);
	
	/**
	 * Module exports.
	 */
	
	module.exports = Transport;
	
	/**
	 * Transport abstract constructor.
	 *
	 * @param {Object} options.
	 * @api private
	 */
	
	function Transport (opts) {
	  this.path = opts.path;
	  this.hostname = opts.hostname;
	  this.port = opts.port;
	  this.secure = opts.secure;
	  this.query = opts.query;
	  this.timestampParam = opts.timestampParam;
	  this.timestampRequests = opts.timestampRequests;
	  this.readyState = '';
	  this.agent = opts.agent || false;
	  this.socket = opts.socket;
	  this.enablesXDR = opts.enablesXDR;
	
	  // SSL options for Node.js client
	  this.pfx = opts.pfx;
	  this.key = opts.key;
	  this.passphrase = opts.passphrase;
	  this.cert = opts.cert;
	  this.ca = opts.ca;
	  this.ciphers = opts.ciphers;
	  this.rejectUnauthorized = opts.rejectUnauthorized;
	  this.forceNode = opts.forceNode;
	
	  // results of ReactNative environment detection
	  this.isReactNative = opts.isReactNative;
	
	  // other options for Node.js client
	  this.extraHeaders = opts.extraHeaders;
	  this.localAddress = opts.localAddress;
	}
	
	/**
	 * Mix in `Emitter`.
	 */
	
	Emitter(Transport.prototype);
	
	/**
	 * Emits an error.
	 *
	 * @param {String} str
	 * @return {Transport} for chaining
	 * @api public
	 */
	
	Transport.prototype.onError = function (msg, desc) {
	  var err = new Error(msg);
	  err.type = 'TransportError';
	  err.description = desc;
	  this.emit('error', err);
	  return this;
	};
	
	/**
	 * Opens the transport.
	 *
	 * @api public
	 */
	
	Transport.prototype.open = function () {
	  if ('closed' === this.readyState || '' === this.readyState) {
	    this.readyState = 'opening';
	    this.doOpen();
	  }
	
	  return this;
	};
	
	/**
	 * Closes the transport.
	 *
	 * @api private
	 */
	
	Transport.prototype.close = function () {
	  if ('opening' === this.readyState || 'open' === this.readyState) {
	    this.doClose();
	    this.onClose();
	  }
	
	  return this;
	};
	
	/**
	 * Sends multiple packets.
	 *
	 * @param {Array} packets
	 * @api private
	 */
	
	Transport.prototype.send = function (packets) {
	  if ('open' === this.readyState) {
	    this.write(packets);
	  } else {
	    throw new Error('Transport not open');
	  }
	};
	
	/**
	 * Called upon open
	 *
	 * @api private
	 */
	
	Transport.prototype.onOpen = function () {
	  this.readyState = 'open';
	  this.writable = true;
	  this.emit('open');
	};
	
	/**
	 * Called with data.
	 *
	 * @param {String} data
	 * @api private
	 */
	
	Transport.prototype.onData = function (data) {
	  var packet = parser.decodePacket(data, this.socket.binaryType);
	  this.onPacket(packet);
	};
	
	/**
	 * Called with a decoded packet.
	 */
	
	Transport.prototype.onPacket = function (packet) {
	  this.emit('packet', packet);
	};
	
	/**
	 * Called upon close.
	 *
	 * @api private
	 */
	
	Transport.prototype.onClose = function () {
	  this.readyState = 'closed';
	  this.emit('close');
	};


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Module dependencies.
	 */
	
	var keys = __webpack_require__(22);
	var hasBinary = __webpack_require__(23);
	var sliceBuffer = __webpack_require__(24);
	var after = __webpack_require__(25);
	var utf8 = __webpack_require__(26);
	
	var base64encoder;
	if (typeof ArrayBuffer !== 'undefined') {
	  base64encoder = __webpack_require__(27);
	}
	
	/**
	 * Check if we are running an android browser. That requires us to use
	 * ArrayBuffer with polling transports...
	 *
	 * http://ghinda.net/jpeg-blob-ajax-android/
	 */
	
	var isAndroid = typeof navigator !== 'undefined' && /Android/i.test(navigator.userAgent);
	
	/**
	 * Check if we are running in PhantomJS.
	 * Uploading a Blob with PhantomJS does not work correctly, as reported here:
	 * https://github.com/ariya/phantomjs/issues/11395
	 * @type boolean
	 */
	var isPhantomJS = typeof navigator !== 'undefined' && /PhantomJS/i.test(navigator.userAgent);
	
	/**
	 * When true, avoids using Blobs to encode payloads.
	 * @type boolean
	 */
	var dontSendBlobs = isAndroid || isPhantomJS;
	
	/**
	 * Current protocol version.
	 */
	
	exports.protocol = 3;
	
	/**
	 * Packet types.
	 */
	
	var packets = exports.packets = {
	    open:     0    // non-ws
	  , close:    1    // non-ws
	  , ping:     2
	  , pong:     3
	  , message:  4
	  , upgrade:  5
	  , noop:     6
	};
	
	var packetslist = keys(packets);
	
	/**
	 * Premade error packet.
	 */
	
	var err = { type: 'error', data: 'parser error' };
	
	/**
	 * Create a blob api even for blob builder when vendor prefixes exist
	 */
	
	var Blob = __webpack_require__(28);
	
	/**
	 * Encodes a packet.
	 *
	 *     <packet type id> [ <data> ]
	 *
	 * Example:
	 *
	 *     5hello world
	 *     3
	 *     4
	 *
	 * Binary is encoded in an identical principle
	 *
	 * @api private
	 */
	
	exports.encodePacket = function (packet, supportsBinary, utf8encode, callback) {
	  if (typeof supportsBinary === 'function') {
	    callback = supportsBinary;
	    supportsBinary = false;
	  }
	
	  if (typeof utf8encode === 'function') {
	    callback = utf8encode;
	    utf8encode = null;
	  }
	
	  var data = (packet.data === undefined)
	    ? undefined
	    : packet.data.buffer || packet.data;
	
	  if (typeof ArrayBuffer !== 'undefined' && data instanceof ArrayBuffer) {
	    return encodeArrayBuffer(packet, supportsBinary, callback);
	  } else if (typeof Blob !== 'undefined' && data instanceof Blob) {
	    return encodeBlob(packet, supportsBinary, callback);
	  }
	
	  // might be an object with { base64: true, data: dataAsBase64String }
	  if (data && data.base64) {
	    return encodeBase64Object(packet, callback);
	  }
	
	  // Sending data as a utf-8 string
	  var encoded = packets[packet.type];
	
	  // data fragment is optional
	  if (undefined !== packet.data) {
	    encoded += utf8encode ? utf8.encode(String(packet.data), { strict: false }) : String(packet.data);
	  }
	
	  return callback('' + encoded);
	
	};
	
	function encodeBase64Object(packet, callback) {
	  // packet data is an object { base64: true, data: dataAsBase64String }
	  var message = 'b' + exports.packets[packet.type] + packet.data.data;
	  return callback(message);
	}
	
	/**
	 * Encode packet helpers for binary types
	 */
	
	function encodeArrayBuffer(packet, supportsBinary, callback) {
	  if (!supportsBinary) {
	    return exports.encodeBase64Packet(packet, callback);
	  }
	
	  var data = packet.data;
	  var contentArray = new Uint8Array(data);
	  var resultBuffer = new Uint8Array(1 + data.byteLength);
	
	  resultBuffer[0] = packets[packet.type];
	  for (var i = 0; i < contentArray.length; i++) {
	    resultBuffer[i+1] = contentArray[i];
	  }
	
	  return callback(resultBuffer.buffer);
	}
	
	function encodeBlobAsArrayBuffer(packet, supportsBinary, callback) {
	  if (!supportsBinary) {
	    return exports.encodeBase64Packet(packet, callback);
	  }
	
	  var fr = new FileReader();
	  fr.onload = function() {
	    exports.encodePacket({ type: packet.type, data: fr.result }, supportsBinary, true, callback);
	  };
	  return fr.readAsArrayBuffer(packet.data);
	}
	
	function encodeBlob(packet, supportsBinary, callback) {
	  if (!supportsBinary) {
	    return exports.encodeBase64Packet(packet, callback);
	  }
	
	  if (dontSendBlobs) {
	    return encodeBlobAsArrayBuffer(packet, supportsBinary, callback);
	  }
	
	  var length = new Uint8Array(1);
	  length[0] = packets[packet.type];
	  var blob = new Blob([length.buffer, packet.data]);
	
	  return callback(blob);
	}
	
	/**
	 * Encodes a packet with binary data in a base64 string
	 *
	 * @param {Object} packet, has `type` and `data`
	 * @return {String} base64 encoded message
	 */
	
	exports.encodeBase64Packet = function(packet, callback) {
	  var message = 'b' + exports.packets[packet.type];
	  if (typeof Blob !== 'undefined' && packet.data instanceof Blob) {
	    var fr = new FileReader();
	    fr.onload = function() {
	      var b64 = fr.result.split(',')[1];
	      callback(message + b64);
	    };
	    return fr.readAsDataURL(packet.data);
	  }
	
	  var b64data;
	  try {
	    b64data = String.fromCharCode.apply(null, new Uint8Array(packet.data));
	  } catch (e) {
	    // iPhone Safari doesn't let you apply with typed arrays
	    var typed = new Uint8Array(packet.data);
	    var basic = new Array(typed.length);
	    for (var i = 0; i < typed.length; i++) {
	      basic[i] = typed[i];
	    }
	    b64data = String.fromCharCode.apply(null, basic);
	  }
	  message += btoa(b64data);
	  return callback(message);
	};
	
	/**
	 * Decodes a packet. Changes format to Blob if requested.
	 *
	 * @return {Object} with `type` and `data` (if any)
	 * @api private
	 */
	
	exports.decodePacket = function (data, binaryType, utf8decode) {
	  if (data === undefined) {
	    return err;
	  }
	  // String data
	  if (typeof data === 'string') {
	    if (data.charAt(0) === 'b') {
	      return exports.decodeBase64Packet(data.substr(1), binaryType);
	    }
	
	    if (utf8decode) {
	      data = tryDecode(data);
	      if (data === false) {
	        return err;
	      }
	    }
	    var type = data.charAt(0);
	
	    if (Number(type) != type || !packetslist[type]) {
	      return err;
	    }
	
	    if (data.length > 1) {
	      return { type: packetslist[type], data: data.substring(1) };
	    } else {
	      return { type: packetslist[type] };
	    }
	  }
	
	  var asArray = new Uint8Array(data);
	  var type = asArray[0];
	  var rest = sliceBuffer(data, 1);
	  if (Blob && binaryType === 'blob') {
	    rest = new Blob([rest]);
	  }
	  return { type: packetslist[type], data: rest };
	};
	
	function tryDecode(data) {
	  try {
	    data = utf8.decode(data, { strict: false });
	  } catch (e) {
	    return false;
	  }
	  return data;
	}
	
	/**
	 * Decodes a packet encoded in a base64 string
	 *
	 * @param {String} base64 encoded message
	 * @return {Object} with `type` and `data` (if any)
	 */
	
	exports.decodeBase64Packet = function(msg, binaryType) {
	  var type = packetslist[msg.charAt(0)];
	  if (!base64encoder) {
	    return { type: type, data: { base64: true, data: msg.substr(1) } };
	  }
	
	  var data = base64encoder.decode(msg.substr(1));
	
	  if (binaryType === 'blob' && Blob) {
	    data = new Blob([data]);
	  }
	
	  return { type: type, data: data };
	};
	
	/**
	 * Encodes multiple messages (payload).
	 *
	 *     <length>:data
	 *
	 * Example:
	 *
	 *     11:hello world2:hi
	 *
	 * If any contents are binary, they will be encoded as base64 strings. Base64
	 * encoded strings are marked with a b before the length specifier
	 *
	 * @param {Array} packets
	 * @api private
	 */
	
	exports.encodePayload = function (packets, supportsBinary, callback) {
	  if (typeof supportsBinary === 'function') {
	    callback = supportsBinary;
	    supportsBinary = null;
	  }
	
	  var isBinary = hasBinary(packets);
	
	  if (supportsBinary && isBinary) {
	    if (Blob && !dontSendBlobs) {
	      return exports.encodePayloadAsBlob(packets, callback);
	    }
	
	    return exports.encodePayloadAsArrayBuffer(packets, callback);
	  }
	
	  if (!packets.length) {
	    return callback('0:');
	  }
	
	  function setLengthHeader(message) {
	    return message.length + ':' + message;
	  }
	
	  function encodeOne(packet, doneCallback) {
	    exports.encodePacket(packet, !isBinary ? false : supportsBinary, false, function(message) {
	      doneCallback(null, setLengthHeader(message));
	    });
	  }
	
	  map(packets, encodeOne, function(err, results) {
	    return callback(results.join(''));
	  });
	};
	
	/**
	 * Async array map using after
	 */
	
	function map(ary, each, done) {
	  var result = new Array(ary.length);
	  var next = after(ary.length, done);
	
	  var eachWithIndex = function(i, el, cb) {
	    each(el, function(error, msg) {
	      result[i] = msg;
	      cb(error, result);
	    });
	  };
	
	  for (var i = 0; i < ary.length; i++) {
	    eachWithIndex(i, ary[i], next);
	  }
	}
	
	/*
	 * Decodes data when a payload is maybe expected. Possible binary contents are
	 * decoded from their base64 representation
	 *
	 * @param {String} data, callback method
	 * @api public
	 */
	
	exports.decodePayload = function (data, binaryType, callback) {
	  if (typeof data !== 'string') {
	    return exports.decodePayloadAsBinary(data, binaryType, callback);
	  }
	
	  if (typeof binaryType === 'function') {
	    callback = binaryType;
	    binaryType = null;
	  }
	
	  var packet;
	  if (data === '') {
	    // parser error - ignoring payload
	    return callback(err, 0, 1);
	  }
	
	  var length = '', n, msg;
	
	  for (var i = 0, l = data.length; i < l; i++) {
	    var chr = data.charAt(i);
	
	    if (chr !== ':') {
	      length += chr;
	      continue;
	    }
	
	    if (length === '' || (length != (n = Number(length)))) {
	      // parser error - ignoring payload
	      return callback(err, 0, 1);
	    }
	
	    msg = data.substr(i + 1, n);
	
	    if (length != msg.length) {
	      // parser error - ignoring payload
	      return callback(err, 0, 1);
	    }
	
	    if (msg.length) {
	      packet = exports.decodePacket(msg, binaryType, false);
	
	      if (err.type === packet.type && err.data === packet.data) {
	        // parser error in individual packet - ignoring payload
	        return callback(err, 0, 1);
	      }
	
	      var ret = callback(packet, i + n, l);
	      if (false === ret) return;
	    }
	
	    // advance cursor
	    i += n;
	    length = '';
	  }
	
	  if (length !== '') {
	    // parser error - ignoring payload
	    return callback(err, 0, 1);
	  }
	
	};
	
	/**
	 * Encodes multiple messages (payload) as binary.
	 *
	 * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number
	 * 255><data>
	 *
	 * Example:
	 * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers
	 *
	 * @param {Array} packets
	 * @return {ArrayBuffer} encoded payload
	 * @api private
	 */
	
	exports.encodePayloadAsArrayBuffer = function(packets, callback) {
	  if (!packets.length) {
	    return callback(new ArrayBuffer(0));
	  }
	
	  function encodeOne(packet, doneCallback) {
	    exports.encodePacket(packet, true, true, function(data) {
	      return doneCallback(null, data);
	    });
	  }
	
	  map(packets, encodeOne, function(err, encodedPackets) {
	    var totalLength = encodedPackets.reduce(function(acc, p) {
	      var len;
	      if (typeof p === 'string'){
	        len = p.length;
	      } else {
	        len = p.byteLength;
	      }
	      return acc + len.toString().length + len + 2; // string/binary identifier + separator = 2
	    }, 0);
	
	    var resultArray = new Uint8Array(totalLength);
	
	    var bufferIndex = 0;
	    encodedPackets.forEach(function(p) {
	      var isString = typeof p === 'string';
	      var ab = p;
	      if (isString) {
	        var view = new Uint8Array(p.length);
	        for (var i = 0; i < p.length; i++) {
	          view[i] = p.charCodeAt(i);
	        }
	        ab = view.buffer;
	      }
	
	      if (isString) { // not true binary
	        resultArray[bufferIndex++] = 0;
	      } else { // true binary
	        resultArray[bufferIndex++] = 1;
	      }
	
	      var lenStr = ab.byteLength.toString();
	      for (var i = 0; i < lenStr.length; i++) {
	        resultArray[bufferIndex++] = parseInt(lenStr[i]);
	      }
	      resultArray[bufferIndex++] = 255;
	
	      var view = new Uint8Array(ab);
	      for (var i = 0; i < view.length; i++) {
	        resultArray[bufferIndex++] = view[i];
	      }
	    });
	
	    return callback(resultArray.buffer);
	  });
	};
	
	/**
	 * Encode as Blob
	 */
	
	exports.encodePayloadAsBlob = function(packets, callback) {
	  function encodeOne(packet, doneCallback) {
	    exports.encodePacket(packet, true, true, function(encoded) {
	      var binaryIdentifier = new Uint8Array(1);
	      binaryIdentifier[0] = 1;
	      if (typeof encoded === 'string') {
	        var view = new Uint8Array(encoded.length);
	        for (var i = 0; i < encoded.length; i++) {
	          view[i] = encoded.charCodeAt(i);
	        }
	        encoded = view.buffer;
	        binaryIdentifier[0] = 0;
	      }
	
	      var len = (encoded instanceof ArrayBuffer)
	        ? encoded.byteLength
	        : encoded.size;
	
	      var lenStr = len.toString();
	      var lengthAry = new Uint8Array(lenStr.length + 1);
	      for (var i = 0; i < lenStr.length; i++) {
	        lengthAry[i] = parseInt(lenStr[i]);
	      }
	      lengthAry[lenStr.length] = 255;
	
	      if (Blob) {
	        var blob = new Blob([binaryIdentifier.buffer, lengthAry.buffer, encoded]);
	        doneCallback(null, blob);
	      }
	    });
	  }
	
	  map(packets, encodeOne, function(err, results) {
	    return callback(new Blob(results));
	  });
	};
	
	/*
	 * Decodes data when a payload is maybe expected. Strings are decoded by
	 * interpreting each byte as a key code for entries marked to start with 0. See
	 * description of encodePayloadAsBinary
	 *
	 * @param {ArrayBuffer} data, callback method
	 * @api public
	 */
	
	exports.decodePayloadAsBinary = function (data, binaryType, callback) {
	  if (typeof binaryType === 'function') {
	    callback = binaryType;
	    binaryType = null;
	  }
	
	  var bufferTail = data;
	  var buffers = [];
	
	  while (bufferTail.byteLength > 0) {
	    var tailArray = new Uint8Array(bufferTail);
	    var isString = tailArray[0] === 0;
	    var msgLength = '';
	
	    for (var i = 1; ; i++) {
	      if (tailArray[i] === 255) break;
	
	      // 310 = char length of Number.MAX_VALUE
	      if (msgLength.length > 310) {
	        return callback(err, 0, 1);
	      }
	
	      msgLength += tailArray[i];
	    }
	
	    bufferTail = sliceBuffer(bufferTail, 2 + msgLength.length);
	    msgLength = parseInt(msgLength);
	
	    var msg = sliceBuffer(bufferTail, 0, msgLength);
	    if (isString) {
	      try {
	        msg = String.fromCharCode.apply(null, new Uint8Array(msg));
	      } catch (e) {
	        // iPhone Safari doesn't let you apply to typed arrays
	        var typed = new Uint8Array(msg);
	        msg = '';
	        for (var i = 0; i < typed.length; i++) {
	          msg += String.fromCharCode(typed[i]);
	        }
	      }
	    }
	
	    buffers.push(msg);
	    bufferTail = sliceBuffer(bufferTail, msgLength);
	  }
	
	  var total = buffers.length;
	  buffers.forEach(function(buffer, i) {
	    callback(exports.decodePacket(buffer, binaryType, true), i, total);
	  });
	};


/***/ }),
/* 22 */
/***/ (function(module, exports) {

	
	/**
	 * Gets the keys for an object.
	 *
	 * @return {Array} keys
	 * @api private
	 */
	
	module.exports = Object.keys || function keys (obj){
	  var arr = [];
	  var has = Object.prototype.hasOwnProperty;
	
	  for (var i in obj) {
	    if (has.call(obj, i)) {
	      arr.push(i);
	    }
	  }
	  return arr;
	};


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

	/* global Blob File */
	
	/*
	 * Module requirements.
	 */
	
	var isArray = __webpack_require__(10);
	
	var toString = Object.prototype.toString;
	var withNativeBlob = typeof Blob === 'function' ||
	                        typeof Blob !== 'undefined' && toString.call(Blob) === '[object BlobConstructor]';
	var withNativeFile = typeof File === 'function' ||
	                        typeof File !== 'undefined' && toString.call(File) === '[object FileConstructor]';
	
	/**
	 * Module exports.
	 */
	
	module.exports = hasBinary;
	
	/**
	 * Checks for binary data.
	 *
	 * Supports Buffer, ArrayBuffer, Blob and File.
	 *
	 * @param {Object} anything
	 * @api public
	 */
	
	function hasBinary (obj) {
	  if (!obj || typeof obj !== 'object') {
	    return false;
	  }
	
	  if (isArray(obj)) {
	    for (var i = 0, l = obj.length; i < l; i++) {
	      if (hasBinary(obj[i])) {
	        return true;
	      }
	    }
	    return false;
	  }
	
	  if ((typeof Buffer === 'function' && Buffer.isBuffer && Buffer.isBuffer(obj)) ||
	    (typeof ArrayBuffer === 'function' && obj instanceof ArrayBuffer) ||
	    (withNativeBlob && obj instanceof Blob) ||
	    (withNativeFile && obj instanceof File)
	  ) {
	    return true;
	  }
	
	  // see: https://github.com/Automattic/has-binary/pull/4
	  if (obj.toJSON && typeof obj.toJSON === 'function' && arguments.length === 1) {
	    return hasBinary(obj.toJSON(), true);
	  }
	
	  for (var key in obj) {
	    if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {
	      return true;
	    }
	  }
	
	  return false;
	}


/***/ }),
/* 24 */
/***/ (function(module, exports) {

	/**
	 * An abstraction for slicing an arraybuffer even when
	 * ArrayBuffer.prototype.slice is not supported
	 *
	 * @api public
	 */
	
	module.exports = function(arraybuffer, start, end) {
	  var bytes = arraybuffer.byteLength;
	  start = start || 0;
	  end = end || bytes;
	
	  if (arraybuffer.slice) { return arraybuffer.slice(start, end); }
	
	  if (start < 0) { start += bytes; }
	  if (end < 0) { end += bytes; }
	  if (end > bytes) { end = bytes; }
	
	  if (start >= bytes || start >= end || bytes === 0) {
	    return new ArrayBuffer(0);
	  }
	
	  var abv = new Uint8Array(arraybuffer);
	  var result = new Uint8Array(end - start);
	  for (var i = start, ii = 0; i < end; i++, ii++) {
	    result[ii] = abv[i];
	  }
	  return result.buffer;
	};


/***/ }),
/* 25 */
/***/ (function(module, exports) {

	module.exports = after
	
	function after(count, callback, err_cb) {
	    var bail = false
	    err_cb = err_cb || noop
	    proxy.count = count
	
	    return (count === 0) ? callback() : proxy
	
	    function proxy(err, result) {
	        if (proxy.count <= 0) {
	            throw new Error('after called too many times')
	        }
	        --proxy.count
	
	        // after first error, rest are passed to err_cb
	        if (err) {
	            bail = true
	            callback(err)
	            // future error callbacks will go to error handler
	            callback = err_cb
	        } else if (proxy.count === 0 && !bail) {
	            callback(null, result)
	        }
	    }
	}
	
	function noop() {}


/***/ }),
/* 26 */
/***/ (function(module, exports) {

	/*! https://mths.be/utf8js v2.1.2 by @mathias */
	
	var stringFromCharCode = String.fromCharCode;
	
	// Taken from https://mths.be/punycode
	function ucs2decode(string) {
		var output = [];
		var counter = 0;
		var length = string.length;
		var value;
		var extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}
	
	// Taken from https://mths.be/punycode
	function ucs2encode(array) {
		var length = array.length;
		var index = -1;
		var value;
		var output = '';
		while (++index < length) {
			value = array[index];
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
		}
		return output;
	}
	
	function checkScalarValue(codePoint, strict) {
		if (codePoint >= 0xD800 && codePoint <= 0xDFFF) {
			if (strict) {
				throw Error(
					'Lone surrogate U+' + codePoint.toString(16).toUpperCase() +
					' is not a scalar value'
				);
			}
			return false;
		}
		return true;
	}
	/*--------------------------------------------------------------------------*/
	
	function createByte(codePoint, shift) {
		return stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);
	}
	
	function encodeCodePoint(codePoint, strict) {
		if ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence
			return stringFromCharCode(codePoint);
		}
		var symbol = '';
		if ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence
			symbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);
		}
		else if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence
			if (!checkScalarValue(codePoint, strict)) {
				codePoint = 0xFFFD;
			}
			symbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);
			symbol += createByte(codePoint, 6);
		}
		else if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence
			symbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);
			symbol += createByte(codePoint, 12);
			symbol += createByte(codePoint, 6);
		}
		symbol += stringFromCharCode((codePoint & 0x3F) | 0x80);
		return symbol;
	}
	
	function utf8encode(string, opts) {
		opts = opts || {};
		var strict = false !== opts.strict;
	
		var codePoints = ucs2decode(string);
		var length = codePoints.length;
		var index = -1;
		var codePoint;
		var byteString = '';
		while (++index < length) {
			codePoint = codePoints[index];
			byteString += encodeCodePoint(codePoint, strict);
		}
		return byteString;
	}
	
	/*--------------------------------------------------------------------------*/
	
	function readContinuationByte() {
		if (byteIndex >= byteCount) {
			throw Error('Invalid byte index');
		}
	
		var continuationByte = byteArray[byteIndex] & 0xFF;
		byteIndex++;
	
		if ((continuationByte & 0xC0) == 0x80) {
			return continuationByte & 0x3F;
		}
	
		// If we end up here, its not a continuation byte
		throw Error('Invalid continuation byte');
	}
	
	function decodeSymbol(strict) {
		var byte1;
		var byte2;
		var byte3;
		var byte4;
		var codePoint;
	
		if (byteIndex > byteCount) {
			throw Error('Invalid byte index');
		}
	
		if (byteIndex == byteCount) {
			return false;
		}
	
		// Read first byte
		byte1 = byteArray[byteIndex] & 0xFF;
		byteIndex++;
	
		// 1-byte sequence (no continuation bytes)
		if ((byte1 & 0x80) == 0) {
			return byte1;
		}
	
		// 2-byte sequence
		if ((byte1 & 0xE0) == 0xC0) {
			byte2 = readContinuationByte();
			codePoint = ((byte1 & 0x1F) << 6) | byte2;
			if (codePoint >= 0x80) {
				return codePoint;
			} else {
				throw Error('Invalid continuation byte');
			}
		}
	
		// 3-byte sequence (may include unpaired surrogates)
		if ((byte1 & 0xF0) == 0xE0) {
			byte2 = readContinuationByte();
			byte3 = readContinuationByte();
			codePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;
			if (codePoint >= 0x0800) {
				return checkScalarValue(codePoint, strict) ? codePoint : 0xFFFD;
			} else {
				throw Error('Invalid continuation byte');
			}
		}
	
		// 4-byte sequence
		if ((byte1 & 0xF8) == 0xF0) {
			byte2 = readContinuationByte();
			byte3 = readContinuationByte();
			byte4 = readContinuationByte();
			codePoint = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0C) |
				(byte3 << 0x06) | byte4;
			if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {
				return codePoint;
			}
		}
	
		throw Error('Invalid UTF-8 detected');
	}
	
	var byteArray;
	var byteCount;
	var byteIndex;
	function utf8decode(byteString, opts) {
		opts = opts || {};
		var strict = false !== opts.strict;
	
		byteArray = ucs2decode(byteString);
		byteCount = byteArray.length;
		byteIndex = 0;
		var codePoints = [];
		var tmp;
		while ((tmp = decodeSymbol(strict)) !== false) {
			codePoints.push(tmp);
		}
		return ucs2encode(codePoints);
	}
	
	module.exports = {
		version: '2.1.2',
		encode: utf8encode,
		decode: utf8decode
	};


/***/ }),
/* 27 */
/***/ (function(module, exports) {

	/*
	 * base64-arraybuffer
	 * https://github.com/niklasvh/base64-arraybuffer
	 *
	 * Copyright (c) 2012 Niklas von Hertzen
	 * Licensed under the MIT license.
	 */
	(function(){
	  "use strict";
	
	  var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
	
	  // Use a lookup table to find the index.
	  var lookup = new Uint8Array(256);
	  for (var i = 0; i < chars.length; i++) {
	    lookup[chars.charCodeAt(i)] = i;
	  }
	
	  exports.encode = function(arraybuffer) {
	    var bytes = new Uint8Array(arraybuffer),
	    i, len = bytes.length, base64 = "";
	
	    for (i = 0; i < len; i+=3) {
	      base64 += chars[bytes[i] >> 2];
	      base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];
	      base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];
	      base64 += chars[bytes[i + 2] & 63];
	    }
	
	    if ((len % 3) === 2) {
	      base64 = base64.substring(0, base64.length - 1) + "=";
	    } else if (len % 3 === 1) {
	      base64 = base64.substring(0, base64.length - 2) + "==";
	    }
	
	    return base64;
	  };
	
	  exports.decode =  function(base64) {
	    var bufferLength = base64.length * 0.75,
	    len = base64.length, i, p = 0,
	    encoded1, encoded2, encoded3, encoded4;
	
	    if (base64[base64.length - 1] === "=") {
	      bufferLength--;
	      if (base64[base64.length - 2] === "=") {
	        bufferLength--;
	      }
	    }
	
	    var arraybuffer = new ArrayBuffer(bufferLength),
	    bytes = new Uint8Array(arraybuffer);
	
	    for (i = 0; i < len; i+=4) {
	      encoded1 = lookup[base64.charCodeAt(i)];
	      encoded2 = lookup[base64.charCodeAt(i+1)];
	      encoded3 = lookup[base64.charCodeAt(i+2)];
	      encoded4 = lookup[base64.charCodeAt(i+3)];
	
	      bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
	      bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
	      bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
	    }
	
	    return arraybuffer;
	  };
	})();


/***/ }),
/* 28 */
/***/ (function(module, exports) {

	/**
	 * Create a blob builder even when vendor prefixes exist
	 */
	
	var BlobBuilder = typeof BlobBuilder !== 'undefined' ? BlobBuilder :
	  typeof WebKitBlobBuilder !== 'undefined' ? WebKitBlobBuilder :
	  typeof MSBlobBuilder !== 'undefined' ? MSBlobBuilder :
	  typeof MozBlobBuilder !== 'undefined' ? MozBlobBuilder : 
	  false;
	
	/**
	 * Check if Blob constructor is supported
	 */
	
	var blobSupported = (function() {
	  try {
	    var a = new Blob(['hi']);
	    return a.size === 2;
	  } catch(e) {
	    return false;
	  }
	})();
	
	/**
	 * Check if Blob constructor supports ArrayBufferViews
	 * Fails in Safari 6, so we need to map to ArrayBuffers there.
	 */
	
	var blobSupportsArrayBufferView = blobSupported && (function() {
	  try {
	    var b = new Blob([new Uint8Array([1,2])]);
	    return b.size === 2;
	  } catch(e) {
	    return false;
	  }
	})();
	
	/**
	 * Check if BlobBuilder is supported
	 */
	
	var blobBuilderSupported = BlobBuilder
	  && BlobBuilder.prototype.append
	  && BlobBuilder.prototype.getBlob;
	
	/**
	 * Helper function that maps ArrayBufferViews to ArrayBuffers
	 * Used by BlobBuilder constructor and old browsers that didn't
	 * support it in the Blob constructor.
	 */
	
	function mapArrayBufferViews(ary) {
	  return ary.map(function(chunk) {
	    if (chunk.buffer instanceof ArrayBuffer) {
	      var buf = chunk.buffer;
	
	      // if this is a subarray, make a copy so we only
	      // include the subarray region from the underlying buffer
	      if (chunk.byteLength !== buf.byteLength) {
	        var copy = new Uint8Array(chunk.byteLength);
	        copy.set(new Uint8Array(buf, chunk.byteOffset, chunk.byteLength));
	        buf = copy.buffer;
	      }
	
	      return buf;
	    }
	
	    return chunk;
	  });
	}
	
	function BlobBuilderConstructor(ary, options) {
	  options = options || {};
	
	  var bb = new BlobBuilder();
	  mapArrayBufferViews(ary).forEach(function(part) {
	    bb.append(part);
	  });
	
	  return (options.type) ? bb.getBlob(options.type) : bb.getBlob();
	};
	
	function BlobConstructor(ary, options) {
	  return new Blob(mapArrayBufferViews(ary), options || {});
	};
	
	if (typeof Blob !== 'undefined') {
	  BlobBuilderConstructor.prototype = Blob.prototype;
	  BlobConstructor.prototype = Blob.prototype;
	}
	
	module.exports = (function() {
	  if (blobSupported) {
	    return blobSupportsArrayBufferView ? Blob : BlobConstructor;
	  } else if (blobBuilderSupported) {
	    return BlobBuilderConstructor;
	  } else {
	    return undefined;
	  }
	})();


/***/ }),
/* 29 */
/***/ (function(module, exports) {

	/**
	 * Compiles a querystring
	 * Returns string representation of the object
	 *
	 * @param {Object}
	 * @api private
	 */
	
	exports.encode = function (obj) {
	  var str = '';
	
	  for (var i in obj) {
	    if (obj.hasOwnProperty(i)) {
	      if (str.length) str += '&';
	      str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);
	    }
	  }
	
	  return str;
	};
	
	/**
	 * Parses a simple querystring into an object
	 *
	 * @param {String} qs
	 * @api private
	 */
	
	exports.decode = function(qs){
	  var qry = {};
	  var pairs = qs.split('&');
	  for (var i = 0, l = pairs.length; i < l; i++) {
	    var pair = pairs[i].split('=');
	    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
	  }
	  return qry;
	};


/***/ }),
/* 30 */
/***/ (function(module, exports) {

	
	module.exports = function(a, b){
	  var fn = function(){};
	  fn.prototype = b.prototype;
	  a.prototype = new fn;
	  a.prototype.constructor = a;
	};

/***/ }),
/* 31 */
/***/ (function(module, exports) {

	'use strict';
	
	var alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split('')
	  , length = 64
	  , map = {}
	  , seed = 0
	  , i = 0
	  , prev;
	
	/**
	 * Return a string representing the specified number.
	 *
	 * @param {Number} num The number to convert.
	 * @returns {String} The string representation of the number.
	 * @api public
	 */
	function encode(num) {
	  var encoded = '';
	
	  do {
	    encoded = alphabet[num % length] + encoded;
	    num = Math.floor(num / length);
	  } while (num > 0);
	
	  return encoded;
	}
	
	/**
	 * Return the integer value specified by the given string.
	 *
	 * @param {String} str The string to convert.
	 * @returns {Number} The integer value represented by the string.
	 * @api public
	 */
	function decode(str) {
	  var decoded = 0;
	
	  for (i = 0; i < str.length; i++) {
	    decoded = decoded * length + map[str.charAt(i)];
	  }
	
	  return decoded;
	}
	
	/**
	 * Yeast: A tiny growing id generator.
	 *
	 * @returns {String} A unique id.
	 * @api public
	 */
	function yeast() {
	  var now = encode(+new Date());
	
	  if (now !== prev) return seed = 0, prev = now;
	  return now +'.'+ encode(seed++);
	}
	
	//
	// Map each character to its index.
	//
	for (; i < length; i++) map[alphabet[i]] = i;
	
	//
	// Expose the `yeast`, `encode` and `decode` functions.
	//
	yeast.encode = encode;
	yeast.decode = decode;
	module.exports = yeast;


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * Module requirements.
	 */
	
	var Polling = __webpack_require__(19);
	var inherit = __webpack_require__(30);
	
	/**
	 * Module exports.
	 */
	
	module.exports = JSONPPolling;
	
	/**
	 * Cached regular expressions.
	 */
	
	var rNewline = /\n/g;
	var rEscapedNewline = /\\n/g;
	
	/**
	 * Global JSONP callbacks.
	 */
	
	var callbacks;
	
	/**
	 * Noop.
	 */
	
	function empty () { }
	
	/**
	 * Until https://github.com/tc39/proposal-global is shipped.
	 */
	function glob () {
	  return typeof self !== 'undefined' ? self
	      : typeof window !== 'undefined' ? window
	      : typeof global !== 'undefined' ? global : {};
	}
	
	/**
	 * JSONP Polling constructor.
	 *
	 * @param {Object} opts.
	 * @api public
	 */
	
	function JSONPPolling (opts) {
	  Polling.call(this, opts);
	
	  this.query = this.query || {};
	
	  // define global callbacks array if not present
	  // we do this here (lazily) to avoid unneeded global pollution
	  if (!callbacks) {
	    // we need to consider multiple engines in the same page
	    var global = glob();
	    callbacks = global.___eio = (global.___eio || []);
	  }
	
	  // callback identifier
	  this.index = callbacks.length;
	
	  // add callback to jsonp global
	  var self = this;
	  callbacks.push(function (msg) {
	    self.onData(msg);
	  });
	
	  // append to query string
	  this.query.j = this.index;
	
	  // prevent spurious errors from being emitted when the window is unloaded
	  if (typeof addEventListener === 'function') {
	    addEventListener('beforeunload', function () {
	      if (self.script) self.script.onerror = empty;
	    }, false);
	  }
	}
	
	/**
	 * Inherits from Polling.
	 */
	
	inherit(JSONPPolling, Polling);
	
	/*
	 * JSONP only supports binary as base64 encoded strings
	 */
	
	JSONPPolling.prototype.supportsBinary = false;
	
	/**
	 * Closes the socket.
	 *
	 * @api private
	 */
	
	JSONPPolling.prototype.doClose = function () {
	  if (this.script) {
	    this.script.parentNode.removeChild(this.script);
	    this.script = null;
	  }
	
	  if (this.form) {
	    this.form.parentNode.removeChild(this.form);
	    this.form = null;
	    this.iframe = null;
	  }
	
	  Polling.prototype.doClose.call(this);
	};
	
	/**
	 * Starts a poll cycle.
	 *
	 * @api private
	 */
	
	JSONPPolling.prototype.doPoll = function () {
	  var self = this;
	  var script = document.createElement('script');
	
	  if (this.script) {
	    this.script.parentNode.removeChild(this.script);
	    this.script = null;
	  }
	
	  script.async = true;
	  script.src = this.uri();
	  script.onerror = function (e) {
	    self.onError('jsonp poll error', e);
	  };
	
	  var insertAt = document.getElementsByTagName('script')[0];
	  if (insertAt) {
	    insertAt.parentNode.insertBefore(script, insertAt);
	  } else {
	    (document.head || document.body).appendChild(script);
	  }
	  this.script = script;
	
	  var isUAgecko = 'undefined' !== typeof navigator && /gecko/i.test(navigator.userAgent);
	
	  if (isUAgecko) {
	    setTimeout(function () {
	      var iframe = document.createElement('iframe');
	      document.body.appendChild(iframe);
	      document.body.removeChild(iframe);
	    }, 100);
	  }
	};
	
	/**
	 * Writes with a hidden iframe.
	 *
	 * @param {String} data to send
	 * @param {Function} called upon flush.
	 * @api private
	 */
	
	JSONPPolling.prototype.doWrite = function (data, fn) {
	  var self = this;
	
	  if (!this.form) {
	    var form = document.createElement('form');
	    var area = document.createElement('textarea');
	    var id = this.iframeId = 'eio_iframe_' + this.index;
	    var iframe;
	
	    form.className = 'socketio';
	    form.style.position = 'absolute';
	    form.style.top = '-1000px';
	    form.style.left = '-1000px';
	    form.target = id;
	    form.method = 'POST';
	    form.setAttribute('accept-charset', 'utf-8');
	    area.name = 'd';
	    form.appendChild(area);
	    document.body.appendChild(form);
	
	    this.form = form;
	    this.area = area;
	  }
	
	  this.form.action = this.uri();
	
	  function complete () {
	    initIframe();
	    fn();
	  }
	
	  function initIframe () {
	    if (self.iframe) {
	      try {
	        self.form.removeChild(self.iframe);
	      } catch (e) {
	        self.onError('jsonp polling iframe removal error', e);
	      }
	    }
	
	    try {
	      // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
	      var html = '<iframe src="javascript:0" name="' + self.iframeId + '">';
	      iframe = document.createElement(html);
	    } catch (e) {
	      iframe = document.createElement('iframe');
	      iframe.name = self.iframeId;
	      iframe.src = 'javascript:0';
	    }
	
	    iframe.id = self.iframeId;
	
	    self.form.appendChild(iframe);
	    self.iframe = iframe;
	  }
	
	  initIframe();
	
	  // escape \n to prevent it from being converted into \r\n by some UAs
	  // double escaping is required for escaped new lines because unescaping of new lines can be done safely on server-side
	  data = data.replace(rEscapedNewline, '\\\n');
	  this.area.value = data.replace(rNewline, '\\n');
	
	  try {
	    this.form.submit();
	  } catch (e) {}
	
	  if (this.iframe.attachEvent) {
	    this.iframe.onreadystatechange = function () {
	      if (self.iframe.readyState === 'complete') {
	        complete();
	      }
	    };
	  } else {
	    this.iframe.onload = complete;
	  }
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Module dependencies.
	 */
	
	var Transport = __webpack_require__(20);
	var parser = __webpack_require__(21);
	var parseqs = __webpack_require__(29);
	var inherit = __webpack_require__(30);
	var yeast = __webpack_require__(31);
	var debug = __webpack_require__(3)('engine.io-client:websocket');
	var BrowserWebSocket, NodeWebSocket;
	if (typeof self === 'undefined') {
	  try {
	    NodeWebSocket = __webpack_require__(34);
	  } catch (e) { }
	} else {
	  BrowserWebSocket = self.WebSocket || self.MozWebSocket;
	}
	
	/**
	 * Get either the `WebSocket` or `MozWebSocket` globals
	 * in the browser or try to resolve WebSocket-compatible
	 * interface exposed by `ws` for Node-like environment.
	 */
	
	var WebSocket = BrowserWebSocket || NodeWebSocket;
	
	/**
	 * Module exports.
	 */
	
	module.exports = WS;
	
	/**
	 * WebSocket transport constructor.
	 *
	 * @api {Object} connection options
	 * @api public
	 */
	
	function WS (opts) {
	  var forceBase64 = (opts && opts.forceBase64);
	  if (forceBase64) {
	    this.supportsBinary = false;
	  }
	  this.perMessageDeflate = opts.perMessageDeflate;
	  this.usingBrowserWebSocket = BrowserWebSocket && !opts.forceNode;
	  this.protocols = opts.protocols;
	  if (!this.usingBrowserWebSocket) {
	    WebSocket = NodeWebSocket;
	  }
	  Transport.call(this, opts);
	}
	
	/**
	 * Inherits from Transport.
	 */
	
	inherit(WS, Transport);
	
	/**
	 * Transport name.
	 *
	 * @api public
	 */
	
	WS.prototype.name = 'websocket';
	
	/*
	 * WebSockets support binary
	 */
	
	WS.prototype.supportsBinary = true;
	
	/**
	 * Opens socket.
	 *
	 * @api private
	 */
	
	WS.prototype.doOpen = function () {
	  if (!this.check()) {
	    // let probe timeout
	    return;
	  }
	
	  var uri = this.uri();
	  var protocols = this.protocols;
	  var opts = {
	    agent: this.agent,
	    perMessageDeflate: this.perMessageDeflate
	  };
	
	  // SSL options for Node.js client
	  opts.pfx = this.pfx;
	  opts.key = this.key;
	  opts.passphrase = this.passphrase;
	  opts.cert = this.cert;
	  opts.ca = this.ca;
	  opts.ciphers = this.ciphers;
	  opts.rejectUnauthorized = this.rejectUnauthorized;
	  if (this.extraHeaders) {
	    opts.headers = this.extraHeaders;
	  }
	  if (this.localAddress) {
	    opts.localAddress = this.localAddress;
	  }
	
	  try {
	    this.ws = this.usingBrowserWebSocket && !this.isReactNative ? (protocols ? new WebSocket(uri, protocols) : new WebSocket(uri)) : new WebSocket(uri, protocols, opts);
	  } catch (err) {
	    return this.emit('error', err);
	  }
	
	  if (this.ws.binaryType === undefined) {
	    this.supportsBinary = false;
	  }
	
	  if (this.ws.supports && this.ws.supports.binary) {
	    this.supportsBinary = true;
	    this.ws.binaryType = 'nodebuffer';
	  } else {
	    this.ws.binaryType = 'arraybuffer';
	  }
	
	  this.addEventListeners();
	};
	
	/**
	 * Adds event listeners to the socket
	 *
	 * @api private
	 */
	
	WS.prototype.addEventListeners = function () {
	  var self = this;
	
	  this.ws.onopen = function () {
	    self.onOpen();
	  };
	  this.ws.onclose = function () {
	    self.onClose();
	  };
	  this.ws.onmessage = function (ev) {
	    self.onData(ev.data);
	  };
	  this.ws.onerror = function (e) {
	    self.onError('websocket error', e);
	  };
	};
	
	/**
	 * Writes data to socket.
	 *
	 * @param {Array} array of packets.
	 * @api private
	 */
	
	WS.prototype.write = function (packets) {
	  var self = this;
	  this.writable = false;
	
	  // encodePacket efficient as it uses WS framing
	  // no need for encodePayload
	  var total = packets.length;
	  for (var i = 0, l = total; i < l; i++) {
	    (function (packet) {
	      parser.encodePacket(packet, self.supportsBinary, function (data) {
	        if (!self.usingBrowserWebSocket) {
	          // always create a new object (GH-437)
	          var opts = {};
	          if (packet.options) {
	            opts.compress = packet.options.compress;
	          }
	
	          if (self.perMessageDeflate) {
	            var len = 'string' === typeof data ? Buffer.byteLength(data) : data.length;
	            if (len < self.perMessageDeflate.threshold) {
	              opts.compress = false;
	            }
	          }
	        }
	
	        // Sometimes the websocket has already been closed but the browser didn't
	        // have a chance of informing us about it yet, in that case send will
	        // throw an error
	        try {
	          if (self.usingBrowserWebSocket) {
	            // TypeError is thrown when passing the second argument on Safari
	            self.ws.send(data);
	          } else {
	            self.ws.send(data, opts);
	          }
	        } catch (e) {
	          debug('websocket closed before onclose event');
	        }
	
	        --total || done();
	      });
	    })(packets[i]);
	  }
	
	  function done () {
	    self.emit('flush');
	
	    // fake drain
	    // defer to next tick to allow Socket to clear writeBuffer
	    setTimeout(function () {
	      self.writable = true;
	      self.emit('drain');
	    }, 0);
	  }
	};
	
	/**
	 * Called upon close
	 *
	 * @api private
	 */
	
	WS.prototype.onClose = function () {
	  Transport.prototype.onClose.call(this);
	};
	
	/**
	 * Closes socket.
	 *
	 * @api private
	 */
	
	WS.prototype.doClose = function () {
	  if (typeof this.ws !== 'undefined') {
	    this.ws.close();
	  }
	};
	
	/**
	 * Generates uri for connection.
	 *
	 * @api private
	 */
	
	WS.prototype.uri = function () {
	  var query = this.query || {};
	  var schema = this.secure ? 'wss' : 'ws';
	  var port = '';
	
	  // avoid port if default for schema
	  if (this.port && (('wss' === schema && Number(this.port) !== 443) ||
	    ('ws' === schema && Number(this.port) !== 80))) {
	    port = ':' + this.port;
	  }
	
	  // append timestamp to URI
	  if (this.timestampRequests) {
	    query[this.timestampParam] = yeast();
	  }
	
	  // communicate binary support capabilities
	  if (!this.supportsBinary) {
	    query.b64 = 1;
	  }
	
	  query = parseqs.encode(query);
	
	  // prepend ? to query
	  if (query.length) {
	    query = '?' + query;
	  }
	
	  var ipv6 = this.hostname.indexOf(':') !== -1;
	  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
	};
	
	/**
	 * Feature detection for WebSocket.
	 *
	 * @return {Boolean} whether this transport is available.
	 * @api public
	 */
	
	WS.prototype.check = function () {
	  return !!WebSocket && !('__initialize' in WebSocket && this.name === WS.prototype.name);
	};


/***/ }),
/* 34 */
/***/ (function(module, exports) {

	/* (ignored) */

/***/ }),
/* 35 */
/***/ (function(module, exports) {

	
	var indexOf = [].indexOf;
	
	module.exports = function(arr, obj){
	  if (indexOf) return arr.indexOf(obj);
	  for (var i = 0; i < arr.length; ++i) {
	    if (arr[i] === obj) return i;
	  }
	  return -1;
	};

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	/**
	 * Module dependencies.
	 */
	
	var parser = __webpack_require__(7);
	var Emitter = __webpack_require__(8);
	var toArray = __webpack_require__(37);
	var on = __webpack_require__(38);
	var bind = __webpack_require__(39);
	var debug = __webpack_require__(3)('socket.io-client:socket');
	var parseqs = __webpack_require__(29);
	var hasBin = __webpack_require__(23);
	
	/**
	 * Module exports.
	 */
	
	module.exports = exports = Socket;
	
	/**
	 * Internal events (blacklisted).
	 * These events can't be emitted by the user.
	 *
	 * @api private
	 */
	
	var events = {
	  connect: 1,
	  connect_error: 1,
	  connect_timeout: 1,
	  connecting: 1,
	  disconnect: 1,
	  error: 1,
	  reconnect: 1,
	  reconnect_attempt: 1,
	  reconnect_failed: 1,
	  reconnect_error: 1,
	  reconnecting: 1,
	  ping: 1,
	  pong: 1
	};
	
	/**
	 * Shortcut to `Emitter#emit`.
	 */
	
	var emit = Emitter.prototype.emit;
	
	/**
	 * `Socket` constructor.
	 *
	 * @api public
	 */
	
	function Socket(io, nsp, opts) {
	  this.io = io;
	  this.nsp = nsp;
	  this.json = this; // compat
	  this.ids = 0;
	  this.acks = {};
	  this.receiveBuffer = [];
	  this.sendBuffer = [];
	  this.connected = false;
	  this.disconnected = true;
	  this.flags = {};
	  if (opts && opts.query) {
	    this.query = opts.query;
	  }
	  if (this.io.autoConnect) this.open();
	}
	
	/**
	 * Mix in `Emitter`.
	 */
	
	Emitter(Socket.prototype);
	
	/**
	 * Subscribe to open, close and packet events
	 *
	 * @api private
	 */
	
	Socket.prototype.subEvents = function () {
	  if (this.subs) return;
	
	  var io = this.io;
	  this.subs = [on(io, 'open', bind(this, 'onopen')), on(io, 'packet', bind(this, 'onpacket')), on(io, 'close', bind(this, 'onclose'))];
	};
	
	/**
	 * "Opens" the socket.
	 *
	 * @api public
	 */
	
	Socket.prototype.open = Socket.prototype.connect = function () {
	  if (this.connected) return this;
	
	  this.subEvents();
	  this.io.open(); // ensure open
	  if ('open' === this.io.readyState) this.onopen();
	  this.emit('connecting');
	  return this;
	};
	
	/**
	 * Sends a `message` event.
	 *
	 * @return {Socket} self
	 * @api public
	 */
	
	Socket.prototype.send = function () {
	  var args = toArray(arguments);
	  args.unshift('message');
	  this.emit.apply(this, args);
	  return this;
	};
	
	/**
	 * Override `emit`.
	 * If the event is in `events`, it's emitted normally.
	 *
	 * @param {String} event name
	 * @return {Socket} self
	 * @api public
	 */
	
	Socket.prototype.emit = function (ev) {
	  if (events.hasOwnProperty(ev)) {
	    emit.apply(this, arguments);
	    return this;
	  }
	
	  var args = toArray(arguments);
	  var packet = {
	    type: (this.flags.binary !== undefined ? this.flags.binary : hasBin(args)) ? parser.BINARY_EVENT : parser.EVENT,
	    data: args
	  };
	
	  packet.options = {};
	  packet.options.compress = !this.flags || false !== this.flags.compress;
	
	  // event ack callback
	  if ('function' === typeof args[args.length - 1]) {
	    debug('emitting packet with ack id %d', this.ids);
	    this.acks[this.ids] = args.pop();
	    packet.id = this.ids++;
	  }
	
	  if (this.connected) {
	    this.packet(packet);
	  } else {
	    this.sendBuffer.push(packet);
	  }
	
	  this.flags = {};
	
	  return this;
	};
	
	/**
	 * Sends a packet.
	 *
	 * @param {Object} packet
	 * @api private
	 */
	
	Socket.prototype.packet = function (packet) {
	  packet.nsp = this.nsp;
	  this.io.packet(packet);
	};
	
	/**
	 * Called upon engine `open`.
	 *
	 * @api private
	 */
	
	Socket.prototype.onopen = function () {
	  debug('transport is open - connecting');
	
	  // write connect packet if necessary
	  if ('/' !== this.nsp) {
	    if (this.query) {
	      var query = _typeof(this.query) === 'object' ? parseqs.encode(this.query) : this.query;
	      debug('sending connect packet with query %s', query);
	      this.packet({ type: parser.CONNECT, query: query });
	    } else {
	      this.packet({ type: parser.CONNECT });
	    }
	  }
	};
	
	/**
	 * Called upon engine `close`.
	 *
	 * @param {String} reason
	 * @api private
	 */
	
	Socket.prototype.onclose = function (reason) {
	  debug('close (%s)', reason);
	  this.connected = false;
	  this.disconnected = true;
	  delete this.id;
	  this.emit('disconnect', reason);
	};
	
	/**
	 * Called with socket packet.
	 *
	 * @param {Object} packet
	 * @api private
	 */
	
	Socket.prototype.onpacket = function (packet) {
	  var sameNamespace = packet.nsp === this.nsp;
	  var rootNamespaceError = packet.type === parser.ERROR && packet.nsp === '/';
	
	  if (!sameNamespace && !rootNamespaceError) return;
	
	  switch (packet.type) {
	    case parser.CONNECT:
	      this.onconnect();
	      break;
	
	    case parser.EVENT:
	      this.onevent(packet);
	      break;
	
	    case parser.BINARY_EVENT:
	      this.onevent(packet);
	      break;
	
	    case parser.ACK:
	      this.onack(packet);
	      break;
	
	    case parser.BINARY_ACK:
	      this.onack(packet);
	      break;
	
	    case parser.DISCONNECT:
	      this.ondisconnect();
	      break;
	
	    case parser.ERROR:
	      this.emit('error', packet.data);
	      break;
	  }
	};
	
	/**
	 * Called upon a server event.
	 *
	 * @param {Object} packet
	 * @api private
	 */
	
	Socket.prototype.onevent = function (packet) {
	  var args = packet.data || [];
	  debug('emitting event %j', args);
	
	  if (null != packet.id) {
	    debug('attaching ack callback to event');
	    args.push(this.ack(packet.id));
	  }
	
	  if (this.connected) {
	    emit.apply(this, args);
	  } else {
	    this.receiveBuffer.push(args);
	  }
	};
	
	/**
	 * Produces an ack callback to emit with an event.
	 *
	 * @api private
	 */
	
	Socket.prototype.ack = function (id) {
	  var self = this;
	  var sent = false;
	  return function () {
	    // prevent double callbacks
	    if (sent) return;
	    sent = true;
	    var args = toArray(arguments);
	    debug('sending ack %j', args);
	
	    self.packet({
	      type: hasBin(args) ? parser.BINARY_ACK : parser.ACK,
	      id: id,
	      data: args
	    });
	  };
	};
	
	/**
	 * Called upon a server acknowlegement.
	 *
	 * @param {Object} packet
	 * @api private
	 */
	
	Socket.prototype.onack = function (packet) {
	  var ack = this.acks[packet.id];
	  if ('function' === typeof ack) {
	    debug('calling ack %s with %j', packet.id, packet.data);
	    ack.apply(this, packet.data);
	    delete this.acks[packet.id];
	  } else {
	    debug('bad ack %s', packet.id);
	  }
	};
	
	/**
	 * Called upon server connect.
	 *
	 * @api private
	 */
	
	Socket.prototype.onconnect = function () {
	  this.connected = true;
	  this.disconnected = false;
	  this.emit('connect');
	  this.emitBuffered();
	};
	
	/**
	 * Emit buffered events (received and emitted).
	 *
	 * @api private
	 */
	
	Socket.prototype.emitBuffered = function () {
	  var i;
	  for (i = 0; i < this.receiveBuffer.length; i++) {
	    emit.apply(this, this.receiveBuffer[i]);
	  }
	  this.receiveBuffer = [];
	
	  for (i = 0; i < this.sendBuffer.length; i++) {
	    this.packet(this.sendBuffer[i]);
	  }
	  this.sendBuffer = [];
	};
	
	/**
	 * Called upon server disconnect.
	 *
	 * @api private
	 */
	
	Socket.prototype.ondisconnect = function () {
	  debug('server disconnect (%s)', this.nsp);
	  this.destroy();
	  this.onclose('io server disconnect');
	};
	
	/**
	 * Called upon forced client/server side disconnections,
	 * this method ensures the manager stops tracking us and
	 * that reconnections don't get triggered for this.
	 *
	 * @api private.
	 */
	
	Socket.prototype.destroy = function () {
	  if (this.subs) {
	    // clean subscriptions to avoid reconnections
	    for (var i = 0; i < this.subs.length; i++) {
	      this.subs[i].destroy();
	    }
	    this.subs = null;
	  }
	
	  this.io.destroy(this);
	};
	
	/**
	 * Disconnects the socket manually.
	 *
	 * @return {Socket} self
	 * @api public
	 */
	
	Socket.prototype.close = Socket.prototype.disconnect = function () {
	  if (this.connected) {
	    debug('performing disconnect (%s)', this.nsp);
	    this.packet({ type: parser.DISCONNECT });
	  }
	
	  // remove socket from pool
	  this.destroy();
	
	  if (this.connected) {
	    // fire events
	    this.onclose('io client disconnect');
	  }
	  return this;
	};
	
	/**
	 * Sets the compress flag.
	 *
	 * @param {Boolean} if `true`, compresses the sending data
	 * @return {Socket} self
	 * @api public
	 */
	
	Socket.prototype.compress = function (compress) {
	  this.flags.compress = compress;
	  return this;
	};
	
	/**
	 * Sets the binary flag
	 *
	 * @param {Boolean} whether the emitted data contains binary
	 * @return {Socket} self
	 * @api public
	 */
	
	Socket.prototype.binary = function (binary) {
	  this.flags.binary = binary;
	  return this;
	};

/***/ }),
/* 37 */
/***/ (function(module, exports) {

	module.exports = toArray
	
	function toArray(list, index) {
	    var array = []
	
	    index = index || 0
	
	    for (var i = index || 0; i < list.length; i++) {
	        array[i - index] = list[i]
	    }
	
	    return array
	}


/***/ }),
/* 38 */
/***/ (function(module, exports) {

	"use strict";
	
	/**
	 * Module exports.
	 */
	
	module.exports = on;
	
	/**
	 * Helper for subscriptions.
	 *
	 * @param {Object|EventEmitter} obj with `Emitter` mixin or `EventEmitter`
	 * @param {String} event name
	 * @param {Function} callback
	 * @api public
	 */
	
	function on(obj, ev, fn) {
	  obj.on(ev, fn);
	  return {
	    destroy: function destroy() {
	      obj.removeListener(ev, fn);
	    }
	  };
	}

/***/ }),
/* 39 */
/***/ (function(module, exports) {

	/**
	 * Slice reference.
	 */
	
	var slice = [].slice;
	
	/**
	 * Bind `obj` to `fn`.
	 *
	 * @param {Object} obj
	 * @param {Function|String} fn or string
	 * @return {Function}
	 * @api public
	 */
	
	module.exports = function(obj, fn){
	  if ('string' == typeof fn) fn = obj[fn];
	  if ('function' != typeof fn) throw new Error('bind() requires a function');
	  var args = slice.call(arguments, 2);
	  return function(){
	    return fn.apply(obj, args.concat(slice.call(arguments)));
	  }
	};


/***/ }),
/* 40 */
/***/ (function(module, exports) {

	
	/**
	 * Expose `Backoff`.
	 */
	
	module.exports = Backoff;
	
	/**
	 * Initialize backoff timer with `opts`.
	 *
	 * - `min` initial timeout in milliseconds [100]
	 * - `max` max timeout [10000]
	 * - `jitter` [0]
	 * - `factor` [2]
	 *
	 * @param {Object} opts
	 * @api public
	 */
	
	function Backoff(opts) {
	  opts = opts || {};
	  this.ms = opts.min || 100;
	  this.max = opts.max || 10000;
	  this.factor = opts.factor || 2;
	  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
	  this.attempts = 0;
	}
	
	/**
	 * Return the backoff duration.
	 *
	 * @return {Number}
	 * @api public
	 */
	
	Backoff.prototype.duration = function(){
	  var ms = this.ms * Math.pow(this.factor, this.attempts++);
	  if (this.jitter) {
	    var rand =  Math.random();
	    var deviation = Math.floor(rand * this.jitter * ms);
	    ms = (Math.floor(rand * 10) & 1) == 0  ? ms - deviation : ms + deviation;
	  }
	  return Math.min(ms, this.max) | 0;
	};
	
	/**
	 * Reset the number of attempts.
	 *
	 * @api public
	 */
	
	Backoff.prototype.reset = function(){
	  this.attempts = 0;
	};
	
	/**
	 * Set the minimum duration
	 *
	 * @api public
	 */
	
	Backoff.prototype.setMin = function(min){
	  this.ms = min;
	};
	
	/**
	 * Set the maximum duration
	 *
	 * @api public
	 */
	
	Backoff.prototype.setMax = function(max){
	  this.max = max;
	};
	
	/**
	 * Set the jitter
	 *
	 * @api public
	 */
	
	Backoff.prototype.setJitter = function(jitter){
	  this.jitter = jitter;
	};
	


/***/ })
/******/ ])
});
;
//# sourceMappingURL=socket.io.dev.js.map</script><script type="text/javascript">var livedataSocketIOConnectOptions = { reconnection: true, reconnectionDelay: 1000, reconnectionDelayMax: 5000, reconnectionAttempts: 5, timeout: 20000 };</script><script type="text/javascript">/**
 * @copyright Cisco Systems Confidential
 *            Copyright (c) 2014-15 by Cisco Systems, Inc.
 *            All Rights Reserved.
 *            
 * @fileOverview The socket lib resides on the cbabu system to establish
 *     an socket connection with the socket io server. The idea is for
 *     the master frame to create a hidden IFRAME pointing to the socket
 *     lib HTML page, importing this JS.  Window.postMessage is used to communicate.
 *     This allows the socket connection with the socket io library to be
 *     established within third-party containers.
 * @name Socket Lib
 */

/** @namespace */
var cbabu = cbabu || {};

var livedataSocketIOConnectOptions = livedataSocketIOConnectOptions || {};

cbabu.cuic = cbabu.cuic || {};

cbabu.cuic.failoverRetryTimerInterval = 2000;

/************************************************************************************************************************
 * 
 * Socket object which actually contains the web socket connection object. The socket connection is created and events 
 * attached in this object.
 * 
 ************************************************************************************************************************/
cbabu.cuic.Socket = function (socketHost, ldHost, authorization, reportId) {

  /**
   * The actual socket connection to socket io
   */	
  this.socket = null;
  /**
   * The host:port where the socket io connection has to be established.
   */
  this.socketHost= socketHost;
  /**
   * The status of the connection. 
   *   true - connected
   *   false - disconnected
   */
  this.connected= false;
  
  this.retryCount = 0;
  
  
  this.maxRetryCount = (livedataSocketIOConnectOptions.reconnectionAttempts || 5);
  /**
   * TODO: Currently not being used, we might need to use this to differentiate between various failover or disconnection scenarios.
   */
  this.status = null;
  
  this.ldHost = ldHost;
  
  this.protocol = location.protocol.indexOf("https:") > -1 ? "wss://" : "ws://";
  
  /**
   * The socket server path to connect to the socket server
   */
  this.server = this.protocol + this.socketHost +"/";
  
  this.authorization = authorization;
  
  this.reportId = reportId;
  
  this.isGadget = window.gadgets?true:false;
  
  this.socketIOStatus = false;
  
  this.socketCertificateAccepted = "UNKNOWN";
  
  this._mb = new cbabu.cuic.MessageBridge();
	
};

cbabu.cuic.Socket.prototype = {
		
	emit: function(event,roominfo) {
      if (typeof this.socket==='undefined') {
    	 _slog("SocketLib-emit():-the socket has not be initialized properly");
         return;	
      }
	  this.socket.emit(event,roominfo);	
	},

	/**
	 * gets the present status of connection to socket server.
	 */	
    isConnected: function() {
    	return this.connected;
    },
    
    
    /**
	 * gets the present status of connection to socket server.
	 */	
    getRetryCount: function() {
    		return this.retryCount;
    },
    
    setRetryCount: function(count) {
    	
    	this.retryCount = count;
    	
    	if(false == this.connected && this.retryCount >= this.maxRetryCount) {
    		_slog("Socket.setRetryConnect - connectNext event triggered");
    		
    		setTimeout(function(){$.event.trigger({type: "connectNext"})},cbabu.cuic.failoverRetryTimerInterval);
    	}
    },
    
    /**
     * returns the current status of the connection, mainly useful in connect failure scenarios.
     */
    getStatus: function() {
    		return this.status;
    },
    
    /**
     * Allows to close the connection to socket server.
     */
    closeConnection: function() {
        if(this.socket) {
        	this._mb.sendMessage(this._mb.TYPES.STATUS, this._mb.STATUS["UNAVAILABLE"]);
        	this.socket.close();
        }
        this.setRetryCount(0);
    },
    /**
     * Allows to set Token for current token.
     */
    setNewToken: function(token) {
       this.token = token;
    },
    
    /**
     * Establishes a connection to socket IO server and registers the callbacks required to be handled.
     */
	connect : function() {
		//In Gadget scenario we need to make a call to get the auth token directly from the ld service.
		
			
		      
	          
	          
			
			//var pwd = btoa('CUIC\\cuicadmin:cuicadmin');//this.authorization;
            var pwd = this.authorization;
			  $.ajax({
				  cache: false,
				  url : "/cuic/rest/datasources/" + this.reportId + "?idkind=REPORT&statusrequired=true",
				   beforeSend: function(xhr) {
				       // xhr.setRequestHeader('Authorization', 'Basic '+ pwd);
				    },
				  success : $.proxy( this.dsResponseSuccessCallBack,this),
				  error : $.proxy(this.dsResponseErrorCallBack,this)
			  });			
		
	},
    
	dsResponseErrorCallBack : function (response) {
		_slog("SocketLib-dsResponseErrorCallBack():-Datasource REST Api failed with respone:" + JSON.stringify(response));
		this.connected = false;
		this._mb.sendMessage(this._mb.TYPES.STATUS, this._mb.STATUS["UNAVAILABLE"]);
		this.setRetryCount(this.maxRetryCount);
	},
	
	socketConnectCallBack : function () {
		if(this.connected == false) {
		  this.socketCertificateAccepted = true;	
		  this.socket.on('message',$.proxy(this.subscribeMessageCallBack,this));	
		  this._mb.sendMessage(this._mb.TYPES.STATUS, this._mb.STATUS["CONNECTED"]);
		}
		
		this.connected = true;
		this.status = "CONNECTED";
		this.setRetryCount(0);
	},
	
	socketDisconnectCallBack: function(data) {
		_slog("got disconnected::"+data);
		this.status = "DISCONNECTED";
		this._mb.sendMessage(this._mb.TYPES.STATUS, this._mb.STATUS["UNAVAILABLE"]);
		this.connected = false;
	},

	socketSubscribedCallBack: function(data) {
		_slog("got subscribed::"+data);
		this._mb.sendMessage(this._mb.TYPES.SUBSCRIBED, data);
	},

	socketSubscribedErrorCallBack: function(data) {
		_slog("got subscribed error::"+data);
		this._mb.sendMessage(this._mb.TYPES.SUBSCRIBE_ERROR, data);
	},
	
	socketUnsubscribedCallBack: function(data) {
        _slog("got unsubscribed::"+data);
		this._mb.sendMessage(this._mb.TYPES.UNSUBSCRIBED, data);
    },

	socketUnsubscribedErrorCallBack: function(data) {
        _slog("got unsubscribed::"+data);
        this._mb.sendMessage(this._mb.TYPES.UNSUBSCRIBED_ERROR, data);
    },
    
	socketConnectErrorCallBack : function(data) {
		//callback when there is a connection error
		_slog("SocketLib-socketConnectErrorCallBack():"+data);
		this.connected= false;
	},
	
	socketReconnectErrorCallBack : function(data) {
		//callback when there is a connection error
		_slog("SocketLib-socketReconnectErrorCallBack():"+data);
		this.connected= false;
	},
	
	socketReconnectAttemptCallBack : function(data) {
		//callback when there is a connection error
		_slog("SocketLib-socketReconnectAttemptCallBack():"+data);
		this._mb.sendMessage(this._mb.TYPES.STATUS, this._mb.STATUS["UNAVAILABLE"]);
		this.setRetryCount(data);
	},
	
	socketReconnectFailedCallBack : function(data) {
		//callback when there is a connection error
		_slog("SocketLib-socketReconnectFailedCallBack():"+data);
		this.connected= false;
		if(data && data.message &&data.message.indexOf("xhr poll error") > -1) {
			this.status = "CERTIFICATE_EXCEPTION";
		}
	},
	
    subscribeMessageCallBack : function(data) {
		data = JSON.stringify(data);
		_slog("Message received on socket::"+data);
		this._mb.sendEvent("cbabu.cuic.messageNode",data);
	},

	
	dsResponseSuccessCallBack : function(response) {
        var socketHost = this.socketHost;
		var ldHost = this.ldHost["HOST"];
		
		if(!ldHost) {
			_slog("SocketLib-dsResponseSuccessCallBack():-Invalid LD host(IP:port)");
			this.connected = false;
			this.setRetryCount(2);
			return;
		}
		
		if(window.location.protocol.indexOf("http:") > -1) {
			var spArray = ldHost.split(":");
			ldHost = spArray[0] + ":" +(parseInt(spArray[1]) );
			
			spArray = socketHost.split(":");
			socketHost = spArray[0] + ":" +(parseInt(spArray[1]) );
			
		}
		var token = null;
        try {
        	token = response.connectionStatus[ldHost] ? JSON.parse(response.connectionStatus[ldHost]).token : null;
        	this.socketIOStatus = response.connectionStatus[socketHost] == "true"?true:false;
        } catch(e) {
        	token = null;
        }		
		
		if(!token || this.socketIOStatus == false) {
			_slog("SocketLib-dsResponseSuccessCallBack():-Invalid token from LD service");
			this.socketCertificateAccepted = "UNKNOWN";
			this.connected = false;
			this.setRetryCount(this.maxRetryCount);
			return;
		}
		
		
        this.checkSocketIOStatus().done($.proxy(function() {
        	if(false == this.socketCertificateAccepted || "UNKNOWN" == this.socketCertificateAccepted) {
    			this.connected = false;
    			this.setRetryCount(this.maxRetryCount);
    			if(window.gadgets) {
    				this._mb.sendMessage(this._mb.TYPES.STATUS, this._mb.STATUS["UNAVAILABLE"]);
    			}
    			return;
        	}
    		return this.connectSocketAndAttachCallBacks(token);    	
        },this));	
	},
	
	checkSocketIOStatus:function() {
		
		//make  a call to security page id it is accessible from client as well.
		var dfd = $.Deferred();
		
		var protocol = window.location.protocol.indexOf("http:") > -1 ? 'http':'https';
		
		if(false) {
			
			var xdr = new XDomainRequest();
			var reqComplete = false; 
			xdr.open('GET',protocol + "://" + this.socketHost + "/security?"+new Date().getTime());
			
			xdr.onload = $.proxy(function(response, status, xhr) {
				this.socketCertificateAccepted = true;
				reqComplete = true;
				dfd.resolve();
			},this);
			
			xdr.onerror = $.proxy(function() {
				this.socketCertificateAccepted = false;
				reqComplete = true;
				dfd.resolve();
			},this);
			
			//timeout is not working on xdr
			setTimeout(function(){
				if(false == reqComplete) {
					xdr.abort();
					dfd.resolve();
				}
			},3000);
			
			xdr.send(null);
			
		} else {
			$.ajax({
				cache: false,
				type: 'GET',
				crossDomain: true,
				timeout: 3000, 
				url : protocol + "://" + this.socketHost + "/security",
				success : $.proxy(function(response, status, xhr) {
					this.socketCertificateAccepted = true;
					dfd.resolve();
				},this), 
				error : $.proxy(function() {
					this.socketCertificateAccepted = false;
					dfd.resolve();
				},this)
			});
			
		}
		
		
		return dfd.promise();
		
	},
	
	connectSocketAndAttachCallBacks:function(token){
		this.socket = io.connect(this.server, {
			'force new connection': true,
			'reconnection':livedataSocketIOConnectOptions.reconnection || true,
			'reconnectionDelay':livedataSocketIOConnectOptions.reconnectionDelay || 2000,
			'reconnectionDelayMax':livedataSocketIOConnectOptions.reconnectionDelayMax || 10000,
			'reconnectionAttempts':livedataSocketIOConnectOptions.reconnectionAttempts || 5,
			'transports': ['websocket'],
			'randomizationFactor':0.5,
			'transportOptions': {'websocket':{ 'protocols':['token',  token]}}	
		});

		this.socket.on('connect', $.proxy( this.socketConnectCallBack,this));

		this.socket.on('connect_error', $.proxy( this.socketConnectErrorCallBack,this));
		
		this.socket.on('reconnect_error', $.proxy(this.socketReconnectErrorCallBack,this));
		
		this.socket.on('reconnect_failed', $.proxy(this.socketReconnectFailedCallBack,this));
		
		this.socket.on('reconnect_attempt', $.proxy( this.socketReconnectAttemptCallBack,this));
		
		this.socket.on('disconnect',$.proxy(this.socketDisconnectCallBack,this));

		this.socket.on('subscribed',$.proxy(this.socketSubscribedCallBack,this));

		this.socket.on('subscribe_error',$.proxy(this.socketSubscribedErrorCallBack,this));
		this.socket.on('unsubscribed',$.proxy(this.socketUnsubscribedCallBack, this));
		this.socket.on('unsubscribe_error',$.proxy(this.socketUnsubscribedErrorCallBack, this));
		
		return this.socket;
	}
	
};





/**************************************************************************************************************************
 * 
 * Socket list is the container which has the array of host:port (socket io service) combinations available for connection.
 * 
 **************************************************************************************************************************/

cbabu.cuic.SocketList =  function (socketHostArray, ldHostArray, authorization, viewId) {
  this.socketHostArray = socketHostArray;
  this.socketList=[];
  this.index=-1;
  //Now socket host array will come with token and gadget info need to pass the same during socket creation.
  for(var i=0;i<socketHostArray.length;i++) {
	  this.addSocket(socketHostArray[i], ldHostArray[i], authorization, viewId);		
  }
};

cbabu.cuic.SocketList.prototype = {

	/**
	 * Add a new socket host (ip:port) to the socket list which is having a socket io service running and available for connection. 
	 */	
	addSocket: function(socketHost, ldHost, authorization, viewId) {
		this.socketList.push(new cbabu.cuic.Socket(socketHost, ldHost, authorization, viewId));
	},
	
	/**
	 * This method returns the current active socket connection, where connection was succesful or trying for connection.
	 */
	getSocket : function() {
		
		if (this.index==-1) {
			return null; // No sockets have been defined.
		}

		return this.socketList[this.index];             
	},
	/**
	 * This method returns the next socket in the socket list which can be used to establish a connection to socket server.
	 */
	getNextSocket : function () {
 
	   this.index++;
       if (this.index >= this.socketList.length) {
    	   this.index = 0;
    	   var acceptCalled = false;
    		   for(var i =0;i<this.socketList.length;i++) {
    			   if(acceptCalled == false && this.socketList[i].socketCertificateAccepted == false) {
    				   //launch certificates only in case of https protocol
    				   if(window.location.protocol.indexOf("https:") > -1) {
    					   window.top._tunnelLoadingTimeoutCallback();    					   
    				   }
    				   acceptCalled = true;
    			   }
    			   this.socketList[i].socketCertificateAccepted = "UNKNOWN";
    	   }
       }
	   return this.socketList[this.index];
	},
    
	size: function(){
      return this.socketList.length;
    }

};



/*************************************************************************************************************
 * 
 * Socket Proxy makes possible connection to the socket service and also gets the details of current socket.
 * This Object basically hides the actual socket connection and exposes methods which are required only. 
 * 
 *************************************************************************************************************/


cbabu.cuic.SocketProxy = function(socketHostArray, ldHostArray, authorization, viewId) {
	this.socketList = new cbabu.cuic.SocketList(socketHostArray, ldHostArray, authorization, viewId);
};

  
cbabu.cuic.SocketProxy.prototype = {
	
	getSocket: function() {
		return this.socketList.getSocket();
	},
	
	connect: function() {
		$(document).on( "connectNext", $.proxy(this.connectNextAvailableHost,this));
		_slog("SocketProxy.connect() - connectNext event triggered");
		$.event.trigger({type: "connectNext"});
	},

    connectNextAvailableHost: function() {
    	_slog("SocketProxy.connectAvailableHost() - Inside socketProxy.connectNextAvailableHost");
      //existing socket connection has to be closed before connecting to other side.
      var socket = this.socketList.getSocket();
      
      if(socket) {
    	  	socket.closeConnection();
      }
      
      return this.socketList.getNextSocket().connect();
    },
    
    size: function(){
    		return this.socketList.size();
    }
};

function _slog(message)
{
	if(typeof console != 'undefined')
	{
		console.log(message);
	}
}
</script><script type="text/javascript">/**
 * @fileOverview The Socket Tunnel resides on the cbabu system to establish
 *     an Socket connection with the Socket.IO server. The idea is for
 *     the Master Tunnel to create a Socket Tunnel. 
 * 
 * @name SocketTunnel
 * @requires socket.io.js, cbabu.Utilities
 */

/** @namespace */
var cbabu = cbabu || {};

var livedataSocketIOConnectOptions = livedataSocketIOConnectOptions || {};

cbabu.cuic = cbabu.cuic || {};

/**
 * @class
 * Create a Socket connection (using socket lib) with the Socket.IO server to
 * receive events. Events are delivered through the communication tunnel with
 * the parent Master Tunnel. After the creation of the SocketTunnel object, the init
 * must be called to start listening for messages from the parent frame. Socket
 * connection establishment starts when the parent sends the credentials
 * (via master tunnel).
 * @constructor
 */
cbabu.cuic.SocketTunnel = function () {

    var

    /**
     * The ID of the user logged into notification server.
     * @private
     */
    _ldHostArray,
   
    /**
     * The array contains list of available socket connections 
     * @private
     */
    _socketHostArray,
    
    /**
     * The password of the user logged into notification server.
     * @private
     */
    _password,

    /**
     * ViewId of the parent frame, required to get the token for LD service
     * @private
     */
    _viewId,
    
	/**
	 * the socket proxy is a wrapper which provides methods available for connecting
	 * to socket server.
	 * @private
	 */
    _socketProxy = null,
    
        
    _mb = new cbabu.cuic.MessageBridge(),
    
 
    /**
     * Utility to clean everything up upon unloading
     * @private
     */
	_unload = function () {
	    //Tell clients that we are unloading the page
	    _mb.sendMessage(_mb.TYPES.STATUS, _mb.STATUS["UNLOADING"]);
	    //TODO:-need to clean up connection and subscription as well.
	},
	
    /**
     * Establish socket connection using socket.io library.
     * @private
     */
    _connect = function () {
        _socketProxy.connect();
     },
     
     _clearTimers = function(){
	    	if(_disconnectTimer) {
	    		clearTimeout(_disconnectTimer);
	    		_disconnectTimer = null;
	    	}
	    	
	    	if(conectCheckInterval) {
				clearInterval(conectCheckInterval);
				conectCheckInterval=null;
			}

     },  
	
   
	_log = function (msg, e) {
	    if (window.console) {
	        if (e) {
	            console.log(msg, e);
	        } else {
	            console.log(msg);
	        }
	    }
	},

    /**
     * Utility for sending a subscription request to the XMPP notification server.
     * This is likely invoked by a _mb.TYPES.SUBSCRIBE message and responds with the same.
     * @param {String} node
     *     The path of the node of interest to be subscribed
     * @private
     */
    _subscribe = function (roomInfo) {
		var socket = _socketProxy.getSocket();
		if(socket) {
			socket.emit('subscribe', roomInfo);
		}
    },

    /**
     * Utility for sending an unsubscribe request to the XMPP notification server.
     * This is likely invoked by a _mb.TYPES.UNSUBSCRIBE message and responds with the same.
     * @param {String} node
     *     The path of the node of interest to be unsubscribed
     * @private
     */
    _unsubscribe = function (roomInfo) {
		var socket = _socketProxy.getSocket();
		if(socket) {
			socket.emit('unsubscribe', roomInfo);
		}
    },
	
    /**
     * Handler for messages delivered by window.postMessage. Listens for
     * credentials to be passed by parent frame in order to establish a BOSH
     * connection.
     * @param {Object} e
     *     The message object as provided by the window.postMessage feature.
     * @private
     */
    _messageHandler = function (e) {
        var

        //Extract the message type and message data. The expected format is
        //"type|data" where type is a number represented by the TYPES object.
        delimPos = e.indexOf("|"),
        type = Number(e.substr(0, delimPos)),
        data =  e.substr(delimPos + 1);

        //Since the ID and password is being delivered by the parent frame
        //separately, store the credentials until both fields come in
        //before attempting to connect.

		switch (type) {
        case _mb.TYPES.LDHOSTARRAY:
            _ldHostArray = JSON.parse(data);
            break;
        case _mb.TYPES.SOCKETHOSTARRAY:
            _socketHostArray = JSON.parse(data);
            break;   
        case _mb.TYPES.PASSWORD:
            _password = data;
            break; 
        case _mb.TYPES.SUBSCRIBE:
            _subscribe(data);
            return;
        case _mb.TYPES.UNSUBSCRIBE:
            _unsubscribe(data);
            return;
        case _mb.TYPES.VIEW_ID:
        		_viewId = data;
            break;   
        }

        //Ensure that ID, domain and password credentials have been received
        //before attempting to establish a Socket connection.
        if (_ldHostArray !== undefined && _password !== undefined && _socketHostArray !== undefined && _viewId !== undefined) {
        	//before connecting check if we can load the redirect url of socket io,
        	//first try for sidea
        		_socketProxy = new cbabu.cuic.SocketProxy(_socketHostArray, _ldHostArray, _password, _viewId);
        		_connect();
        		_password = undefined;
        }
    };
    
 
    /**
     * Initiate the message listener to wait for actions from the parent frame.
     */
    this.init = function (mtTunnel) {
    	
        _mb.sendMessage(_mb.TYPES.STATUS, _mb.STATUS["LOADED"]);
    };
    
    this.messageHandler= function (message) {
        _messageHandler(message);
    };
    
    this.getSocketProxy= function () {
        return _socketProxy;
    };
    
    
    this.getSocketHostForCertificateAcceptance = function() {
        var acceptCertificateList = [];	
    	var socketList = _socketProxy.socketList;
    	
    	if(socketList && socketList.socketList) {
    		socketList = socketList.socketList;
    		for(var i=0;i<socketList.length;i++) {
    			
    			if(socketList[i].socketCertificateAccepted == false) {
    				acceptCertificateList.push(socketList[i].socketHost);	
    			}
    		}
    	}
    	
    	return acceptCertificateList;
    	
    };

 };
 
 
 cbabu.cuic.MessageBridge = function () {
	 
	 
	    var _masterTunnel = cbabu.cuic.clientservices.ClientServices.getTunnel();
	    
	    /**
	     * The different types of messages that could be sent to the parent.
	     * The types here should be understood by the parent and used to
	     * identify how the message is formatted.
	     * @private
	     */
	    this.TYPES = {
	        EVENT: 0,
	        LDHOSTARRAY: 1,
	        PASSWORD: 2,
	        SOCKETHOST_AVAILABLE:3,
	        STATUS: 4,
	        SOCKETHOSTARRAY: 5,
	        SOCKETHOST_UNAVAILABLE:6,
	        SUBSCRIBE: 7,
	        UNSUBSCRIBE: 8,
	        VIEW_ID: 9,
	        TOKEN:10,
            SUBSCRIBED:11,
            SUBSCRIBE_ERROR:12,
            UNSUBSCRIBED:13,
            UNSUBSCRIBE_ERROR:14
	    };

	    /**
	     * Describes the states of the Socket connection.
	     * @private
	     */
	    this.STATUS = {
	         "LOADED":"loaded",
	         "CONNECTING":"connecting",
	         "CONNECTED":"connected",
	         "UNLOADING":"unloading",
	         "AVAILABLE":"available",
	         "RECONNECTED":"reconnected",
	         "UNAVAILABLE":"unavailable"
	     };
	        

	    this.init = function (mtTunnel) {
	    	_masterTunnel = mtTunnel;
	    };
	    

	    /**
	     * Communicates with the parent frame (should be the Master gadget) by
	     * sending a message formatted as follows "type|message".
	     * @param {Number} type
	     *     The category type of the message.
	     * @param {String} message
	     *     The message to be sent to the parent frame.
	     */
	    this.sendMessage = function (type, message) {
	        message = type + "|" + message;
	        _masterTunnel.messageHandler(message);
	    };

	    /**
	     * Common utility for sending event notifications through the tunnel.
	     * @param {String} node
	     *     The node that the event was published on
	     * @param {String} payload
	     *     The payload of the notification
	     */
		this.sendEvent = function (node, payload) {
			//Since the node path matches the REST URL, URI encoding/decoding should keep it safe.
			node = encodeURI(node ? node : "");
			payload = (payload ? payload : "");
			
			this.sendMessage(this.TYPES.EVENT, node + payload);
		};
 };


</script><script type="text/javascript">/**
 * @fileOverview A collection of conversion utilities.
 * Last modified 07-06-2011, Cisco Systems
 *
 * @name Utilities.Converter
 */

/** @namespace */
(function (factory) {
    "use strict";

    // Define as an AMD module if possible
    if ( typeof define === 'function' && define.amd )
    {
        define( [], factory );
    }
    /* Define using browser globals otherwise
     * Prevent multiple instantiations if the script is loaded twice
     */
    else
    {
        factory();
    } 
}(function () {
    window.cbabu = window.cbabu || {};
    window.cbabu.cuic = window.cbabu.cuic || {};

    /**
     * @class
     * Contains a collection of utility functions.
     */
    window.cbabu.cuic.Converter = (function () {
        /** @scope cbabu.cuic.clientservices.Utilities */
        return {
            /*  This work is licensed under Creative Commons GNU LGPL License.

                License: http://creativecommons.org/licenses/LGPL/2.1/
               Version: 0.9
                Author:  Stefan Goessner/2006
                Web:     http://goessner.net/ 
            */
            xml2json: function (xml, tab) {
                var X = {
                    toObj: function (xml) {
                        var o = {};
                        if (xml.nodeType === 1) {
                            // element node ..
                            if (xml.attributes.length)
                            // element with attributes  ..
                            for (var i = 0; i < xml.attributes.length; i++)
                            o["@" + xml.attributes[i].nodeName] = (xml.attributes[i].nodeValue || "").toString();
                            if (xml.firstChild) {
                                // element has child nodes ..
                                var textChild = 0,
                                cdataChild = 0,
                                hasElementChild = false;
                                for (var n = xml.firstChild; n; n = n.nextSibling) {
                                    if (n.nodeType == 1) hasElementChild = true;
                                    else if (n.nodeType == 3 && n.nodeValue.match(/[^ \f\n\r\t\v]/)) textChild++;
                                    // non-whitespace text
                                    else if (n.nodeType == 4) cdataChild++;
                                    // cdata section node
                                }
                                if (hasElementChild) {
                                    if (textChild < 2 && cdataChild < 2) {
                                        // structured element with evtl. a single text or/and cdata node ..
                                        X.removeWhite(xml);
                                        for (var n = xml.firstChild; n; n = n.nextSibling) {
                                            if (n.nodeType == 3)
                                            // text node
                                            o["#text"] = X.escape(n.nodeValue);
                                            else if (n.nodeType == 4)
                                            // cdata node
                                            o["#cdata"] = X.escape(n.nodeValue);
                                            else if (o[n.nodeName]) {
                                                // multiple occurence of element ..
                                                if (o[n.nodeName] instanceof Array)
                                                o[n.nodeName][o[n.nodeName].length] = X.toObj(n);
                                                else
                                                o[n.nodeName] = [o[n.nodeName], X.toObj(n)];
                                            }
                                            else
                                            // first occurence of element..
                                            o[n.nodeName] = X.toObj(n);
                                        }
                                    }
                                    else {
                                        // mixed content
                                        if (!xml.attributes.length)
                                        o = X.escape(X.innerXml(xml));
                                        else
                                        o["#text"] = X.escape(X.innerXml(xml));
                                    }
                                }
                                else if (textChild) {
                                    // pure text
                                    if (!xml.attributes.length)
                                    o = X.escape(X.innerXml(xml));
                                    else
                                    o["#text"] = X.escape(X.innerXml(xml));
                                }
                                else if (cdataChild) {
                                    // cdata
                                    if (cdataChild > 1)
                                    o = X.escape(X.innerXml(xml));
                                    else
                                    for (var n = xml.firstChild; n; n = n.nextSibling)
                                    o["#cdata"] = X.escape(n.nodeValue);
                                }
                            }
                            if (!xml.attributes.length && !xml.firstChild) o = null;
                        }
                        else if (xml.nodeType == 9) {
                            // document.node
                            o = X.toObj(xml.documentElement);
                        }
                        else
                            throw ("unhandled node type: " + xml.nodeType);
                        return o;
                    },
                    toJson: function(o, name, ind) {
                        var json = name ? ("\"" + name + "\"") : "";
                        if (o instanceof Array) {
                            for (var i = 0, n = o.length; i < n; i++)
                            o[i] = X.toJson(o[i], "", ind + "\t");
                            json += (name ? ":[": "[") + (o.length > 1 ? ("\n" + ind + "\t" + o.join(",\n" + ind + "\t") + "\n" + ind) : o.join("")) + "]";
                        }
                        else if (o == null)
                        json += (name && ":") + "null";
                        else if (typeof(o) == "object") {
                            var arr = [];
                            for (var m in o)
                            arr[arr.length] = X.toJson(o[m], m, ind + "\t");
                            json += (name ? ":{": "{") + (arr.length > 1 ? ("\n" + ind + "\t" + arr.join(",\n" + ind + "\t") + "\n" + ind) : arr.join("")) + "}";
                        }
                        else if (typeof(o) == "string")
                        json += (name && ":") + "\"" + o.toString() + "\"";
                        else
                        json += (name && ":") + o.toString();
                        return json;
                    },
                    innerXml: function(node) {
                        var s = "";
                        if ("innerHTML" in node)
                        s = node.innerHTML;
                        else {
                            var asXml = function(n) {
                                var s = "";
                                if (n.nodeType == 1) {
                                    s += "<" + n.nodeName;
                                    for (var i = 0; i < n.attributes.length; i++)
                                    s += " " + n.attributes[i].nodeName + "=\"" + (n.attributes[i].nodeValue || "").toString() + "\"";
                                    if (n.firstChild) {
                                        s += ">";
                                        for (var c = n.firstChild; c; c = c.nextSibling)
                                        s += asXml(c);
                                        s += "</" + n.nodeName + ">";
                                    }
                                    else
                                    s += "/>";
                                }
                                else if (n.nodeType == 3)
                                s += n.nodeValue;
                                else if (n.nodeType == 4)
                                s += "<![CDATA[" + n.nodeValue + "]]>";
                                return s;
                            };
                            for (var c = node.firstChild; c; c = c.nextSibling)
                            s += asXml(c);
                        }
                        return s;
                    },
                    escape: function(txt) {
                        return txt.replace(/[\\]/g, "\\\\")
                        .replace(/[\"]/g, '\\"')
                        .replace(/[\n]/g, '\\n')
                        .replace(/[\r]/g, '\\r');
                    },
                    removeWhite: function(e) {
                        e.normalize();
                        for (var n = e.firstChild; n;) {
                            if (n.nodeType == 3) {
                                // text node
                                if (!n.nodeValue.match(/[^ \f\n\r\t\v]/)) {
                                    // pure whitespace text node
                                    var nxt = n.nextSibling;
                                    e.removeChild(n);
                                    n = nxt;
                                }
                                else
                                n = n.nextSibling;
                            }
                            else if (n.nodeType == 1) {
                                // element node
                                X.removeWhite(n);
                                n = n.nextSibling;
                            }
                            else
                            // any other node
                            n = n.nextSibling;
                        }
                        return e;
                    }
                };
                if (xml.nodeType == 9)
                // document node
                xml = xml.documentElement;
                var json = X.toJson(X.toObj(X.removeWhite(xml)), xml.nodeName, "\t");
                return "{\n" + tab + (tab ? json.replace(/\t/g, tab) : json.replace(/\t|\n/g, "")) + "\n}";
            },
            
            /*  This work is licensed under Creative Commons GNU LGPL License.

                License: http://creativecommons.org/licenses/LGPL/2.1/
               Version: 0.9
                Author:  Stefan Goessner/2006
                Web:     http://goessner.net/ 
            */
            json2xml: function(o, tab) {
                var toXml = function(v, name, ind) {
                    var xml = "";
                    if (v instanceof Array) {
                        for (var i = 0, n = v.length; i < n; i++)
                        xml += ind + toXml(v[i], name, ind + "\t") + "\n";
                    }
                    else if (typeof(v) == "object") {
                        var hasChild = false;
                        xml += ind + "<" + name;
                        for (var m in v) {
                            if (m.charAt(0) == "@")
                            xml += " " + m.substr(1) + "=\"" + v[m].toString() + "\"";
                            else
                            hasChild = true;
                        }
                        xml += hasChild ? ">": "/>";
                        if (hasChild) {
                            for (var m in v) {
                                if (m == "#text")
                                xml += v[m];
                                else if (m == "#cdata")
                                xml += "<![CDATA[" + v[m] + "]]>";
                                else if (m.charAt(0) != "@")
                                xml += toXml(v[m], m, ind + "\t");
                            }
                            xml += (xml.charAt(xml.length - 1) == "\n" ? ind: "") + "</" + name + ">";
                        }
                    }
                    else {
                        xml += ind + "<" + name + ">" + v.toString() + "</" + name + ">";
                    }
                    return xml;
                },
                xml = "";
                for (var m in o)
                xml += toXml(o[m], m, "");
                return tab ? xml.replace(/\t/g, tab) : xml.replace(/\t|\n/g, "");
            }
        };
    })();
}));
</script><script type="text/javascript">/*!
Math.uuid.js (v1.4)
http://www.broofa.com
mailto:robert@broofa.com

Copyright (c) 2010 Robert Kieffer
Dual licensed under the MIT and GPL licenses.
*/

/*
 * Generate a random uuid.
 *
 * USAGE: Math.uuid(length, radix)
 *   length - the desired number of characters
 *   radix  - the number of allowable values for each character.
 *
 * EXAMPLES:
 *   // No arguments  - returns RFC4122, version 4 ID
 *   >>> Math.uuid()
 *   "92329D39-6F5C-4520-ABFC-AAB64544E172"
 *
 *   // One argument - returns ID of the specified length
 *   >>> Math.uuid(15)     // 15 character ID (default base=62)
 *   "VcydxgltxrVZSTV"
 *
 *   // Two arguments - returns ID of the specified length, and radix. (Radix must be <= 62)
 *   >>> Math.uuid(8, 2)  // 8 character ID (base=2)
 *   "01001010"
 *   >>> Math.uuid(8, 10) // 8 character ID (base=10)
 *   "47473046"
 *   >>> Math.uuid(8, 16) // 8 character ID (base=16)
 *   "098F4D35"
 */
(function (factory) {
    "use strict";

    // Define as an AMD module if possible
    if ( typeof define === 'function' && define.amd )
    {
        define( [], factory );
    }
    /* Define using browser globals otherwise
     * Prevent multiple instantiations if the script is loaded twice
     */
    else
    {
        factory();
    } 
}(function () {
    (function() {
        // Private array of chars to use
        var CHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split('');

        Math.uuid = function (len, radix) {
          var chars = CHARS, uuid = [], i;
          radix = radix || chars.length;

          if (len) {
            // Compact form
            for (i = 0; i < len; i++) uuid[i] = chars[0 | Math.random()*radix];
          } else {
            // rfc4122, version 4 form
            var r;

            // rfc4122 requires these characters
            uuid[8] = uuid[13] = uuid[18] = uuid[23] = '-';
            uuid[14] = '4';

            // Fill in random data.  At i==19 set the high bits of clock sequence as
            // per rfc4122, sec. 4.1.5
            for (i = 0; i < 36; i++) {
              if (!uuid[i]) {
                r = 0 | Math.random()*16;
                uuid[i] = chars[(i == 19) ? (r & 0x3) | 0x8 : r];
              }
            }
          }

          return uuid.join('');
        };

        // A more performant, but slightly bulkier, RFC4122v4 solution.  We boost performance
        // by minimizing calls to random()
        Math.uuidFast = function() {
          var chars = CHARS, uuid = new Array(36), rnd=0, r;
          for (var i = 0; i < 36; i++) {
            if (i==8 || i==13 ||  i==18 || i==23) {
              uuid[i] = '-';
            } else if (i==14) {
              uuid[i] = '4';
            } else {
              if (rnd <= 0x02) rnd = 0x2000000 + (Math.random()*0x1000000)|0;
              r = rnd & 0xf;
              rnd = rnd >> 4;
              uuid[i] = chars[(i == 19) ? (r & 0x3) | 0x8 : r];
            }
          }
          return uuid.join('');
        };

        // A more compact, but less performant, RFC4122v4 solution:
        Math.uuidCompact = function() {
          return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
            var r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);
            return v.toString(16);
          });
        };
      })();
}));
</script><script type="text/javascript">/**
 * The following comment prevents JSLint errors concerning undefined global variables.
 * It tells JSLint that these identifiers are defined elsewhere.
 */
/*jslint bitwise:true, browser:true, nomen:true, regexp:true, sloppy:true, white:true, plusplus: true, unparam: true */

/** The following comment is to prevent jslint errors about 
 * using variables before they are defined.
 */
/*global $, _prefs,_uiMsg,ciscowidgets,dojo,cbabu,gadgets,hostUrl, console, Handlebars */

/**
 * @fileOverview A collection of utility functions.
 *
 * @name Utilities
 * @requires cbabu.cuic.Converter
 */

/** @namespace */
// Add Utilities to the cbabu.cuic.utilities namespace
window.cbabu = window.cbabu || {};
window.cbabu.cuic = window.cbabu.cuic || {};
window.cbabu.cuic.utilities = window.cbabu.cuic.utilities || {};

(function (factory) {
    "use strict";

    // Define as an AMD module if possible
    if ( typeof define === 'function' && define.amd )
    {
        define( ["../../thirdparty/util/converter",
                 "iso8601",
                 "Math.uuid"], factory );
    }
    /* Define using browser globals otherwise
     * Prevent multiple instantiations if the script is loaded twice
     */
    else
    {
        cbabu.cuic.utilities.Utilities = factory(cbabu.cuic.Converter);
    }
}(function (Converter) {
    var Utilities = {

        /**
         * Retrieves the specified item from window.localStorage
         * @param {String} key
         *     The key of the item to retrieve
         * @returns {String}
         *     The string with the value of the retrieved item; returns
         *     what the browser would return if not found (typically null or undefined)
         *     Returns false if window.localStorage feature is not even found.
         */
        getDOMStoreItem: function (key) {
            var store = window.localStorage;
            if (store) {
                return store.getItem(key);
            }
        },

        /**
         * Sets an item into window.localStorage
         * @param {String} key
         *     The key for the item to set
         * @param {String} value
         *     The value to set
         * @returns {boolean}
         *     True if successful, false if window.localStorage is
         *     not even found.
         */
        setDOMStoreItem: function (key, value) {
            var store = window.localStorage;
            if (store) {
                store.setItem(key, value);
                return true;
            }
            return false;
        },

        getStatusObj: function(type,detail) {
                var map = {
				'InProcess': ['ReportUnsubscribing','ReportLoading','FailoverStarted'],
                                'Processed': ['ReportUnsubscribed','ReportLoaded','ReportError','FailoverCompleted']
                          };

                if(map[type].indexOf(detail) !== -1){
                        return {'type':type,'detail':detail};
                } else {
                        return {};
                }
        },

        getRoomInfo: function(nodeIds) {
          var roomInfo = '';
              if (nodeIds) {
                    for (var roomPrefix in nodeIds) {
                            var ids = nodeIds[roomPrefix];
                            if (roomInfo != '')
                                    roomInfo += '&';
                                    roomInfo = roomInfo + roomPrefix + '=' + ids.join(',');
                    }
                  }
            return roomInfo;
         },

         /**
          * ex:- the schema supported for roomStr is resourceId1 = 5001,5002 & resourceId2 = 5004,5006
          * the schema is realised after looking at getRoomInfo which builds roomStr
          * the result roomMap = [resourceId1=5001,resourceId1=5002,resourceId2=5004,resourceId2=5006]
          *
          **/
         getIndividualRoomsSubscribed: function(roomStr) {

            var res = [], roomMap = [];
            res = roomStr.split('&');

            for (var i=0; i < res.length; i++) {
                var res2 = res[i].split('=');
                var keyPrefix = res2[0] + '=';
                var res3 = res2[1].split(',');

                for(var j = 0; j < res3.length; j++) {
                    roomMap.push(keyPrefix + res3[j]);
                }

            }
            return roomMap;
         },         

         getFilterKeyObject: function(permalink) {
          var filterParamJson = this._buildFilterParamJson(permalink);
          var str = filterParamJson.filterParam;
          var startIndex = str.indexOf("=");
          var substring = str.substring(startIndex+1, str.length);
          var tokens = substring.split(":", 2);
          return tokens;
      },


        _buildFilterParamJson: function (url) {
            // summary:
            // This will build the Json object from the params.
            // The return object will be
            //{ viewId:'viewId', filterParam: 'All other params rated by &' }
            var params = {};
            url.replace(/[?&]+([^=&]+)=([^&]*)/gi, function (m, key, value) {
                    params[key] = value;
            });

            var paramJson = {};
            var varArgs = [];
            for (var key in params) {
                    if (key == 'viewId' || key == 'viewType') {
                            paramJson[key] = params[key];
                    } else if (key == 'linkType') {
                            continue;
                    } else {
                            varArgs.push(key + '=' + params[key]);
                    }
            }
            paramJson['filterParam'] = varArgs.join('&');
            return paramJson;
        },
        
        /**
         * Removes a particular item from window.localStorage
         * @param {String} key
         *     The key of the item to remove
         * @returns {boolean}
         *     True if successful, false if not
         *     Returns false if window.localStorage feature is not even found.
         */
        removeDOMStoreItem: function (key) {
            var store = window.localStorage;
            if (store) {
                store.removeItem(key);
                return true;
            }
            return false;
        },

        /**
         * Dumps all the contents of window.localStorage
         * @returns {boolean}
         *     True if successful, false if not.
         *     Returns false if window.localStorage feature is not even found.
         */
        clearDOMStore: function () {
            var store = window.localStorage;
            if (store) {
                store.clear();
                return true;
            }
            return false;
        },

        /**
         * Creates a message listener for window.postMessage messages.
         * @param {Function} callback
         *     The callback that will be invoked with the message. The callback
         *     is responsible for any security checks.
         * @param {String} [origin]
         *     The origin to check against for security. Allows all messages
         *     if no origin is provided.
         * @returns {Function}
         *     The callback function used to register with the message listener.
         *     This is different than the one provided as a parameter because
         *     the function is overloaded with origin checks.
         * @throws {Error} If the callback provided is not a function.
         */
        receiveMessage: function (callback, origin) {
            if (typeof callback !== "function") {
                throw new Error("Callback is not a function.");
            }

            //Create a function closure to perform origin check.
            var cb = function (e) {
                // If an origin check is requested (provided), we'll only invoke the callback if it passes
                if (typeof origin !== "string" || (typeof origin === "string" && typeof e.origin === "string" && e.origin.toLowerCase() === origin.toLowerCase())) {
                    callback(e);
                }
            };

            if (window.addEventListener) { //Firefox, Opera, Chrome, Safari
                window.addEventListener("message", cb, false);
            } else { //Internet Explorer
                window.attachEvent("onmessage", cb);
            }

            //Return callback used to register with listener so that invoker
            //could use it to remove.
            return cb;
        },

        /**
         * Sends a message to a target frame using window.postMessage.
         * @param {Function} message
         *     Message to be sent to target frame.
         * @param {Object} [target="parent"]
         *     An object reference to the target frame. Default us the parent.
         * @param {String} [targetOrigin="*"]
         *     The URL of the frame this frame is sending the message to.
         */
        sendMessage: function (message, target, targetOrigin) {
            //Default to any target URL if none is specified.
            targetOrigin = targetOrigin || "*";

            //Default to parent target if none is specified.
            target = target || parent;

            //Ensure postMessage is supported by browser before invoking.
            if (window.postMessage) {
                target.postMessage(message, targetOrigin);
            }
        },

        /**
         * Returns the passed in handler if it is a function
         * @param {Function} handler
         *     The handler to validate
         * @returns {Function}
         *     The provided handler if it is valid
         * @throws Error
         *     If the handler provided is invalid
         */
        validateHandler: function (handler) {
            if (handler === undefined || typeof handler === "function") {
                return handler;
            } else {
                throw new Error("handler must be a function");
            }
        },

        /**
         * Tries to get extract the AWS error code from a
         * cbabu.cuic.clientservices.ClientServices parsed error response object.
         * @param {Object} rsp
         *     The handler to validate
         * @returns {String}
         *     The error code, HTTP status code, or undefined
         */
        getErrCode: function (rsp) {
            try { // Best effort to get the error code
                return rsp.object.ApiErrors.ApiError.ErrorType;
            } catch (e) { // Second best effort to get the HTTP Status code
                if (rsp && rsp.status) {
                    return "HTTP " + rsp.status;
                }
            } // Otherwise, don't return anything (undefined)
        },

        /**
         * Tries to get extract the AWS error data from a
         * cbabu.cuic.clientservices.ClientServices parsed error response object.
         * @param {Object} rsp
         *     The handler to validate
         * @returns {String}
         *     The error data, HTTP status code, or undefined
         */
        getErrData: function (rsp) {
            try { // Best effort to get the error data
                return rsp.object.ApiErrors.ApiError.ErrorData;
            } catch (e) { // Second best effort to get the HTTP Status code
                if (rsp && rsp.status) {
                    return "HTTP " + rsp.status;
                }
            } // Otherwise, don't return anything (undefined)
        },
        
        /**
         * Tries to get extract the AWS overrideable boolean from a
         * cbabu.cuic.clientservices.ClientServices parsed error response object.
         * @param {Object} rsp
         *     The handler to validate
         * @returns {String}
         *     The overrideable boolean, HTTP status code, or undefined
         */
        getErrOverrideable: function (rsp) {
            try { // Best effort to get the override boolean
                return rsp.object.ApiErrors.ApiError.Overrideable;
            } catch (e) { // Second best effort to get the HTTP Status code
                if (rsp && rsp.status) {
                    return "HTTP " + rsp.status;
                }
            } // Otherwise, don't return anything (undefined)
        },

        /**
         * Trims leading and trailing whitespace
         * @param {String} str
         *     The string to trim
         * @returns {String}
         *     The trimmed string
         */
        trim: function (str) {
            return str.replace(/^\s*/, "").replace(/\s*$/, "");
        },

        /**
         * Utility method for getting the current time
         * @returns {String}
         *     The current time in milliseconds
         */
        currentTimeMillis : function () {
            return (new Date()).getTime();
        },

        /**
         * Generates an RFC1422v4-compliant UUID using pesudorandom numbers.
         * @returns {String}
         *     An RFC1422v4-compliant UUID using pesudorandom numbers.
         **/        
        generateUUID: function () {
            return Math.uuidCompact();
        },

        xml2json: Converter.xml2json,
        
        
        /**
         * Utility method to get the JSON parser either from gadgets.json
         * or from window.JSON (which will be initialized by CUIC if 
         * browser doesn't support
         */
        getJSONParser: function() {
            var _container = window.gadgets || {},
                parser = _container.json || window.JSON;
            return parser;
        },

        /**
        * Utility method to convert a javascript object to XML.
        * @param {Object} object
        *   The object to convert to XML.
        * @param {boolean} escapeFlag
        *   If escapeFlag evaluates to true:
        *       - XML escaping is done on the element values.
        *       - Attributes, #cdata, and #text is not supported.
        *       - The XML is unformatted (no whitespace between elements).
        *   If escapeFlag evaluates to false:
        *       - Element values are written 'as is' (no escaping).
        *       - Attributes, #cdata, and #text is supported.
        *       - The XML is formatted.
        * @returns The XML string.
        */
        json2xml: function (object, escapeFlag) {
            var xml;
            if (escapeFlag) {
                xml = this._json2xmlWithEscape(object);
            }
            else {
                xml = Converter.json2xml(object);
            }
            return xml;
        },

        /**
         * Utility method to convert XML string into javascript object.
         */
        xml2JsObj : function (event) {
            var parser = this.getJSONParser();
            return parser.parse(Converter.xml2json(jQuery.parseXML(event), ""));
        },

        /**
         * <p>Encodes the given string into base64.</p>
         *
         * <p><b>NOTE:</b> {input} is assumed to be UTF-8; only the first
         * 8 bits of each {input} element are significant.</p>
         *
         * @param {String} input
         *     The string to convert to base64.
         * @returns {String}
         *     The converted string.
         */
        b64Encode: function (input) {
            var output = "", idx, data,
                table = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";

            for (idx = 0; idx < input.length; idx += 3) {
                data =  input.charCodeAt(idx) << 16 |
                            input.charCodeAt(idx + 1) << 8 |
                            input.charCodeAt(idx + 2);

                //assume the first 12 bits are valid
                output +=   table.charAt((data >>> 18) & 0x003f) +
                            table.charAt((data >>> 12) & 0x003f);
                output +=   ((idx + 1) < input.length) ?
                            table.charAt((data >>> 6) & 0x003f) :
                            "=";
                output +=   ((idx + 2) < input.length) ?
                            table.charAt(data & 0x003f) :
                            "=";
            }

            return output;
        },

        /**
         * <p>Decodes the given base64 string.</p>
         *
         * <p><b>NOTE:</b> output is assumed to be UTF-8; only the first
         * 8 bits of each output element are significant.</p>
         *
         * @param {String} input
         *     The base64 encoded string
         * @returns {String}
         *     Decoded string
         */
        b64Decode: function (input) {
            var output = "", idx, h, data,
                table = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";

            for (idx = 0; idx < input.length; idx += 4) {
                h = [
                    table.indexOf(input.charAt(idx)),
                    table.indexOf(input.charAt(idx + 1)),
                    table.indexOf(input.charAt(idx + 2)),
                    table.indexOf(input.charAt(idx + 3))
                ];

                data = (h[0] << 18) | (h[1] << 12) | (h[2] << 6) | h[3];
                if (input.charAt(idx + 2) === '=') {
                    data = String.fromCharCode(
                        (data >>> 16) & 0x00ff
                    );
                } else if (input.charAt(idx + 3) === '=') {
                    data = String.fromCharCode(
                        (data >>> 16) & 0x00ff,
                        (data >>> 8) & 0x00ff
                    );
                } else {
                    data = String.fromCharCode(
                        (data >>> 16) & 0x00ff,
                        (data >>> 8) & 0x00ff,
                        data & 0x00ff
                    );
                }
                output += data;
            }

            return output;
        },

        /**
         * Extracts the username and the password from the Base64 encoded string.
         * @params {String}
         *     A base64 encoded string containing credentials that (when decoded)
         *     are colon delimited.
         * @returns {Object}
         *     An object with the following structure:
         *     {id:string, password:string}
         */
        getCredentials: function (authorization) {
            var credObj = {},
                credStr = this.b64Decode(authorization),
                colonIndx = credStr.indexOf(":");

            //Check to ensure that string is colon delimited.
            if (colonIndx === -1) {
                throw new Error("String is not colon delimited.");
            }

            //Extract ID and password.
            credObj.id = credStr.substring(0, colonIndx);
            credObj.password = credStr.substring(colonIndx + 1);
            return credObj;
        },

        /**
         * Takes a string and removes any spaces within the string.
         * @param {String} string
         *     The string to remove spaces from
         * @returns {String}
         *     The string without spaces
         */
        removeSpaces: function (string) {
            return string.split(' ').join('');
        },

        /**
         * Escapes spaces as encoded "&nbsp;" characters so they can
         * be safely rendered by jQuery.text(string) in all browsers.
         *
         * (Although IE behaves as expected, Firefox collapses spaces if this function is not used.)
         *
         * @param text
         *    The string whose spaces should be escaped
         *
         * @returns
         *    The string with spaces escaped
         */
        escapeSpaces: function (string) {
            return string.replace(/\s/g, '\u00a0');
        },

        /**
         * Adds a span styled to line break at word edges around the string passed in.
         * @param str String to be wrapped in word-breaking style.
         * @private
         */
        addWordWrapping : function (str) {
            return '<span style="word-wrap: break-word;">' + str + '</span>';
        },

        /**
         * Takes an Object and determines whether it is an Array or not
         * @param {Object} obj
         *     The Object in question
         * @returns {boolean}
         *     true the object is an Array or false it is not an Array
         */
        isArray: function (obj) {
            return obj.constructor.toString().indexOf("Array") !== -1;
        },

        /**
         * Takes a data object and returns an array extracted
         * @param {Object} data
         *     JSON payload
         *
         * @returns {array}
         *     extracted array
         */
        getArray: function (data) {
            if (this.isArray(data)) {
                //Return if already an array.
                return data;
            } else {
                //Create an array, iterate through object, and push to array. This
                //should only occur with one object, and therefore one obj in array.
                var arr = [];
                arr.push(data);
                return arr;
            }
        },

        /**
         * Extracts the ID for an entity given the cbabu REST URI. The ID is
         * assumed to be the last element in the URI (after the last "/").
         * @param {String} uri
         *     The cbabu REST URI to extract the ID from.
         * @returns {String}
         *     The ID extracted from the REST URI.
         */
        getId: function (uri) {
            if (!uri) {
                return "";
            }
            var strLoc = uri.lastIndexOf("/");
            return uri.slice(strLoc + 1);
        },

        /**
         * Compares two objects
         */
        getEquals: function (objA, objB) {
            var key;

            for (key in objA) {
                if (objA.hasOwnProperty(key)) {
                    if (!objA[key]) {
                        objA[key] = "";
                    }

                    if (typeof objB[key] === 'undefined') {
                        return false;
                    }
                    if (typeof objB[key] === 'object') {
                        if (!objB[key].equals(objA[key])) {
                            return false;
                        }
                    }
                    if (objB[key] !== objA[key]) {
                        return false;
                    }
                }
            }
            return true;
        },

        /**
         * Translates between special characters and HTML entities
         *
         * @param text
         *     The text to translate
         *
         * @param shouldEscape
         *    If true, encode special characters as HTML entities; if
         *    false, decode HTML entities back to special characters
         *
         * @private
         */
        translateHTMLEntities: function (text, shouldEscape) {

            var searchIndex, replaceIndex, searchRegex, translationMap;

            if (typeof(text) !== "undefined" && text !== null)
            {
                translationMap = [
                    ["&", "&amp;"],
                    ["<", "&lt;"],
                    [">", "&gt;"]
                ];

                if (shouldEscape) {
                    searchIndex = 0;
                    replaceIndex = 1;
                } else {
                    searchIndex = 1;
                    replaceIndex = 0;
                }

                jQuery.each(translationMap, function (i, mappingPair) {
                    searchRegex = new RegExp(mappingPair[searchIndex], 'gi');
                    text = text.replace(searchRegex, mappingPair[replaceIndex]);
                });
            }

            return text;
        },

        /**
         * Utility method to pad the number with a leading 0 for single digits
         * @parm (Number) num
         *     the number to pad
         */
        pad : function (num) {
            if (num < 10) {
                return "0" + num;
            }

            return String(num);
        },

        /**
         * Utility method to render a timestamp value (in seconds) into HH:MM:SS format
         * @parm (Number) time
         *     the timestamp in ms to render
         */
        getDisplayTime : function (time) {
            var hour, min, sec, timeStr = "00:00:00";

            if (time && time !== "-1") {
                // calculate hours, minutes, and seconds
                hour = this.pad(Math.floor(time / 3600));
                min = this.pad(Math.floor((time % 3600) / 60));
                sec = this.pad(Math.floor((time % 3600) % 60));
                // construct HH:MM:SS time string
                timeStr = hour + ":" + min + ":" + sec;
            }

            return timeStr;
        },     
        
        /**
         * Utility method to render a timestamp string (of format
         * YYYY-MM-DDTHH:MM:SSZ) into a duration of HH:MM:SS format
         * 
         * @param (String)
         *            timestamp the timestamp to render
         * @param (Date)
         *            now optional argument to provide the time from which to
         *            calculate the duration instead of using the current time
         */
        convertTsToDuration : function (timestamp, now) {
            return this.convertTsToDurationWithFormat(timestamp,false,now); 
        },
        
        /**
         * Utility method to render a timestamp string (of format
         * YYYY-MM-DDTHH:MM:SSZ) into a duration of HH:MM:SS format
         * 
         * @param (String)
         *            timestamp the timestamp to render
         * @param (Date)
         *            now optional argument to provide the time from which to
         *            calculate the duration instead of using the current time
         * @param (boolean)
         *            If True, if duration is null or negative, return -1 so that the duration can be formated
         *            as needed in the Gadget. 
         */
        convertTsToDurationWithFormat : function (timestamp, forFormat,now) {
            var startTimeInMs, nowInMs, durationInSec = "-1";
            
            // Calculate duration
            if (timestamp && typeof timestamp === "string") {
                // first check it '--' for a msg in grid
                if (timestamp === '--' || timestamp ==="" || timestamp === "-1") {
                    return "-1";
                }
                // else try convert string into a time
                startTimeInMs = Date.parse(timestamp);
                if (!isNaN(startTimeInMs)) {
                    if (!now || !(now instanceof Date)) {
                        nowInMs = new Date().getTime();
                    } else {
                        nowInMs = now.getTime();
                    }
                    durationInSec = Math.floor((nowInMs - startTimeInMs) / 1000);
                    
                    if (durationInSec < 0) {
                        if (forFormat) {
                            return "-1";
                        } else {
                            return this.getDisplayTime("-1");
                        }
                    }
                }
            }else {
                if(forFormat){
                    return "-1";
                }
            }
            return this.getDisplayTime(durationInSec);
         },
        /**
         * Adds a new cookie to the page with a default domain.
         * @param {String} key
         *      the key to assign a value to
         * @param {String} value
         *      the value to assign to the key
         * @param {Number} days
         *      number of days (from current) until the cookie should expire
         */
        addCookie : function (key, value, days) {
            var date, expires = "",
                cookie = key + "=" + escape(value);
            if (typeof days === "number") {
                date = new Date();
                date.setTime(date.getTime() + (days * 24 * 3600 * 1000));
                cookie += "; expires=" + date.toGMTString();
            }
            document.cookie = cookie + "; path=/";
        },

        /**
         * Get the value of a cookie given a key.
         * @param {String} key
         *      a key to lookup
         * @returns {String}
         *      the value mapped to a key, null if key doesn't exist
         */
        getCookie : function (key) {
            var i, pairs, pair;
            if (document.cookie) {
                pairs = document.cookie.split(";");
                for (i = 0; i < pairs.length; i += 1) {
                    pair = this.trim(pairs[i]).split("=");
                    if (pair[0] === key) {
                        return unescape(pair[1]);
                    }
                }
            }
            return null;
        },

        /**
         * Deletes the cookie mapped to specified key.
         * @param {String} key
         *      the key to delete
         */
        deleteCookie : function (key) {
            this.addCookie(key, "", -1);
        },

        /**
         * Case insensitive sort for use with arrays or Dojox stores
         * @param {String} a
         *      first value
         * @param {String} b
         *      second value
         */
        caseInsensitiveSort: function (a, b) {
            var ret = 0, emptyString = "";
            a = a + emptyString;
            b = b + emptyString;
            a = a.toLowerCase();
            b = b.toLowerCase();
            if (a > b) {
                ret = 1;
            }
            if (a < b) { 
                ret = -1;
            }
            return ret;
        },

        /**
        * Calls the specified function to render the dojo wijit for a gadget  when the gadget first becomes visible.
        *
        * The displayWjitFunc function will be called once and only once when the div for our wijit 
        * becomes visible for the first time.  This is necessary because some dojo wijits such as the grid
        * throw exceptions and do not render properly if they are created in a display:none div.
        * If our gadget is visisble the function will be called immediately.
        * If our gadget is not yet visisble, then it sets a timer and waits for it to become visible.
        * NOTE:  The timer may seem inefficent, originally I tried connecting to the tab onclick handler, but
        * there is a problem with dojo.connnect to an iframe's parent node in Internet Explorer. 
        * In Firefox the click handler works OK, but it happens before the node is actually visisble, so you
        * end up waiting for the node to become visisble anyway.
        * @displayWjitFunc:  A function to be called once our gadget has become visisble for th first time.
        */  
        onGadgetFirstVisible: function (displayWjitFunc) {
            var i, q, frameId, gadgetNbr, gadgetTitleId, panelId, panelNode, link, iterval, once = false, active = false, tabId = "#finesse-tab-selector";
            try {
                frameId = dojo.attr(window.frameElement, "id"); // Figure out what gadget number we are by looking at our frameset
                gadgetNbr = frameId.match(/\d+$/)[0];  // Strip the number off the end of the frame Id, that's our gadget number
                gadgetTitleId = "#finesse_gadget_" + gadgetNbr + "_title";  // Create a a gadget title id from the number
                
                // Loop through all of the tab panels to find one that has our gadget id
                dojo.query('.tab-panel', window.parent.document).some(function (node, index, arr) {
                    q = dojo.query(gadgetTitleId, node);  // Look in this panel for our gadget id
                    if (q.length > 0) {  // You found it
                        panelNode = node;
                        panelId = dojo.attr(panelNode, "id");  // Get panel id  e.g. panel_Workgroups
                        active = dojo.hasClass(panelNode, "active");
                        tabId = "#tab_" + panelId.slice(6);  // Turn it into a tab id e.g.tab_Workgroups
                        return;
                    }
                });
                // If panel is already active - execute the function - we're done
                if (active) {
                    console.log(frameId + " is visible display it");
                    setTimeout(displayWjitFunc);
                } 
                // If its not visible - wait for the active class to show up.
                else {
                    console.log(frameId  + " (" + tabId + ") is NOT active wait for it");
                    iterval = setInterval(dojo.hitch(this, function () {
                        if (dojo.hasClass(panelNode, "active")) {
                            console.log(frameId  + " (" + tabId + ") is visible display it");
                            clearInterval(iterval);
                            setTimeout(displayWjitFunc);
                        } 
                    }), 250);
                }
            } catch (err) {
                console.log("Could not figure out what tab " + frameId + " is in: " + err);
            }
        },

        /**
         * Downloads the specified url using a hidden iframe. In order to cause the browser to download rather than render
         * in the hidden iframe, the server code must append the header "Content-Disposition" with a value of 
         * "attachment; filename=\"<WhateverFileNameYouWant>\"".
         */
        downloadFile : function (url) {
            var iframe = document.getElementById("download_iframe");

            if (!iframe)
            {
                iframe = document.createElement("iframe");
                $(document.body).append(iframe);
                $(iframe).css("display", "none");
            }

            iframe.src = url;
        },

        /**
         * bitMask has functions for testing whether bit flags specified by integers are set in the supplied value
         */
        bitMask: {
            isSet: function (value, mask) {
                return (value & mask) === mask;
            },
            /**
             * Returns true if all flags in the intArray are set on the specified value
             */
            all: function (value, intArray) {
                var i = intArray.length;
                if (typeof(i) === "undefined")
                {
                    intArray = [intArray];
                    i = 1;
                }
                while ((i = i - 1) !== -1)
                {
                    if (!this.isSet(value, intArray[i]))
                    {
                        return false;
                    }
                }
                return true;
            },
            /**
             * Returns true if any flags in the intArray are set on the specified value
             */
            any: function (value, intArray) {
                var i = intArray.length;
                if (typeof(i) === "undefined")
                {
                    intArray = [intArray];
                    i = 1;
                }
                while ((i = i - 1) !== -1)
                {
                    if (this.isSet(value, intArray[i]))
                    {
                        return true;
                    }
                }
                return false;
            }
        },

        renderDojoGridOffScreen: function (grid) {
            var offscreenDiv = $("<div style='position: absolute; left: -5001px; width: 5000px;'></div>")[0];
            $(document.body).append(offscreenDiv);
            grid.placeAt(offscreenDiv);
            grid.startup();
            document.body.removeChild(offscreenDiv);
            return grid;
        },

        initializeSearchInput: function(searchInput, changeCallback, callbackDelay, callbackScope, placeholderText) {
            var timerId = null,
                theControl = typeof(searchInput) === "string" ? $("#" + searchInput) : $(searchInput),
                theInputControl = theControl.find("input"),
                theClearButton = theControl.find("a"),
                inputControlWidthWithClear = 204,
                inputControlWidthNoClear = 230,
                sPreviousInput = theInputControl.val(),
                toggleClearButton = function(){
                    if (theInputControl.val() === "") {
                        theClearButton.hide();
                        theControl.removeClass("input-append");
                        theInputControl.width(inputControlWidthNoClear);
                    } else {
                        theInputControl.width(inputControlWidthWithClear);
                        theClearButton.show();
                        theControl.addClass("input-append");
                    }
                };

            // set placeholder text
            theInputControl.attr('placeholder', placeholderText);

            theInputControl.unbind('keyup').bind('keyup', function() {
                if (sPreviousInput !== theInputControl.val()) {
                    window.clearTimeout(timerId);
                    sPreviousInput = theInputControl.val();
                    timerId = window.setTimeout(function() {
                        changeCallback.call((callbackScope || window), theInputControl.val());
                        theInputControl[0].focus();
                    }, callbackDelay);
                }

                toggleClearButton();
            });

            theClearButton.bind('click', function() {
                theInputControl.val('');
                changeCallback.call((callbackScope || window), '');

                toggleClearButton();
                theInputControl[0].focus(); // jquery and dojo on the same page break jquery's focus() method
            });

            theInputControl.val("");
            toggleClearButton();
        },

        DataTables: {
            
            createDataTable: function (options, dataTableOptions) {
                var grid,
                    table = $('<table cellpadding="0" cellspacing="0" border="0" class="finesse"><thead><tr></tr></thead></table>'),
                    headerRow = table.find("tr"),
                    defaultOptions = {
                        "aaData": [],
                        "bPaginate": false,
                        "bLengthChange": false,
                        "bFilter": false,
                        "bInfo": false,
                        "sScrollY": "176",
                        "oLanguage": {
                            "sEmptyTable": "",
                            "sZeroRecords": ""
                        }
                    },
                    gridOptions = $.extend({}, defaultOptions, dataTableOptions),
                    columnDefs = [],
                    columnFormatter;

                // Create a header cell for each column, and set up the datatable definition for the column
                $(options.columns).each(function (index, column) {
                    headerRow.append($("<th></th>"));
                    columnDefs[index] = {
                        "mData": column.propertyName,
                        "sTitle": column.columnHeader,
                        "sWidth": column.width,
                        "aTargets": [index],
                        "bSortable": column.sortable,
                        "bVisible": column.visible,
                        "mRender": column.render
                    };
                    if (typeof(column.renderFunction) === "function")
                    {
                        columnDefs[index].mRender = function (value, type, dataObject) {
                            var returnValue;

                            //Apply column render logic to value before applying extra render function
                            if (typeof(column.render) === "function")
                            {
                                value = column.render.call(value, value, value);
                            }

                            if (typeof(type) === "string")
                            {
                                switch (type)
                                {
                                case "undefined":
                                case "sort":
                                    returnValue = value;
                                    break;
                                case "set":
                                    throw new Error("Unsupported set data in Finesse Grid");
                                case "filter":
                                case "display":
                                case "type":
                                    returnValue = column.renderFunction.call(dataObject, value, dataObject);
                                    break;
                                default:
                                    break;
                                }
                            }
                            else
                            {
                                throw new Error("type param not specified in Finesse DataTable mData");
                            }

                            return  returnValue;
                        };
                    }
                });
                gridOptions.aoColumnDefs = columnDefs;

                // Set the height
                if (typeof(options.bodyHeightPixels) !== "undefined" && options.bodyHeightPixels !== null)
                {
                    gridOptions.sScrollY = options.bodyHeightPixels + "px";
                }

                // Place it into the DOM
                if (typeof(options.container) !== "undefined" && options.container !== null)
                {
                    $(options.container).append(table);
                }

                // Create the DataTable
                table.dataTable(gridOptions);

                return table;
            }
        },
        
        /**
         * Sets a dojo button to the specified disable state, removing it from
         * the tab order if disabling, and restoring it to the tab order if enabling.
         * @param {Object} dojoButton Reference to the dijit.form.Button object. This is not the DOM element.
         * @param {bool} disabled
         */
        setDojoButtonDisabledAttribute: function (dojoButton, disabled) {
            var labelNode,
                tabIndex;

            dojoButton.set("disabled", disabled);

            // Remove the tabindex attribute on disabled buttons, store it, 
            // and replace it when it becomes enabled again
            labelNode = $("#" + dojoButton.id + "_label");
            if (disabled)
            {
                labelNode.data("finesse:dojoButton:tabIndex", labelNode.attr("tabindex"));
                labelNode.removeAttr("tabindex");
            }
            else
            {
                tabIndex = labelNode.data("finesse:dojoButton:tabIndex");
                if (typeof(tabIndex) === "string")
                {
                    labelNode.attr("tabindex", Number(tabIndex));
                }
            }
        },

        /**
         * Measures the given text using the supplied fontFamily and fontSize
         * @param  {string} text       text to measure
         * @param  {string} fontFamily
         * @param  {string} fontSize
         * @return {number} pixel width
         */
        measureText: function (text, fontFamily, fontSize) {
            var width,
                element = $("<div></div>").text(text).css({
                    "fontSize": fontSize,
                    "fontFamily": fontFamily
                }).addClass("offscreen").appendTo(document.body);

            width = element.width();
            element.remove();

            return width;
        },

        /**
        * Private helper method for converting a javascript object to xml, where the values of the elements are
        * appropriately escaped for XML.
        * This is a simple implementation that does not implement cdata or attributes. It is also 'unformatted' in that
        * there is no whitespace between elements.
        * @param object The javascript object to convert to XML.
        * @returns The XML string.
        * @private
        */
        _json2xmlWithEscape: function(object) {
            var that = this,
                xml = "",
                m,
                toXmlHelper = function(value, name) {
                var xml = "",
                    i,
                    m;
                if (value instanceof Array) {
                    for (i = 0; i < value.length; ++i) {
                        xml += toXmlHelper(value[i], name);
                    }
                }
                else if (typeof value === "object") {
                    xml += "<" + name + ">";
                    for (m in value) {
                        if (value.hasOwnProperty(m)) {
                           xml += toXmlHelper(value[m], m);
                        }
                    }
                    xml += "</" + name + ">";
                }
                else {
                    // is a leaf node
                    xml += "<" + name + ">" + that.translateHTMLEntities(value.toString(), true) +
                        "</" + name + ">";
                }
                return xml;
            };
            for (m in object) {
                if (object.hasOwnProperty(m)) {
                    xml += toXmlHelper(object[m], m);
                }
            }
            return xml;
        },

        decodeStr: function (val) {
            var str = val.replace(/\+/g, '%20');
            str = str.replace(/%5C/g, "\\\\");
            str = decodeURIComponent(str);
            return str;
        },

        decodeFilterString: function (filterFields) {
            var that = this;
            if (filterFields) {
                filterFields.forEach(function (filterField) {
                    if (filterField.fieldType === 'STRING') {
                        filterField.firstStr = filterField.firstStr ? that.decodeStr(filterField.firstStr) : '';
                    }
                });
            }
        },
    };    
    
    return Utilities;
}));
</script><script type="text/javascript">/**
 * @fileOverview Allows gadgets to call the log function to publish client logging messages over the hub.
 *
 * @name cbabu.cuic.cslogger.ClientLogger
 * @requires OpenAjax
 */
(function (factory) {
    "use strict";

    // Define as an AMD module if possible
    if ( typeof define === 'function' && define.amd )
    {
        define([], factory );
    }
    
    /* Define using browser globals otherwise
     * Prevent multiple instantiations if the script is loaded twice
     */
    else
    {
        factory();
    }
    
}(function () {

    window.cbabu = window.cbabu || {};
    window.cbabu.cuic = window.cbabu.cuic || {};
    window.cbabu.cuic.cslogger = window.cbabu.cuic.cslogger || {};
    
    window.cbabu.cuic.cslogger.ClientLogger = (function () {
        var _hub, _logTopic, _originId,
    
        /**
         * Pads a single digit number for display purposes (e.g. '4' shows as '04')
         * @param num is the number to pad to 2 digits
         * @returns a two digit padded string
         */
        padTwoDigits = function (num)
        {
            return (num < 10) ? '0' + num : num;
        },
        
        /**
         * Pads a single digit number for display purposes (e.g. '4' shows as '004')
         * @param num is the number to pad to 3 digits
         * @returns a three digit padded string
         */
        padThreeDigits = function (num)
        {
            if (num < 10)
            {
              return '00'+num;
            }
            else if (num < 100)
            {
              return '0'+num;
            }
            else  
            {
               return num;
            }
        },
    
         /**
          * Gets a timestamp.
          * @returns {String} is a timestamp in the following format: HH:MM:SS
          */
        getTimestamp = function ()
        {
            var date = new Date(), timeStr;
            timeStr = padTwoDigits(date.getHours()) + ":" + padTwoDigits(date.getMinutes()) + ":" 
              + padTwoDigits(date.getSeconds()+"."+padThreeDigits(date.getMilliseconds()));
    
            return timeStr;
        },
    
        /**
         * Checks to see if we have a console.
         * @returns Whether the console object exists.
         */
        hasConsole = function () {
            try {
                if (window.console !== undefined) {
                    return true;
                }
            } catch (err) {
              // ignore and return false
            }
    
            return false;
        },
    
        /**
        * Logs a message to a hidden textarea element on the page
        *
        * @param str is the string to log.
        * @param logType is the optional type which is prefixed (default is "LOG")
        * @private
        */
        writeToLogOutput = function (msg) {
            var logOutput = document.getElementById("cbabuLogOutput");
    
            if (logOutput === null)
            {
                logOutput = document.createElement("textarea");
                logOutput.id = "cbabuLogOutput";
                logOutput.style.display = "none";
                document.body.appendChild(logOutput);
            }
    
            if (logOutput.value === "")
            {
                logOutput.value = msg;
            }
            else
            {
                logOutput.value = logOutput.value + "\n" + msg;
            }
        },
    
        logToConsole = function (str)
        {
            var msg, timeStr = getTimestamp();
            msg = "\n" + timeStr + ": " + str;
    
            // Log to console
            if (hasConsole()) {
                console.log(msg);
            }
    
            //Uncomment to print logs to hidden textarea.
            //writeToLogOutput(msg);
    
            return msg;
        };
    
        return {
    
            /**
             * Publishes a Log Message over the hub.
             *
             * @param {String} message
             *     The string to log.
             */
            log : function (message) {
                if(_hub) {
                    _hub.publish(_logTopic, logToConsole(_originId + message));
                }
            },
    
            /**
             * Initiates the client logger with a hub and a gadgetId
             * @param {Object} hub
             *      the hub to communicate with
             * @param {Object} gadgetId
             *      a unique string to identify which gadget is doing the logging
             */
            init: function (hub, gadgetId) {
                _hub = hub;
                _logTopic = "cbabu.cuic.clientLogging." + gadgetId;
                _originId = gadgetId + " : ";
            }
        };
    }());
}));
</script><script type="text/javascript">/**
 * @fileOverview Contains a list of topics used for client side pubsub.
 *
 * @name Topics
 */

/** @namespace */

/**
 * @class
 * Contains a list of topics with some utility functions.
 */
(function (factory) {
    "use strict";

    // Define as an AMD module if possible
    if ( typeof define === 'function' && define.amd )
    {
        define([], factory );
    }
    
    /* Define using browser globals otherwise
     * Prevent multiple instantiations if the script is loaded twice
     */
    else
    {
        factory();
    }
    
}(function () {
    
    window.cbabu = window.cbabu || {};
    window.cbabu.cuic = window.cbabu.cuic || {};
    window.cbabu.cuic.clientservices = window.cbabu.cuic.clientservices || {};
    
    window.cbabu.cuic.clientservices.Topics = (function () {

        /**
         * The namespace prepended to all cbabu topics.
         */
        this.namespace = "cbabu.cuic.info";
    
        /**
         * @private
         * Gets the full topic name with the cbabu namespace prepended.
         * @param {String} topic
         *     The topic category.
         * @returns {String}
         *     The full topic name with prepended namespace.
         */
        var _getNSTopic = function (topic) {
            return this.namespace + "." + topic;
        };
    
    
    
        /** @scope cbabu.cuic.clientservices.Topics */
        return {
            /** Client side request channel. */
            REQUESTS: _getNSTopic("requests"),
    
            /** Client side response channel. */
            RESPONSES: _getNSTopic("responses"),

            /** Connection status. */
            EVENTS_CONNECTION_INFO: _getNSTopic("connection"),
            
            /** Presence channel */
            PRESENCE: _getNSTopic("presence"),
    
            /**
             * Convert a cbabu REST URI to a OpenAjax compatible topic name.
             */
            getTopic: function (restUri) {
                //The topic should not start with '/' else it will get replaced with
                //'.' which is invalid.
                //Thus, remove '/' if it is at the beginning of the string
                if (restUri.indexOf('/') === 0) {
                    restUri = restUri.substr(1);
                }
    
                //Replace every instance of "/" with ".". This is done to follow the
                //OpenAjaxHub topic name convention.
                return restUri.replace(/\//g, ".");
            }
        };
    }());
    
    return window.cbabu.cuic.clientservices.Topics;
}));
</script><script type="text/javascript">/** The following comment is to prevent jslint errors about 
 * using variables before they are defined.
 */
/*global cbabu*/

/**
 * @fileOverview Initiated by the Master to create a shared BOSH connection.
 *
 * @name MasterTunnel
 * @requires Utilities
 */

/** @namespace */


/**
 * @class
 * Establishes a shared event connection by creating a communication tunnel
 * with the notification server and consume events which could be published.
 * Public functions are exposed to register to the connection status information
 * and events.
 * @constructor
 * @param {String} host
 *     The host name/ip of the cbabu server.
 * @throws {Error} If required constructor parameter is missing.
 */
(function (factory) {
    "use strict";

    // Define as an AMD module if possible
    if ( typeof define === 'function' && define.amd )
    {
        define(["utilities/Utilities"], factory );
    }
    
    /* Define using browser globals otherwise
     * Prevent multiple instantiations if the script is loaded twice
     */
    else
    {
        factory(cbabu.cuic.utilities.Utilities);
    }
    
}(function (Utilities) {
    
    window.cbabu = window.cbabu || {};
    window.cbabu.cuic = window.cbabu.cuic || {};
    window.cbabu.cuic.clientservices = window.cbabu.cuic.clientservices || {};

    window.cbabu.cuic.clientservices.MasterTunnel = function (host, scheme) {
        if (typeof host !== "string" || host.length === 0) {
            throw new Error("Required host parameter missing.");
        }

        var
        
        _socketTunnel = null,

        /**
         * Flag to indicate whether the tunnel frame is loaded.
         * @private
         */
        _isTunnelLoaded = false,
        
        _isSocketHostAvailable = false,

        /**
         * Short reference to the cbabu utility.
         * @private
         */
        _util = Utilities,

        /**
         * The URL with host and port to the cbabu server.
         * @private
         */
        _tunnelOrigin,

        /**
         * Location of the tunnel HTML URL.
         * @private
         */
        _tunnelURL,
        
        /**
         * The port on which to connect to the cbabu server to load the eventing resources.
         * @private
         */
        _tunnelOriginPort,
        
        /**
         * Flag to indicate whether we have processed the tunnel config yet.
         * @private
         */
        _isTunnelConfigInit = false,

        /**
         * The tunnel frame window object.
         * @private
         */
        _tunnelFrame,

        /**
         * The handler registered with the object to be invoked when an event is
         * delivered by the notification server.
         * @private
         */
        _eventHandler,
        
        /**
         * The handler registered with the object to be invoked when presence is
         * delivered by the notification server.
         * @private
         */
        _presenceHandler,

        /**
         * The handler registered with the object to be invoked when the BOSH
         * connection has changed states. The object will contain the "status"
         * property and a "resourceID" property only if "status" is "connected".
         * @private
         */
        _connInfoHandler,

        /**
         * The last connection status published by the JabberWerx library.
         * @private
         */
        _statusCache,

        /**
         * The last event sent by notification server.
         * @private
         */
        _eventCache,

        /**
         * The ID of the user logged into notification server.
         * @private
         */
        _userName,

        /**
         * The domain of the XMPP server, representing the portion of the JID
         * following '@': userid@domain.com
         * @private
         */
        _socketHost,
        
        _ldHost = [],
        
        _socketHostArray = [],

        /**
         * The password of the user logged into notification server.
         * @private
         */
        _password,
        
        /**
         * ViewId of the parent frame, required to get the token for LD service
         * @private
         */
        _viewId,

        /**
         * The jid of the pubsub service on the XMPP server
         * @private
         */
        _pubsubDomain,

        /**
         * The resource to use for the BOSH connection.
         * @private
         */
        _resource,

        /**
         * The resource ID identifying the client device (that we receive from the server).
         * @private
         */
        _resourceID,

        /**
         * The different types of messages that could be sent to the parent frame.
         * The types here should be understood by the parent frame and used to
         * identify how the message is formatted.
         * @private
         */
        _TYPES = {
            EVENT: 0,
            LDHOST: 1,
            PASSWORD: 2,
            SOCKETHOST_AVAILABLE:3,
            STATUS: 4,
            SOCKETHOST: 5,
            SOCKETHOST_UNAVAILABLE:6,
            SUBSCRIBE: 7,
            UNSUBSCRIBE: 8,
            VIEW_ID: 9,
            TOKEN: 10,
            SUBSCRIBED: 11,
            SUBSCRIBE_ERROR:12,
            UNSUBSCRIBED:13,
            UNSUBSCRIBE_ERROR:14
        },

        _handlers = {
            subscribe: {},
            unsubscribe: {}
        },
        

        /**
         * Create a connection info object.
         * @returns {Object}
         *     A connection info object containing a "status" and "resourceID".
         * @private
         */
        _createConnInfoObj = function () {
            return {
                status: _statusCache,
                resourceID: _resourceID
            };
        },

        /**
         * Utility function which sends a message to the dynamic tunnel frame
         * event frame formatted as follows: "type|message".
         * @param {Number} type
         *     The category type of the message.
         * @param {String} message
         *     The message to be sent to the tunnel frame.
         * @private
         */
        _sendMessage = function (type, message) {
            message = type + "|" + message;
            //_util.sendMessage(message, _tunnelFrame, _tunnelOrigin);
            _socketTunnel.messageHandler(message);
        },

        /**
         * Utility to process the response of a subscribe request from
         * the tunnel frame, then invoking the stored callback handler
         * with the respective data (error, when applicable)
         * @param {String} data
         *     The response in the format of "node[|error]"
         * @private
         */
        _processSubscribeResponse = function (data) {
            var dataArray = data.split("|"),
            node = dataArray[0],
            err;
            
            //Error is optionally the second item in the array
            if (dataArray.length) {
                err = dataArray[1];
            }
            
            // These response handlers are short lived and should be removed and cleaned up immediately after invocation.
            if (_handlers.subscribe[node]) {
                _handlers.subscribe[node](err);
                delete _handlers.subscribe[node];
            }
        },
        
        

        /**
         * Utility to process the response of an unsubscribe request from
         * the tunnel frame, then invoking the stored callback handler
         * with the respective data (error, when applicable)
         * @param {String} data
         *     The response in the format of "node[|error]"
         * @private
         */
        _processUnsubscribeResponse = function (data) {
            var dataArray = data.split("|"),
            node = dataArray[0],
            err;
            
            //Error is optionally the second item in the array
            if (dataArray.length) {
                err = dataArray[1];
            }
            
            // These response handlers are short lived and should be removed and cleaned up immediately after invocation.
            if (_handlers.unsubscribe[node]) {
                _handlers.unsubscribe[node](err);
                delete _handlers.unsubscribe[node];
            }
        },
        
        
        /**
         * Handler for messages delivered by window.postMessage. Listens for events
         * published by the notification server, connection status published by
         * the JabberWerx library, and the resource ID created when the BOSH
         * connection has been established.
         * @param {Object} e
         *     The message object as provided by the window.postMessage feature.
         * @private
         */
        _messageHandler = function (e) {
            var

            //Extract the message type and message data. The expected format is
            //"type|data" where type is a number represented by the TYPES object.
            delimPos = e.indexOf("|"),
            type = Number(e.substr(0, delimPos)),
            data =  e.substr(delimPos + 1);
            //Added the setTimeout so that the postmessage and publishing to the OpenAjax dont happen in the same thread.
            //It will slow down the performance if both operations happen in same thread.
            setTimeout(function(){
			            //Accepts messages and invoke the correct registered handlers.
				switch (type) {
				case _TYPES.EVENT:
					_eventCache = data;
					if (typeof _eventHandler === "function") {
						_eventHandler(data);
					}
					break;
				case _TYPES.STATUS:
					_statusCache = data;

					//A "loaded" status means that the frame is ready to accept
					//credentials for establishing a BOSH connection.
					if (data === "loaded") {
						_isTunnelLoaded = true;
						
						/*if(_resource) {
							_sendMessage(_TYPES.RESOURCEID, _resource);
						}*/
						_sendMessage(_TYPES.PASSWORD, _password);
						_sendMessage(_TYPES.SOCKETHOST, JSON.stringify(_socketHost));
						_sendMessage(_TYPES.LDHOST, JSON.stringify(_ldHost));
						_sendMessage(_TYPES.VIEW_ID, _viewId);
					} else if (typeof _connInfoHandler === "function") {
						_connInfoHandler(_createConnInfoObj());
					}
					break;
				case _TYPES.SOCKETHOST_AVAILABLE:
					_isSocketHostAvailable = true;
					break;
				case _TYPES.SOCKETHOST_UNAVAILABLE:
					_isSocketHostAvailable = false;
					break;
					
				case _TYPES.RESOURCEID:
					_resourceID = data;
					break;
				case _TYPES.SUBSCRIBE:
					_processSubscribeResponse(data);
					break;
				case _TYPES.UNSUBSCRIBE:
					_processUnsubscribeResponse(data);
					break;
                		case _TYPES.SUBSCRIBED:
					cbabu.cuic.clientservices.ClientServices.publish("cbabu.cuic.subscribed", data);
					break;
				case _TYPES.SUBSCRIBE_ERROR:
					cbabu.cuic.clientservices.ClientServices.publish("cbabu.cuic.subscribe.error", data);
					break;
		                case _TYPES.UNSUBSCRIBED:       
		                    cbabu.cuic.clientservices.ClientServices.publish("cbabu.cuic.unsubscribed", data);
		                    break;
		                case _TYPES.UNSUBSCRIBE_ERROR:
		                    cbabu.cuic.clientservices.ClientServices.publish("cbabu.cuic.unsubscribe.error", data);
		                    break;
				default:
					break;
				}
			
			},100);              

        },


        /**
         * Create the tunnel iframe which establishes the shared BOSH connection.
         * Messages are sent across frames using window.postMessage.
         * @private
         */
        _createTunnel = function () {
    	      _socketTunnel = new cbabu.cuic.SocketTunnel();
    	      _socketTunnel.init();
        };
        
        /**
         * This method is used to create host array from complete host information.
         * Messages are sent across frames using tunnel.
         * Complete host information will have socket host ip and token for string
         * @private
         */
        _createSocketArrayList = function (socketHost) {
        	var socketHostList = socketHost
            for(var index=0;index<socketHost.length;index++)
            	{
            		_socketHostArray[index] = socketHostList[index];
            	}
           
        };
        
        /**
         * Sends a message via postmessage to the SocketTunnel to attempt to connect to the XMPP server
         * @private
         */
        this.subscribeRoom = function (roomId) {
            _sendMessage(_TYPES.SUBSCRIBE, roomId);
        };
        
        this.unsubscribeRoom = function (roomId) {
            _sendMessage(_TYPES.UNSUBSCRIBE, roomId);
        };
        
        this._postToken = function(data){
        	_sendMessage(_TYPES.TOKEN, data);
        };
        

        /**
         * Sends a message via postmessage to the SocketTunnel to attempt to connect to the XMPP server
         * @private
         */
        this.makeConnectReq = function () {
            _sendMessage(_TYPES.PASSWORD, _password);
        };
        
        /**
         * Returns the host of the cbabu server.
         * @returns {String}
         *     The host specified during the creation of the object.
         */
        this.getHost = function () {
            return host;
        };

        /**
         * The resource ID of the user who is logged into the notification server.
         * @returns {String}
         *     The resource ID generated by the notification server.
         */
        this.getResourceID = function () {
            return _resourceID;
        };

        /**
         * Indicates whether the tunnel frame is loaded.
         * @returns {Boolean}
         *     True if the tunnel frame is loaded, false otherwise.
         */
        this.isTunnelLoaded = function () {
            return _isTunnelLoaded;
        };
        
        
        
        /**
         * Indicates whether the socket host is loaded.
         * @returns {Boolean}
         *     True if the tunnel frame is loaded, false otherwise.
         */
        this.isSocketHostAvailable = function () {
            return _isSocketHostAvailable;
        };

        /**
         * The location of the tunnel HTML URL.
         * @returns {String}
         *     The location of the tunnel HTML URL.
         */
        this.getSocketHostArray = function () {
            return _socketHostArray;
        };
        
        this.getSocketHostForCertificateAcceptance = function() {
        	return _socketTunnel.getSocketHostForCertificateAcceptance();
        };

        /**
         * Tunnels a subscribe request to the eventing iframe.
         * @param {String} node
         *     The node to subscribe to
         * @param {Function} handler
         *     Handler to invoke upon success or failure
         */
        this.subscribe = function (node, handler) {
            if (handler && typeof handler !== "function") {
                throw new Error("Parameter is not a function.");
            }
            _handlers.subscribe[node] = handler;
            _sendMessage(_TYPES.SUBSCRIBE, node);
        };

        /**
         * Tunnels an unsubscribe request to the eventing iframe.
         * @param {String} node
         *     The node to unsubscribe from
         * @param {Function} handler
         *     Handler to invoke upon success or failure
         */
        this.unsubscribe = function (node, handler) {
            if (handler && typeof handler !== "function") {
                throw new Error("Parameter is not a function.");
            }
            _handlers.unsubscribe[node] = handler;
            _sendMessage(_TYPES.UNSUBSCRIBE, node);
        };

        /**
         * Registers a handler to be invoked when an event is delivered. Only one
         * is registered at a time. If there has already been an event that was
         * delivered, the handler will be invoked immediately.
         * @param {Function} handler
         *     Invoked when an event is delivered through the event connection.
         */
        this.registerEventHandler = function (handler) {
            if (typeof handler !== "function") {
                throw new Error("Parameter is not a function.");
            }
            _eventHandler = handler;
            if (_eventCache) {
                handler(_eventCache);
            }
        };

        /**
         * Unregisters the event handler completely.
         */
        this.unregisterEventHandler = function () {
            _eventHandler = undefined;
        };
        
        /**
         * Registers a handler to be invoked when a connection status changes. The
         * object passed will contain a "status" property, and a "resourceID"
         * property, which will contain the most current resource ID assigned to
         * the client. If there has already been an event that was delivered, the
         * handler will be invoked immediately.
         * @param {Function} handler
         *     Invoked when a connection status changes.
         */
        this.registerConnectionInfoHandler = function (handler) {
            if (typeof handler !== "function") {
                throw new Error("Parameter is not a function.");
            }
            _connInfoHandler = handler;
            if (_statusCache) {
                handler(_createConnInfoObj());
            }
        };

        /**
         * Unregisters the connection information handler.
         */
        this.unregisterConnectionInfoHandler = function () {
            _connInfoHandler = undefined;
        };

        /**
         * Start listening for events and create a event tunnel for the shared BOSH
         * connection.
         * @param {String} id
         *     The ID of the user for the notification server.
         * @param {String} password
         *     The password of the user for the notification server.
         * @param {String} socketHost
         *     The XMPP domain of the notification server
         * @param {String} pubsubDomain
         *     The location (JID) of the XEP-0060 PubSub service
         * @param {String} resource
         *     The resource to connect to the notification servier with.
         */
        this.init = function (password, socketHost, ldHost, viewId) {
            
            if (typeof password !== "string" || typeof socketHost !== "object" ) {
                throw new Error("Invalid or missing required parameters.");
            }

            _ldHost = ldHost;
            _password = password;
            _socketHost = socketHost;
            _viewId = viewId;
            //Attach a listener for messages sent from tunnel frame.
            //_util.receiveMessage(_messageHandler, _tunnelOrigin);
            _createSocketArrayList(socketHost);
            //Create the tunnel iframe which will establish the shared connection.
            _createTunnel();
        };
        
        this.messageHandler = function (message) {
        	_messageHandler(message);
        };

        //BEGIN TEST CODE//
//        /**
//         * Test code added to expose private functions that are used by unit test
//         * framework. This section of code is removed during the build process
//         * before packaging production code. The [begin|end]TestSection are used
//         * by the build to identify the section to strip.
//         * @ignore
//         */
//        this.beginTestSection = 0;
//
//        /**
//         * @ignore
//         */
//        this.getTestObject = function () {
//            //Load mock dependencies.
//            var _mock = new MockControl();
//            _util = _mock.createMock(cbabu.cuic.utilities.Utilities);
//
//            return {
//                //Expose mock dependencies
//                mock: _mock,
//                util: _util,
//
//                //Expose internal private functions
//                types: _TYPES,
//                createConnInfoObj: _createConnInfoObj,
//                sendMessage: _sendMessage,
//                messageHandler: _messageHandler,
//                createTunnel: _createTunnel,
//                handlers: _handlers,
//                initTunnelConfig : _initTunnelConfig
//            };
//        };
//
//        /**
//         * @ignore
//         */
//        this.endTestSection = 0;
//        //END TEST CODE//
    };
}));
</script><script type="text/javascript">/** The following comment is to prevent jslint errors about 
 * using variables before they are defined.
 */
/*global cbabu*/

/**
 * @fileOverview Registers with the MasterTunnel to receive events, which it
 *     could publish to the OpenAjax gadget pubsub infrastructure.
 *
 * @name MasterPublisher
 * @requires OpenAjax, cbabu.cuic.clientservices.MasterTunnel, cbabu.cuic.clientservices.Topics
 */

/** @namespace */

/**
 * @class
 * Register with the MasterTunnel to receive events. Events are published to
 * the appropriate topics.
 * @constructor
 * @param {cbabu.cuic.clientservices.MasterTunnel} tunnel
 *     An object instance of the {@link cbabu.cuic.clientservices.MasterTunnel} class.
 * @throws {Error} If required constructor parameter is missing.
 */
(function (factory) {
    "use strict";

    // Define as an AMD module if possible
    if ( typeof define === 'function' && define.amd )
    {
        define(["clientservices/MasterTunnel",
                "clientservices/Topics",
                "utilities/Utilities"], factory );
    }
    
    /* Define using browser globals otherwise
     * Prevent multiple instantiations if the script is loaded twice
     */
    else
    {
        factory(cbabu.cuic.clientservices.MasterTunnel, cbabu.cuic.clientservices.Topics, cbabu.cuic.utilities.Utilities);
    }
    
}(function (MasterTunnel, Topics, Utilities) {
    
    window.cbabu = window.cbabu || {};
    window.cbabu.cuic = window.cbabu.cuic || {};
    window.cbabu.cuic.clientservices = window.cbabu.cuic.clientservices || {};
    
    window.cbabu.cuic.clientservices.MasterPublisher = function (tunnel, hub) {
        if (!(tunnel instanceof MasterTunnel)) {
            throw new Error("Required tunnel object missing or invalid.");
        }

        var
        
        ClientServices = cbabu.cuic.clientservices.ClientServices,

        /**
         * Reference to the gadget pubsub Hub instance.
         * @private
         */
        _hub = hub,

        /**
         * Reference to the Topics class.
         * @private
         */
        _topics = Topics,
        
        /**
         * Reference to conversion utilities class.
         * @private
         */
        _utils = Utilities,
        
        /**
         * References to ClientServices logger methods
         * @private
         */
        _logger = {
            log: ClientServices.log
        },
        
        /**
         * Store the passed in tunnel.
         * @private
         */
        _tunnel = tunnel,

        /**
         * Caches the connection info event so that it could be published if there
         * is a request for it.
         * @private
         */
        _connInfoCache,

        /**
         * The types of possible request types supported when listening to the
         * requests channel. Each request type could result in different operations.
         */
        _REQTYPES = {
            CONNECTIONINFO: "ConnectionInfoReq",
            SUBSCRIBE: "SubscribeNodeReq",
            UNSUBSCRIBE: "UnsubscribeNodeReq",
            CONNECT: "ConnectionReq"
        },

        /**
         * Will store list of nodes that have OF subscriptions created
         *     _nodesList[node][subscribing].reqIds[subid]
         *     _nodesList[node][active].reqIds[subid]
         *     _nodesList[node][unsubscribing].reqIds[subid]
         *     _nodesList[node][holding].reqIds[subid]
         */
        _nodesList = {},
        
        /**
         * The states that a subscription can be in
         */
        _CHANNELSTATES = {
            UNINITIALIZED: "Uninitialized",
            PENDING: "Pending",
            OPERATIONAL: "Operational"
        },

        /**
          * Checks if the payload is JSON 
          * @returns {Boolean}
          * @private
          */
        _isJsonPayload = function(event) {
            var delimStart, delimEnd, retval = false;
            
            try { 
              delimStart = event.indexOf('{');
              delimEnd = event.lastIndexOf('}');

              if ((delimStart !== -1 ) && (delimEnd === (event.length - 1))) {
                retval = true;	//event contains JSON payload
              }
            } catch (err) {
              _logger.log("MasterPublisher._isJsonPayload() - Caught error: " + err);
            }
            return retval;
        },
        
                /**
          * Parses a JSON event and then publishes.
          *
          * @param {String} event
          *     The full event payload.
          * @throws {Error} If the payload object is malformed.
          * @private
          */
        _parseAndPublishJSONEvent = function(event) {
            var topic, eventObj, publishEvent,
            delimPos = event.indexOf("{"),
            node, parser,
            eventJson = event,
            returnObj = {node: null, data: null};

            try {
               //Extract and strip the node path from the message
               if (delimPos > 0) 
               {
                  //We need to decode the URI encoded node path
                  //TODO: make sure this is kosher with OpenAjax topic naming
                  node = decodeURI(event.substr(0, delimPos));
                  eventJson = event.substr(delimPos);
                  
                  //Converting the node path to openAjaxhub topic
                  topic = _topics.getTopic(node);
                  
                  returnObj.node = node;
                  returnObj.payload = eventJson;
               } 
               else 
               {
                  _logger.log("MasterPublisher._parseAndPublishJSONEvent() - [ERROR] node is not given in postMessage: " + eventJson);
                  throw new Error("node is not given in postMessage: " + eventJson);
               }

               //parser = _utils.getJSONParser();
               //eventObj = parser.parse(eventJson);
               //returnObj.data = eventObj;

            } catch (err) {
               _logger.log("MasterPublisher._parseAndPublishJSONEvent() - [ERROR] Malformed event payload: " + err);
               throw new Error("Malformed event payload : " + err);
            }
            
            _logger.log("MasterPublisher._parseAndPublishJSONEvent() - Received JSON event on node '" + node + "': " + eventJson); 
            
            publishEvent = {content : eventJson};

            //Publish event to proper event topic.
            if (topic && eventJson) {
               _hub.publish(topic, publishEvent);
            }
        },
        
        /**
          * Parses an XML event and then publishes.
          *
          * @param {String} event
          *     The full event payload.
          * @throws {Error} If the payload object is malformed.
          * @private
          */
        _parseAndPublishXMLEvent = function(event) {
            var topic, eventObj, publishEvent, restTopic,
            delimPos = event.indexOf("<"),
            node,
            eventXml = event;
            
            try {
               //Extract and strip the node path from the message
               if (delimPos > 0) {
                  //We need to decode the URI encoded node path
                  //TODO: make sure this is kosher with OpenAjax topic naming
                  node = decodeURI(event.substr(0, delimPos));
                  eventXml = event.substr(delimPos);
                  //Converting the node path to openAjaxhub topic
                  topic = _topics.getTopic(node);
               } else {
                  _logger.log("MasterPublisher._parseAndPublishXMLEvent() - [ERROR] node is not given in postMessage: " + eventXml);
                  throw new Error("node is not given in postMessage: " + eventXml);
               }

               eventObj = _utils.xml2JsObj(eventXml);
                  
           } catch (err) {
               _logger.log("MasterPublisher._parseAndPublishXMLEvent() - [ERROR] Malformed event payload: " + err);
               throw new Error("Malformed event payload : " + err);
           }
           
           _logger.log("MasterPublisher._parseAndPublishXMLEvent() - Received XML event on node '" + node + "': " + eventXml);
           
           publishEvent = {content : event, object : eventObj };

           //Publish event to proper event topic.
           if (topic && eventObj) {
               _hub.publish(topic, publishEvent);
           }
        },
        
        /**
         * Publishes events to the appropriate topic. The topic name is determined
         * by fetching the source value from the event.
         * @param {String} event
         *     The full event payload.
         * @throws {Error} If the payload object is malformed.
         * @private
         */
        _eventHandler = function (event) {
            
            //Handle JSON or XML events
            if (!_isJsonPayload(event))
            {
               //XML
               _parseAndPublishXMLEvent(event);
            }
            else
            {
               //JSON
               _parseAndPublishJSONEvent(event);
            }
        },
        
        
        /**
         * Handler for when presence events are sent through the MasterTunnel.
         * @returns {Object}
         *     A presence xml event.
         * @private
         */
        _presenceHandler = function (event) {
            var eventObj = _utils.xml2JsObj(event), publishEvent;
            
            publishEvent = {content : event, object : eventObj};
            
            if (eventObj) {
                _hub.publish(_topics.PRESENCE, publishEvent);
            }
        },

        /**
         * Clone the connection info object from cache.
         * @returns {Object}
         *     A connection info object containing a "status" and "resourceID".
         * @private
         */
        _cloneConnInfoObj = function () {
            if (_connInfoCache) {
                return {
                    status: _connInfoCache.status,
                    resourceID: _connInfoCache.resourceID
                };
            } else {
                return null;
            }
        },

        /**
         * Publishes the connection info to the connection info topic.
         * @param {Object} connInfo
         *     The connection info object containing the status and resource ID.
         * @private
         */
        _connInfoHandler = function (connInfo) {
            _connInfoCache = connInfo;
            _logger.log("MasterPublisher._connInfoHandler() - Connection status: " + connInfo.status);
            _hub.publish(_topics.EVENTS_CONNECTION_INFO, _cloneConnInfoObj());
        },

        
        /**
         * Utility method to bookkeep node subscription requests and determine
         * whehter it is necessary to tunnel the request to JabberWerx.
         * @param {String} node
         *     The node of interest
         * @param {String} reqId
         *     A unique string identifying the request/subscription
         * @private
         */
        _subscribeNode = function (node, subid) {
            // NODE DOES NOT YET EXIST
            if (!_nodesList[node]) {
                _nodesList[node] = {
                    "subscribing": {
                        "reqIds": {},
                        "length": 0
                    },
                    "active": {
                        "reqIds": {},
                        "length": 0
                    },
                    "unsubscribing": {
                        "reqIds": {},
                        "length": 0
                    },
                    "holding": {
                        "reqIds": {},
                        "length": 0
                    }
                };
            }
            if (_nodesList[node].active.length === 0) {
                if (_nodesList[node].unsubscribing.length === 0) {
                    if (_nodesList[node].subscribing.length === 0) {
                        _nodesList[node].subscribing.reqIds[subid] = true;
                        _nodesList[node].subscribing.length += 1;

                        _logger.log("MasterPublisher._subscribeNode() - Attempting to subscribe to node '" + node + "'");
                        _tunnel.subscribe(node, function (err) {
                            var errObj, curSubid;
                            if (err) {
                                errObj = {
                                    subscribe: {
                                        content: err
                                    }
                                };

                                try {
                                    errObj.subscribe.object = gadgets.json.parse((_utils.xml2json(jQuery.parseXML(err), "")));
                                } catch (e) {
                                    errObj.error = {
                                        errorType: "parseError",
                                        errorMessage: "Could not serialize XML: " + e
                                    };
                                }
                                _logger.log("MasterPublisher._subscribeNode() - Error subscribing to node '" + node + "': " + err);
                            } else {
                                _logger.log("MasterPublisher._subscribeNode() - Subscribed to node '" + node + "'");
                            }

                            for (curSubid in _nodesList[node].subscribing.reqIds) {
                                if (_nodesList[node].subscribing.reqIds.hasOwnProperty(curSubid)) {
                                    _hub.publish(_topics.RESPONSES + "." + curSubid, errObj);
                                    if (!err) {
                                        _nodesList[node].active.reqIds[curSubid] = true;
                                        _nodesList[node].active.length += 1;
                                    }
                                    delete _nodesList[node].subscribing.reqIds[curSubid];
                                    _nodesList[node].subscribing.length -= 1;
                                }
                            }
                        });
                        
                    } else { //other ids are subscribing
                        _nodesList[node].subscribing.reqIds[subid] = true;
                        _nodesList[node].subscribing.length += 1;
                    }                       
                } else { //An unsubscribe request is pending, hold onto these subscribes until it is done
                    _nodesList[node].holding.reqIds[subid] = true;
                    _nodesList[node].holding.length += 1;
                }
            } else { // The node has active subscriptions; add this subid and return successful response
                _nodesList[node].active.reqIds[subid] = true;
                _nodesList[node].active.length += 1;
                _hub.publish(_topics.RESPONSES + "." + subid, undefined); 
            }
        },

        /**
         * Utility method to bookkeep node unsubscribe requests and determine
         * whehter it is necessary to tunnel the request to JabberWerx.
         * @param {String} node
         *     The node to unsubscribe from
         * @param {String} reqId
         *     A unique string identifying the subscription to remove
         * @private
         */
        _unsubscribeNode = function (node, subid) {
            if (!_nodesList[node]) { //node DNE, publish success response
                _hub.publish(_topics.RESPONSES + "." + subid, undefined); 
            } else {
                if (_nodesList[node].active.length > 1) {
                    delete _nodesList[node].active.reqIds[subid];
                    _hub.publish(_topics.RESPONSES + "." + subid, undefined); 
                    _nodesList[node].active.length -= 1;
                } else if (_nodesList[node].active.length === 1) { // transition subid from active category to unsubscribing category
                    _nodesList[node].unsubscribing.reqIds[subid] = true;
                    _nodesList[node].unsubscribing.length += 1;
                    delete _nodesList[node].active.reqIds[subid];
                    _nodesList[node].active.length -= 1;

                    _logger.log("MasterPublisher._unsubscribeNode() - Attempting to unsubscribe from node '" + node + "'");
                    _tunnel.unsubscribe(node, function (err) {
                        var errObj, curSubid;
                        if (err) {
                            errObj = {
                                subscribe: {
                                    content: err
                                }
                            };

                            try {
                                errObj.subscribe.object = gadgets.json.parse((_utils.xml2json(jQuery.parseXML(err), "")));
                            } catch (e) {
                                errObj.error = {
                                    errorType: "parseError",
                                    errorMessage: "Could not serialize XML: " + e
                                };
                            }
                            _logger.log("MasterPublisher._unsubscribeNode() - Error unsubscribing from node '" + node + "': " + err);
                        } else {
                            _logger.log("MasterPublisher._unsubscribeNode() - Unsubscribed from node '" + node + "'");
                        }

                        for (curSubid in _nodesList[node].unsubscribing.reqIds) {
                            if (_nodesList[node].unsubscribing.reqIds.hasOwnProperty(curSubid)) {
                                // publish to all subids whether unsubscribe failed or succeeded
                                _hub.publish(_topics.RESPONSES + "." + curSubid, errObj); 
                                if (!err) {
                                    delete _nodesList[node].unsubscribing.reqIds[curSubid];
                                    _nodesList[node].unsubscribing.length -= 1;
                                } else { // Just remove the subid from unsubscribing; the next subscribe request will operate with node already created
                                    delete _nodesList[node].unsubscribing.reqIds[curSubid];
                                    _nodesList[node].unsubscribing.length -= 1;
                                }   
                            }
                        }
                        
                        if (!err && _nodesList[node].holding.length > 0) { // if any subscribe requests came in while unsubscribing from OF, now transition from holding to subscribing
                            for (curSubid in _nodesList[node].holding.reqIds) {
                                if (_nodesList[node].holding.reqIds.hasOwnProperty(curSubid)) {
                                    delete _nodesList[node].holding.reqIds[curSubid];
                                    _nodesList[node].holding.length -= 1;
                                    _subscribeNode(node, curSubid);                             
                                }
                            }
                        }
                    });
                } else { // length <= 0?
                    _hub.publish(_topics.RESPONSES + "." + subid, undefined);
                }
            }
        },
        
        /**
         * Handles client requests to establish a BOSH connection.
         * @param {String} id
         *     id of the xmpp user
         * @param {String} password
         *     password of the xmpp user
         * @param {String} sockethost
         *     sockethost of the xmpp user account
         * @private
         */
        _connect = function (id, password, sockethost) {
            _tunnel.makeConnectReq(id, password, sockethost);
        },

        /**
         * Handles client requests made to the request topic. The type of the
         * request is described in the "type" property within the data payload. Each
         * type can result in a different operation.
         * @param {String} topic
         *     The topic which data was published to.
         * @param {Object} data
         *     The data containing requests information published by clients.
         * @param {String} data.type
         *     The type of the request. Supported: "ConnectionInfoReq"
         * @param {Object} data.data
         *     May contain data relevant for the particular requests.
         * @param {String} [data.invokeID]
         *     The ID used to identify the request with the response. The invoke ID
         *     will be included in the data in the publish to the topic. It is the
         *     responsibility of the client to correlate the published data to the
         *     request made by using the invoke ID.
         * @private
         */
        _clientRequestHandler = function (topic, data) {
            var dataCopy;

            //Ensure a valid data object with "type" and "data" properties.
            if (typeof data === "object" &&
                    typeof data.type === "string" &&
                    typeof data.data === "object") {
                switch (data.type) {
                case _REQTYPES.CONNECTIONINFO:
                    //It is possible that Slave clients come up before the Master
                    //client. If that is the case, the Slaves will need to make a
                    //request for the Master to send the latest connection info to the
                    //connectionInfo topic.
                    dataCopy = _cloneConnInfoObj();
                    if (dataCopy) {
                        if (data.invokeID !== undefined) {
                            dataCopy.invokeID = data.invokeID;
                        }
                        _hub.publish(_topics.EVENTS_CONNECTION_INFO, dataCopy);
                    }
                    break;
                case _REQTYPES.SUBSCRIBE:
                    if (typeof data.data.node === "string") {
                        _subscribeNode(data.data.node, data.invokeID);
                    }
                    break;
                case _REQTYPES.UNSUBSCRIBE:
                    if (typeof data.data.node === "string") {
                        _unsubscribeNode(data.data.node, data.invokeID);
                    }
                    break;
                case _REQTYPES.CONNECT:
                    if (typeof data.data.id === "string" && typeof data.data.password === "string" && typeof data.data.sockethost === "string") {
                        _connect(data.data.id, data.data.password, data.data.sockethost);
                    }
                    break;
                default:
                    break;
                }
            }
        };

        (function () {
            //Register to receive events and connection status from tunnel.
            _tunnel.registerEventHandler(_eventHandler);
            _tunnel.registerConnectionInfoHandler(_connInfoHandler);

            //Listen to a request channel to respond to any requests made by other
            //clients because the Master may have access to useful information.
            _hub.subscribe(_topics.REQUESTS, _clientRequestHandler);
        }());

        /**
         * Resets the list of explicit subscriptions
         */
        this.wipeout = function () {
            var node, curSubid, errObj = {
                error: {
                    errorType: "Disconnected",
                    errorMessage: "Outstanding request will never complete."
                }
            };

            // Iterate through all outstanding subscribe requests to notify them that it will never return
            for (node in _nodesList) {
                if (_nodesList.hasOwnProperty(node)) {
                    for (curSubid in _nodesList[node].subscribing.reqIds) {
                        if (_nodesList[node].subscribing.reqIds.hasOwnProperty(curSubid)) {
                            // Notify this outstanding subscribe request to give up and error out
                            _hub.publish(_topics.RESPONSES + "." + curSubid, errObj); 
                        }
                    }
                    for (curSubid in _nodesList[node].unsubscribing.reqIds) {
                        if (_nodesList[node].unsubscribing.reqIds.hasOwnProperty(curSubid)) {
                            // Notify this outstanding unsubscribe request to give up and error out
                            _hub.publish(_topics.RESPONSES + "." + curSubid, errObj); 
                        }
                    }
                }
            }

            _nodesList = {};
       };

        //BEGIN TEST CODE//
       /**
        * Test code added to expose private functions that are used by unit test
        * framework. This section of code is removed during the build process
        * before packaging production code. The [begin|end]TestSection are used
        * by the build to identify the section to strip.
        * @ignore
        */
       this.beginTestSection = 0;

       /**
        * @ignore
        */
       this.getTestObject = function () {
           //Load mock dependencies.
           var _mock = new MockControl();
           _hub = _mock.createMock(gadgets.Hub);
           _tunnel = _mock.createMock();

           return {
               //Expose mock dependencies
               mock: _mock,
               hub: _hub,
               tunnel: _tunnel,
               setTunnel: function (tunnel) {
                   _tunnel = tunnel;
               },
               getTunnel: function () {
                   return _tunnel;
               },

               //Expose internal private functions
               reqtypes: _REQTYPES,
               eventHandler: _eventHandler,
               presenceHandler: _presenceHandler,
               
               subscribeNode: _subscribeNode,
               unsubscribeNode: _unsubscribeNode,
               
               getNodeList: function () {
                   return _nodesList;
               },
               setNodeList: function (nodelist) {
                   _nodesList = nodelist;
               },
               
               cloneConnInfoObj: _cloneConnInfoObj,
               connInfoHandler: _connInfoHandler,
               clientRequestHandler: _clientRequestHandler

           };
       };


       /**
        * @ignore
        */
       this.endTestSection = 0;
       //END TEST CODE//

    };
}));
</script><script type="text/javascript">/** The following comment is to prevent jslint errors about 
 * using variables before they are defined.
 */
/*global publisher:true */

/**
 * @fileOverview Exposes a set of API wrappers that will hide the dirty work of
 *     constructing Finesse API requests and consuming Finesse events.
 *
 * @name finesse.clientservices.ClientServices
 * @requires OpenAjax, jQuery 1.5, cbabu.cuic.utilities.Utilities
 */


/**
 * @class
 * Allow clients to make Finesse API requests and consume Finesse events by
 * calling a set of exposed functions. The Services layer will do the dirty
 * work of establishing a shared BOSH connection (for designated Master
 * modules), consuming events for client subscriptions, and constructing API
 * requests.
 */
(function (factory) {
    "use strict";

    // Define as an AMD module if possible
    if ( typeof define === 'function' && define.amd )
    {
        define(["clientservices/MasterTunnel",
                "clientservices/MasterPublisher",
                "clientservices/Topics",
                "utilities/Utilities"], factory );
    }
    
    /* Define using browser globals otherwise
     * Prevent multiple instantiations if the script is loaded twice
     */
    else
    {
        factory(cbabu.cuic.clientservices.MasterTunnel, cbabu.cuic.clientservices.MasterPublisher,cbabu.cuic.clientservices.Topics, cbabu.cuic.utilities.Utilities);
    }
    
}(function (MasterTunnel, MasterPublisher, Topics, Utilities) {
    
    window.cbabu = window.cbabu || {};
    window.cbabu.cuic = window.cbabu.cuic || {};
    window.cbabu.cuic.clientservices = window.cbabu.cuic.clientservices || {};
    
    window.cbabu.cuic.clientservices.ClientServices = (function () {
        var

        /**
         * Shortcut reference to the master tunnel
         * @private
         */
        _tunnel,

        _publisher,

        /**
         * Shortcut reference to the finesse.utilities.Utilities singleton
         * This will be set by init()
         * @private
         */
        _util,

        /**
         * Shortcut reference to the gadgets.io object.
         * This will be set by init()
         * @private
         */
        _io,

        /**
         * Shortcut reference to the gadget pubsub Hub instance.
         * This will be set by init()
         * @private
         */
        _hub,

        /**
         * Logger object set externally by setLogger, defaults to nothing.
         * @private
         */
        _logger = {},

        /**
         * Shortcut reference to the Topics class.
         * This will be set by init()
         * @private
         */
        _topics,

        /**
         * Config object needed to initialize this library
         * This must be set by init()
         * @private
         */
        _config,

        /**
         * @private
         * Whether or not this ClientService instance is a Master.
         */
        _isMaster = false,

        /**
         * @private
         * Whether the Client Services have been initiated yet.
         */
        _inited = false,

        /**
         * Stores the list of subscription IDs for all subscriptions so that it
         * could be retrieve for unsubscriptions.
         * @private
         */
        _subscriptionID = {},
            
        _callbackSubscriptionID = {},

        /**
         * The possible states of the JabberWerx BOSH connection.
         * @private
         */
        _STATUS = {
            CONNECTING: "connecting",
            CONNECTED: "connected",
            RECONNECTED : "reconnected",
            DISCONNECTED: "disconnected",
            DISCONNECTED_CONFLICT: "conflict",
            DISCONNECTED_UNAUTHORIZED: "unauthorized",
            DISCONNECTING: "disconnecting",
            RECONNECTING: "reconnecting",
            UNLOADING: "unloading",
            NETWORK_ERROR:"network_error",
            UNAVAILABLE:"unavailable",
            AVAILABLE:"available"
        },

        /**
         * Handler function to be invoked when BOSH connection is connecting.
         * @private
         */
        _onConnectingHandler = {},

        /**
         * Handler function to be invoked when BOSH connection is connected
         * @private
         */
        _onConnectHandler ={},

        /**
         * Handler function to be invoked when BOSH connection is disconnecting.
         * @private
         */
        _onDisconnectingHandler = {},

        /**
         * Handler function to be invoked when the BOSH is disconnected.
         * @private
         */
        _onDisconnectHandler = {},

        /**
         * Handler function to be invoked when the BOSH is reconnecting.
         * @private
         */
        _onReconnectingHandler={},
        
        /**
         * Handler function to be invoked when the BOSH is unloading.
         * @private
         */
        _onUnloadingHandler={},

        /**
         * Contains a cache of the latest connection info containing the current
         * state of the BOSH connection and the resource ID.
         * @private
         */
        _connInfo,

        /**
         * Keeps track of all the objects that need to be refreshed when we recover
         * due to our resilient connection. Only objects that we subscribe to will
         * be added to this list.
         */
        _refreshList = [],

        _subscribedRooms = {},

        /**
         * @private
         * Centralized logger.log method for external logger
         * @param {String} msg
         *     Message to log
         */
        _log = function (msg) {
            // If the external logger throws up, it stops here.
            try {
                if (_logger.log) {
                    _logger.log("[ClientServices] " + msg);
                }
            } catch (e) { }
        },

        /**
         * Go through each object in the _refreshList and call its refresh() function
         */
        _refreshObjects = function () {
            var i;

            // wipe out the explicit subscription list before we refresh objects
            if (_publisher) {
                _publisher.wipeout();
            }

            // refresh each item in the refresh list
            for (i = _refreshList.length - 1; i >= 0; i -= 1) {
                _log("Refreshing " + _refreshList[i].getRestUrl());
                _refreshList[i].refresh();
            }
        },

        /**
         * Handler to process connection info publishes.
         * @param {Object} data
         *     The connection info data object.
         * @param {String} data.status
         *     The BOSH connection status.
         * @param {String} data.resourceID
         *     The resource ID for the connection.
         * @private
         */
        _connInfoHandler =  function (data) {

            //Invoke registered handler depending on status received. Due to the
            //request topic where clients can make request for the Master to publish
            //the connection info, there is a chance that duplicate connection info
            //events may be sent, so ensure that there has been a state change
            //before invoking the handlers.
            if (_connInfo === undefined || _connInfo.status !== data.status || data.status == "unavailable") {
                _connInfo = data;
                switch (data.status) {
                case _STATUS.CONNECTING:
                    if (_onConnectingHandler) {
                        for(var key in _onConnectingHandler){
                            _onConnectingHandler[key]();
                        }
                        //_onConnectingHandler();
                    }
                    break;
                case _STATUS.CONNECTED:
                    // Whenever we are connected, we need to refresh any objects
                    // that are stored.
                    _refreshObjects();
                    if (_onConnectHandler) {
                        for(var key in _onConnectHandler){
                            _onConnectHandler[key]();
                        }
                    }
                    break;
                case _STATUS.RECONNECTED:
                    // Whenever we are connected, we need to refresh any objects
                    // that are stored.
                    _refreshObjects();
                    _connInfo.status = _STATUS.CONNECTED; // should not process 'connected' from now onwards and should process 'reconnected' every time
                    if (_onConnectHandler) {
                        for(var key in _onConnectHandler){
                            _onConnectHandler[key]();
                        }
                    }
                    break;    
                case _STATUS.DISCONNECTED:
                    if (_onDisconnectHandler) {
                        for(var key in _onDisconnectHandler){
                            _onDisconnectHandler[key](_STATUS.DISCONNECTED);
                        }
                       // _onDisconnectHandler(_STATUS.DISCONNECTED);
                    }
                    break;
                case _STATUS.NETWORK_ERROR:
                    if (_onDisconnectHandler) {
                        for(var key in _onDisconnectHandler){
                            _onDisconnectHandler[key](_STATUS.NETWORK_ERROR);
                        }
                       // _onDisconnectHandler(_STATUS.NETWORK_ERROR);
                    }
                    break;
                case _STATUS.UNAVAILABLE:
                    if (_onDisconnectHandler) {
                        for(var key in _onDisconnectHandler){
                            _onDisconnectHandler[key](_STATUS.UNAVAILABLE);
                        }
                       // _onDisconnectHandler(_STATUS.UNAVAILABLE);
                    }
                    break;
                 case _STATUS.AVAILABLE:
                     if (_onDisconnectHandler) {
                         for(var key in _onDisconnectHandler){
                            _onDisconnectHandler[key](_STATUS.AVAILABLE);
                        }
                        // _onDisconnectHandler(_STATUS.AVAILABLE);
                      }
                     break;    
                case _STATUS.DISCONNECTED_CONFLICT:
                    if (_onDisconnectHandler) {
                        for(var key in _onDisconnectHandler){
                            _onDisconnectHandler[key]("conflict");
                        }
                        //_onDisconnectHandler("conflict");
                    }
                    break;
                case _STATUS.DISCONNECTED_UNAUTHORIZED:
                    if (_onDisconnectHandler) {
                        for(var key in _onDisconnectHandler){
                            _onDisconnectHandler[key]("unauthorized");
                        }
                        //_onDisconnectHandler("unauthorized");
                    }
                    break;
                case _STATUS.DISCONNECTING:
                    if (_onDisconnectingHandler) {
                       for(var key in _onDisconnectingHandler){
                            _onDisconnectingHandler[key]();
                        }
                        //_onDisconnectingHandler();
                    }
                    break;
                case _STATUS.RECONNECTING:
                    if (_onReconnectingHandler) {
                         for(var key in _onReconnectingHandler){
                            _onReconnectingHandler[key]();
                        }
                        //_onReconnectingHandler();
                    }
                    break;
                case _STATUS.UNLOADING:
                    if (_onUnloadingHandler) {
                          for(var key in _onUnloadingHandler){
                            _onUnloadingHandler[key]();
                        }                  
                        //_onUnloadingHandler();
                    }
                    break;
                }
            }
        },

        /**
         * Ensure that ClientServices have been inited.
         * @private
         */
        _isInited = function () {
            if (!_inited) {
                throw new Error("ClientServices needs to be inited.");
            }
        },

        /**
         * Have the client become the Master by initiating a tunnel to a shared
         * event BOSH connection. The Master is responsible for publishing all
         * events to the pubsub infrastructure.
         * @private
         */
        _becomeMaster = function () {
            _tunnel = new MasterTunnel(_config.host, _config.scheme);
            _publisher = new MasterPublisher(_tunnel, _hub);
            _tunnel.init(_config.authorization, _config.socketHost, _config.ldHost, _config.reportId);
            _isMaster = true;
        },

        /**
         * Make a request to the request channel to have the Master publish the
         * connection info object.
         * @private
         */
        _makeConnectionInfoReq = function () {
            var data = {
                type: "ConnectionInfoReq",
                data: {},
                invokeID: (new Date()).getTime()
            };
            _hub.publish(_topics.REQUESTS, data);
        },
        
        _subscribeRoom = function(roomId) {
        	if(_tunnel) {
        		_tunnel.subscribeRoom(roomId);
        	}
        },
       
       /**
        * Invoked when a request for unsubscription to a room is invoked.
        * Sends a unsubscribe request iff the number of subscribers to this
        * topic is 1 (i.e. iff only the last subscriber is sending a request to
        * unsubscribe).
        */
        _unsubscribeRoom = function(roomId) {
            
            if(_tunnel) {

                var roomMap = cbabu.cuic.utilities.Utilities.getIndividualRoomsSubscribed(roomId);
                var unsubscribeFromTunnel = false;

                for(var i = 0 ; i < roomMap.length; i++) {
                    var room = roomMap[i];
                    if(_subscribedRooms[room]) {
                        if(_subscribedRooms[room] === 1) {
                            _tunnel.unsubscribeRoom(room);
                            unsubscribeFromTunnel = true;
                        } else {
                            _subscribedRooms[room] = _subscribedRooms[room] - 1;
                        }
                    }
                }

                if(!unsubscribeFromTunnel) {
                    _hub.publish("cbabu.cuic.map.unsubscription", "");
                }
            }
        },

        /**
         * Callback that is invoked on confirmation of a subscription
         * to a topic. It keeps track of number of subscribers to a given
         * topic.
         */
        _subscribedRoom = function(roomId) {

            var roomMap = cbabu.cuic.utilities.Utilities.getIndividualRoomsSubscribed(roomId), room;
            for(var i = 0 ; i < roomMap.length; i++) {
                room = roomMap[i];
                _subscribedRooms[room] = _subscribedRooms[room] ? _subscribedRooms[room] + 1 : 1;
            }        
        },

        /**
         * Invoked on successful unsubscription from a topic. Cleans-up
         * the subscription tracker object.
         */
        _unsubscribedRoom = function(roomId) {
            if(_subscribedRooms[roomId]) {
                delete _subscribedRooms[roomId];
            }
        },

        /**
         * Utility method to register a handler which is associated with a
         * particular connection status.
         * @param {String} status
         *     The connection status string.
         * @param {Function} handler
         *     The handler to associate with a particular connection status.
         * @throws {Error}
         *     If the handler provided is not a function.
         * @private
         */
        _registerHandler = function (status, handler,id) {
            if (typeof handler === "function") {
                if (_connInfo && _connInfo.status === status) {
                    handler();
                }
                switch (status) {
                case _STATUS.CONNECTING:
                    _onConnectingHandler[id]=handler;
                    break;
                case _STATUS.CONNECTED:
                    _onConnectHandler[id]=handler;
                    break;
                case _STATUS.DISCONNECTED:
                    _onDisconnectHandler[id]=handler;
                    break;
                case _STATUS.DISCONNECTING:
                    _onDisconnectingHandler[id]=handler;
                    break;
                case _STATUS.RECONNECTING:
                    _onReconnectingHandler[id]=handler;
                    break;
                case _STATUS.UNLOADING:
                    _onUnloadingHandler[id]=handler;
                    break;
                }

            } else {
                throw new Error("Callback is not a function");
            }
        };

        return {               
            /**
             * Adds an item to the list to be refreshed upon reconnect
             * @param {RestBase} object - rest object to be refreshed
             */
            addToRefreshList: function (object) {
                _refreshList.push(object);
            },

            /**
             * Removes the given item from the refresh list
             * @param  {RestBase} object - rest object to be removed
             */
            removeFromRefreshList: function (object) {
                var i;
                for (i = _refreshList.length - 1; i >= 0; i -= 1) {
                    if (_refreshList[i] === object) {
                        _refreshList.splice(i, 1);
                        break;
                    }
                }
            },

            /**
             * The location of the tunnel HTML URL.
             * @returns {String}
             *     The location of the tunnel HTML URL.
             */
            getSocketHostArray: function () {
                return _tunnel.getSocketHostArray();            
            },
            
            
            getSocketHostForCertificateAcceptance: function() {
            	return _tunnel.getSocketHostForCertificateAcceptance();
            },
            
            /**
             * This will post token data to socket lib for reconnecting after failover.
             * @returns
             */
            
            postToken : function(data) {
            	if(_tunnel) {
            		_tunnel._postToken(data);
            	}
            },
            
            /**
             * @private
             * Indicates whether the tunnel frame is loaded.
             * @returns {Boolean}
             *     True if the tunnel frame is loaded, false otherwise.
             */
            isTunnelLoaded: function () {
                return _tunnel.isTunnelLoaded();            
            },
            
            
            isSocketHostAvailable: function() {
            	return _tunnel.isSocketHostAvailable();
            },
            
            /**
             * @private
             * Indicates whether the ClientServices instance is a Master.
             * @returns {Boolean}
             *     True if this instance of ClientServices is a Master, false otherwise.
             */
            isMaster: function () {
                return _isMaster;
            },

            /**
             * @private
             * Get the resource ID. An ID is only available if the BOSH connection has
             * been able to connect successfully.
             * @returns {String}
             *     The resource ID string. Null if the BOSH connection was never
             *     successfully created and/or the resource ID has not been associated.
             */
            getResourceID: function () {
                if (_connInfo !== undefined) {
                    return _connInfo.resourceID;
                }
                return null;
            },
            
            /*
            getHub: function () {
                return _hub;
            },
        */
            /**
             * @private
             * Add a callback to be invoked when the BOSH connection is attempting
             * to connect. If the connection is already trying to connect, the
             * callback will be invoked immediately.
             * @param {Function} handler
             *      An empty param function to be invoked on connecting. Only one
             *      handler can be registered at a time. Handlers already registered
             *      will be overwritten.
             */
            registerOnConnectingHandler: function (handler,id) {
                _registerHandler(_STATUS.CONNECTING, handler,id);
            },

            /**
             * @private
             * Removes the on connecting callback that was registered.
             */
            unregisterOnConnectingHandler: function () {
                delete _onConnectingHandler.id;
            },

            /**
             * @private
             * Add a callback to be invoked when the BOSH connection has been
             * established. If the connection has already been established, the
             * callback will be invoked immediately.
             * @param {Function} handler
             *      An empty param function to be invoked on connect. Only one handler
             *      can be registered at a time. Handlers already registered will be
             *      overwritten.
             */
            registerOnConnectHandler: function (handler,id) {
                _registerHandler(_STATUS.CONNECTED, handler,id);
            },

            /**
             * @private
             * Removes the on connect callback that was registered.
             */
            unregisterOnConnectHandler: function (id) {
                delete _onConnectHandler.id;
            },

            /**
             * @private
             * Add a callback to be invoked when the BOSH connection goes down. If
             * the connection is already down, invoke the callback immediately.
             * @param {Function} handler
             *      An empty param function to be invoked on disconnected. Only one
             *      handler can be registered at a time. Handlers already registered
             *      will be overwritten.
             */
            registerOnDisconnectHandler: function (handler,id) {
                _registerHandler(_STATUS.DISCONNECTED, handler,id);
            },

            /**
             * @private
             * Removes the on disconnect callback that was registered.
             */
            unregisterOnDisconnectHandler: function (id) {
                 delete _onDisconnectHandler.id;
            },

            /**
             * @private
             * Add a callback to be invoked when the BOSH is currently disconnecting. If
             * the connection is already disconnecting, invoke the callback immediately.
             * @param {Function} handler
             *      An empty param function to be invoked on disconnected. Only one
             *      handler can be registered at a time. Handlers already registered
             *      will be overwritten.
             */
            registerOnDisconnectingHandler: function (handler,id) {
                _registerHandler(_STATUS.DISCONNECTING, handler,id);
            },

            /**
             * @private
             * Removes the on disconnecting callback that was registered.
             */
            unregisterOnDisconnectingHandler: function (id) {
                 delete _onDisconnectingHandler.id;
            },

            /**
             * @private
             * Add a callback to be invoked when the BOSH connection is attempting
             * to connect. If the connection is already trying to connect, the
             * callback will be invoked immediately.
             * @param {Function} handler
             *      An empty param function to be invoked on connecting. Only one
             *      handler can be registered at a time. Handlers already registered
             *      will be overwritten.
             */
            registerOnReconnectingHandler: function (handler,id) {
                _registerHandler(_STATUS.RECONNECTING, handler,id);
            },

            /**
             * @private
             * Removes the on reconnecting callback that was registered.
             */
            unregisterOnReconnectingHandler: function (id) {
                 delete _onReconnectingHandler.id;
            },
            
            /**
             * @private
             * Add a callback to be invoked when the BOSH connection is unloading
             * 
             * @param {Function} handler
             *      An empty param function to be invoked on connecting. Only one
             *      handler can be registered at a time. Handlers already registered
             *      will be overwritten.
             */
            registerOnUnloadingHandler: function (handler,id) {
                _registerHandler(_STATUS.UNLOADING, handler,id);
            },
            
            /**
             * @private
             * Removes the on unloading callback that was registered.
             */
            unregisterOnUnloadingHandler: function (id) {
                delete _onUnloadingHandler.id;
            },

            /**
             * @private
             * Proxy method for gadgets.io.makeRequest. The will be identical to gadgets.io.makeRequest
             * ClientServices will mixin the BASIC Auth string, locale, and host, since the
             * configuration is encapsulated in here anyways.
             * This removes the dependency
             * @param {String} url
             *     The relative url to make the request to (the host from the passed in config will be
             *     appended). It is expected that any encoding to the URL is already done.
             * @param {Function} handler
             *     Callback handler for makeRequest to invoke when the response returns.
             *     Completely passed through to gadgets.io.makeRequest
             * @param {Object} params
             *     The params object that gadgets.io.makeRequest expects. Authorization and locale
             *     headers are mixed in.
             */
            makeRequest: function (url, handler, params) {
                var requestedScheme, scheme = "http";
                
                // ClientServices needs to be initialized with a config for restHost, auth, and locale
                _isInited();
                
                // Allow mixin of auth and locale headers
                params = params || {};

                // Override refresh interval to 0 instead of default 3600 as a way to workaround makeRequest 
                // using GET http method because then the params are added to the url as query params, which 
                // exposes the authorization string in the url. This is a placeholder until oauth comes in
                params[gadgets.io.RequestParameters.REFRESH_INTERVAL] = params[gadgets.io.RequestParameters.REFRESH_INTERVAL] || 0;
                
                params[gadgets.io.RequestParameters.HEADERS] = params[gadgets.io.RequestParameters.HEADERS] || {};

                var auth = params["auth"] || _config.authorization;
                
                // Add Basic auth to request header
                params[gadgets.io.RequestParameters.HEADERS].Authorization = "Basic " + auth;
                //Locale
                params[gadgets.io.RequestParameters.HEADERS].locale = _config.locale;

                //Allow clients to override the scheme:
                //  - If not specified  => we use HTTP
                //  - If null specified => we use _config.scheme
                //  - Otherwise         => we use whatever they provide
                requestedScheme = params.SCHEME; 
                
                if (!(requestedScheme === undefined || requestedScheme === "undefined")) {
                    if (requestedScheme === null) {
                       scheme = _config.scheme;
                    } else {
                       scheme = requestedScheme;
                    }
                }
                
                _log("RequestedScheme: " + requestedScheme + "; Scheme: " + scheme);
                if(url.indexOf("http") == 0){   
                        this.makeXHRRequest(url, handler, params);
                  }
                else
                        this.makeXHRRequest(encodeURI(scheme + "://" + restHost + ":" + _config.localhostPort) + url, handler, params);
                 },

            makeXHRRequest: function(url, callback, params) {
                var settings = {};
                settings.type = params.METHOD || "GET";
                settings.contentType = 'application/json';
                settings.dataType = 'json';
                settings.xhrFields = {withCredentials: true};
                settings.headers = params.HEADERS || {};
                settings.data = params.POST_DATA || ""
                settings.url = url;
                var response = {};
                $.ajax(settings).done(function(data, textStatus, request) {
                    response.data = JSON.stringify(data);
                    response.rc = request.status;
                    callback(response);
                }).fail(function(err, textStatus, errorThrown) {
                    response.err = err;
                    response.rc = errorThrown.status;
                    // empty responseText indicates the request was aborted, when cors is not enabled
                    if (err.responseText) {
                        response.text = err.responseText;
                    } else {
                        var res = {errorInfo : [{errorDetail : cuicConfig["corsDisabled"]}]};
                        response.text = JSON.stringify(res);
                    }
                    callback(response);
                });
            },

            /**
             * @private
             * Utility function to make a subscription to a particular topic. Only one
             * callback function is registered to a particular topic at any time.
             * @param {String} topic
             *     The full topic name. The topic name should follow the OpenAjax
             *     convention using dot notation (ex: finesse.api.User.1000).
             * @param {Function} callback
             *     The function that should be invoked with the data when an event
             *     is delivered to the specific topic.
             * @returns {Boolean}
             *     True if the subscription was made successfully and the callback was
             *     been registered. False if the subscription already exist, the
             *     callback was not overwritten.
             */
            subscribe: function (topic, callback,id) {
                _isInited();
                var _topic = topic+(id||'');
                //Ensure that the same subscription isn't made twice.
                if (!_subscriptionID[_topic]) {
                    //Store the subscription ID using the topic name as the key.
                    _subscriptionID[_topic] = _hub.subscribe(topic,
                        //Invoke the callback just with the data object.
                        function (topic, data) {
                            callback(data);
                        });
                    return true;
                }
                return false;
            },
            
            
             callBackSubscribe: function (topic, callback,id) {
                _isInited();
                var _topic = topic+(id||'');
                //Ensure that the same subscription isn't made twice.
                if (!_callbackSubscriptionID[_topic]) {
                     _callbackSubscriptionID[_topic] = callback;
                    //Store the subscription ID using the topic name as the key.
                    _hub.subscribe(topic,
                        //Invoke the callback just with the data object.
                        function (topic, data) {
                            for(var k in _callbackSubscriptionID){
                               _callbackSubscriptionID[k](data);   
                            }
                        });
                    return true;
                }
                return false;
            },
            
            
            publish: function (topic, message, isNoNamespace) {
                _isInited();
                _hub.publish(topic, message, isNoNamespace);
            },
            
            /**
             * @private
             * Unsubscribe from a particular topic.
             * @param {String} topic
             *     The full topic name.
             */
            unsubscribe: function (topic) {
                _isInited();

                //Unsubscribe from the topic using the subscription ID recorded when
                //the subscription was made, then delete the ID from data structure.
                if (_subscriptionID[topic]) {
                    _hub.unsubscribe(_subscriptionID[topic]);
                    delete _subscriptionID[topic];
                }
            },

            /**
             * @private
             * Make a request to the request channel to have the Master subscribe
             * to a node.
             * @param {String} node
             *     The node to subscribe to.
             */
            subscribeNode: function (node, handler) {
                if (handler && typeof handler !== "function") {
                    throw new Error("ClientServices.subscribeNode: handler is not a function");
                }
                
                // Construct the request to send to MasterPublisher through the OpenAjax Hub
                var data = {
                    type: "SubscribeNodeReq",
                    data: {node: node},
                    invokeID: _util.generateUUID()
                },
                responseTopic = _topics.RESPONSES + "." + data.invokeID,
                _this = this;

                // We need to first subscribe to the response channel
                this.subscribe(responseTopic, function (rsp) {
                    // Since this channel is only used for this singular request,
                    // we are not interested anymore.
                    // This is also critical to not leaking memory by having OpenAjax
                    // store a bunch of orphaned callback handlers that enclose on
                    // our entire ClientServices singleton
                    _this.unsubscribe(responseTopic);
                    if (handler) {
                        handler(data.invokeID, rsp);
                    }
                });
                // Then publish the request on the request channel
                _hub.publish(_topics.REQUESTS, data);
            },

            /**
             * @private
             * Make a request to the request channel to have the Master unsubscribe
             * from a node.
             * @param {String} node
             *     The node to unsubscribe from.
             */
            unsubscribeNode: function (node, subid, handler) {
                if (handler && typeof handler !== "function") {
                    throw new Error("ClientServices.unsubscribeNode: handler is not a function");
                }
                
                // Construct the request to send to MasterPublisher through the OpenAjax Hub
                var data = {
                    type: "UnsubscribeNodeReq",
                    data: {
                        node: node,
                        subid: subid
                    },
                    invokeID: _util.generateUUID()
                },
                responseTopic = _topics.RESPONSES + "." + data.invokeID,
                _this = this;

                // We need to first subscribe to the response channel
                this.subscribe(responseTopic, function (rsp) {
                    // Since this channel is only used for this singular request,
                    // we are not interested anymore.
                    // This is also critical to not leaking memory by having OpenAjax
                    // store a bunch of orphaned callback handlers that enclose on
                    // our entire ClientServices singleton
                    _this.unsubscribe(responseTopic);
                    if (handler) {
                        handler(rsp);
                    }
                });
                // Then publish the request on the request channel
                _hub.publish(_topics.REQUESTS, data);
            },
            
            /**
             * @private
             * Make a request to the request channel to have the Master connect to the XMPP server via BOSH
             */
            makeConnectionReq : function () {
                var data = {
                    type: "ConnectionReq",
                    data: {
                        id: _config.id,
                        password: _config.password,
                        socketHost: _config.socketHost
                    },
                    invokeID: (new Date()).getTime()
                };
                _hub.publish(_topics.REQUESTS, data);
            },
        
            /**
             * Set's the global logger for this Client Services instance.
             * @param {Object} logger
             *     Logger object with the following attributes defined:<ul>
             *         <li><b>log:</b> function (msg) to simply log a message
             *     </ul>
             */
            setLogger: function (logger) {
                // We want to check the logger coming in so we don't have to check every time it is called.
                if (logger && typeof logger === "object" && typeof logger.log === "function") {
                    _logger = logger;
                } else {
                    // We are resetting it to an empty object so that _logger.log in .log is falsy.
                    _logger = {};
                }
            },
            
            /**
             * @private
             * Centralized logger.log method for external logger
             * @param {String} msg
             *     Message to log
             */
            log: _log,

            /**
             * Initiates the Client Services with the specified config parameters.
             * Enabling the Client Services as Master will trigger the establishment
             * of a BOSH event connection.
             * @param {Object} config
             *     Configuration object containing properties used for making REST requests:<ul>
             *         <li><b>host:</b> The Finesse server IP/host as reachable from the browser
             *         <li><b>restHost:</b> The Finesse API IP/host as reachable from the gadget container
             *         <li><b>id:</b> The ID of the user. This is an optional param as long as the
             *         appropriate authorization string is provided, otherwise it is
             *         required.</li>
             *         <li><b>password:</b> The password belonging to the user. This is an optional param as
             *         long as the appropriate authorization string is provided,
             *         otherwise it is required.</li>
             *         <li><b>authorization:</b> The base64 encoded "id:password" authentication string. This
             *         param is provided to allow the ability to hide the password
             *         param. If provided, the id and the password extracted from this
             *         string will be used over the config.id and config.password.</li>
             *     </ul>
             * @throws {Error} If required constructor parameter is missing.
             */
            init: function (config) {
                if (!_inited) {
                    //Validate the properties within the config object if one is provided.
                   

                    // Initialize configuration
                    _config = config;

                    // Set shortcuts
                    _util = Utilities;
                    _topics = Topics;
                    
                    //TODO: document when this is properly supported
                    // Allows hub and io dependencies to be passed in. Currently only used for unit tests.
                    _hub = config.hub || gadgets.Hub;
                    _io = config.io || gadgets.io;

                    //If the authorization string is provided, then use that to
                    //extract the ID and the password. Otherwise use the ID and
                    //password from the respective ID and password params.
                    if (_config.authorization) {
                        var creds = _util.getCredentials(_config.authorization);
                        _config.id = creds.id;
                        _config.password = creds.password;
                    }
                    else {
                        _config.authorization = _util.b64Encode(
                                _config.id + ":" + _config.password);
                    }

                    _inited = true;

                    if (_hub) {
                        //Subscribe to receive connection information. Since it is possible that
                        //the client comes up after the Master comes up, the client will need
                        //to make a request to have the Master send the latest connection info.
                        //It would be possible that all clients get connection info again.
                        this.subscribe(_topics.EVENTS_CONNECTION_INFO, _connInfoHandler);
                        _makeConnectionInfoReq();
                    }
                }

                //Return the CS object for object chaining.
                return this;
            },

            /**
             * @private
             * Initializes the BOSH component of this ClientServices instance. This establishes
             * the BOSH connection and will trigger the registered handlers as the connection
             * status changes respectively:<ul>
             *     <li>registerOnConnectingHandler</li>
             *     <li>registerOnConnectHandler</li>
             *     <li>registerOnDisconnectHandler</li>
             *     <li>registerOnDisconnectingHandler</li>
             *     <li>registerOnReconnectingHandler</li>
             *     <li>registerOnUnloadingHandler</li>
             * <ul>
             *
             * @param {Object} config
             *     An object containing the following (optional) handlers for the request:<ul>
             *         <li><b>socketHost:</b> {String} The domain of the XMPP server. Available from the SystemInfo object.
             *         This is used to construct the JID: user@domain.com</li>
             *         <li><b>pubsubDomain:</b> {String} The pub sub domain where the pub sub service is running.
             *         Available from the SystemInfo object.
             *         This is used for creating or removing subscriptions.</li>
             *         <li><b>resource:</b> {String} The resource to connect to the notification server with.</li>
             *     </ul>
             */
            initBosh: function (config) {
                //Validate the properties within the config object if one is provided.
                if (!(typeof config === "object" && typeof config.socketHost === "object")) {
                    throw new Error("Config object contains invalid properties.");
                }
                
                // Mixin the required information for establishing the BOSH connection
                _config.socketHost = config.socketHost;
                // Adding viewId to config for getting token
                _config.viewId = config.reportId;
                
                //Initiate Master launch sequence
                _becomeMaster();
                this.subscribe("SUBSCRIBE_ROOM", _subscribeRoom);
                this.subscribe("UNSUBSCRIBE_ROOM",_unsubscribeRoom);
                this.subscribe('cbabu.cuic.subscribed.client.call', _subscribedRoom, Math.random());
                this.subscribe('cbabu.cuic.unsubscribed.client.call', _unsubscribedRoom, Math.random());
            },
            
            getTunnel: function() {
            	return _tunnel;
            },

            /**
             * @private
             * Private accessor used to inject mocked private dependencies for unit testing
             */
            _getTestObj: function () {
                return {
                    setPublisher: function (publisher) {
                        _publisher = publisher;
                    }
                };
            }
        };
    }());
}));
</script><script type="text/javascript"> var tunnelCreated = false;
    var _TUNNEL_LOADING_TIMEOUT = 20000;
    var isFF = window.all ? false : true;
    var _tunnelLoadingTimeoutId = null;
    var tunnelSecurityWindowRef = null;
    var pollTunnelSecurityWindowCloseId = null;
    var _TUNNEL_SECURITY_WINDOW_CLOSE_POLL_INTERVAL = 1000;
    var _req = {};
    var _hub = null;
    var repServiceDownMsg = '<spring:message code="reportingServiceDown" javaScriptEscape="true" text="reportingServiceDown undef" />';
    //Lazy initialization, the tunnel should be created only when the first real time report is run.
    //One node should be in openfire, to which all clients should be listening for connect and disconnect events of tunnel
    //If when a report runs it will check if the connection is not available then goes and creates the connection.
    function createTunnel(config) {

        if (!cbabu || tunnelCreated == true) {
            return;
        }

        try {
            cbabu.cuic.clientservices.ClientServices.init(config);
        } catch (error) {
            console.log("Error while initializing the client services in Main.htmx::" + error.toString());
            return;
        }

        try {
            // To handle the situation where the tunnel iframe is not loaded
            // properly when using Firefox with HTTPS due to certificate issues.
            /*_tunnelLoadingTimeoutId = setTimeout(
  		                _tunnelLoadingTimeoutCallback, _TUNNEL_LOADING_TIMEOUT);
  			    */
            cbabu.cuic.clientservices.ClientServices.initBosh(config);
            tunnelCreated = true;
        } catch (error) {
            console.log("Error while intializing the bosh connection:" + error.toString());
            return;
        }
    }


    /**
     * Callback for when the tunnel iframe is not loaded within a reasonable amount of time.
     * @private
     */
    var _tunnelLoadingTimeoutCallback = function () {
        if (_tunnelLoadingTimeoutId == true) {
            return;
        }
        _tunnelLoadingTimeoutId = true;
        // When using HTTPS in Firefox with a self-signed certificate, upon loading the tunnel URL, 
        // our tunnel iframe presents a self-signed certificate which is unaccessible because the 
        // tunnel iframe is hidden on the Agent Desktop. As a result, the Agent Desktop fails to 
        // load because there is no way to accept the self-signed certificate.
        var socketHostArr = cbabu.cuic.clientservices.ClientServices.getSocketHostForCertificateAcceptance();
        if (socketHostArr && socketHostArr.length > 0) {
            var msg = ccbu.commondesktop.LocaleService.getLocalizedString('RTR.Notification.SecurityException');
            _openTunnelSecurityURLViaHTTPS(socketHostArr, msg);
            _cancelTimers();
        }
        else{
             _tunnelLoadingTimeoutId = setTimeout(
  		                _tunnelLoadingTimeoutCallback, _TUNNEL_LOADING_TIMEOUT);
        }
    }

    /**
     * Open the tunnel security page.
     * @private
     */
    var _openTunnelSecurityURLViaHTTPS = function (socketHostArray, msg) {
        if (window.location.protocol.indexOf("https") == -1 || !socketHostArray) {
            _topicPublish("cuic_datasource_online_check", false);
            return;
        }
        var socketHostStr = "";
        for (var i = 0; i < socketHostArray.length; i++) {
            if (i > 0) {
                socketHostStr = socketHostStr.concat(", ");
            }
            socketHostStr = socketHostStr.concat(socketHostArray[i]);
        }
        msg = msg.replace("{0}", socketHostStr);
        var r = confirm(msg);
        if (r == false) {
            _topicPublish("cuic_datasource_online_check", false);
            setTimeout(function () {
                _tunnelLoadingTimeoutId = false;
            }, 20000);
            return;
        }
        var tunnelSecurityURL = [];
        var tunnelSecurityWindowRef = [];
        var popoutAllowed = true;
        for (var i = 0; i < socketHostArray.length; i++) {

            tunnelSecurityURL.push(location.protocol + "//" + socketHostArray[i] + "/security");

            var popwin = window.open(tunnelSecurityURL[i]);
            if (!popwin) { // if popwin is undefined or null means, popout has been blocked by the browser. Need to first accept allow the popouts for the current url.
                console.log("Cannot launch popout for '" + tunnelSecurityURL[i] + "'. It might have been blocked by the browser.");
                popoutAllowed = false;
            }
            tunnelSecurityWindowRef.push(popwin);

        }

        if (popoutAllowed == false) {
            _topicPublish("cuic_datasource_online_check", false);
            return;
        }

        var pollTunnelSecurityWindowCloseId = setInterval(function () {
            for (var i = 0; i < socketHostArray.length; i++) {
                if (tunnelSecurityWindowRef && tunnelSecurityWindowRef[i] && tunnelSecurityWindowRef[i].closed != true) {
                    return;
                }
            }
            if (pollTunnelSecurityWindowCloseId) {
                _topicPublish("cuic_datasource_online_check", true);
                setTimeout(function () {
                    _tunnelLoadingTimeoutId = false;
                }, 20000);
                clearInterval(pollTunnelSecurityWindowCloseId);
            }
            //window.location.reload();
        }, _TUNNEL_SECURITY_WINDOW_CLOSE_POLL_INTERVAL);
    }

    var _topicPublish = function (topic, data) {
        if (!this._hub) {
            _hub = window.top.OpenAjax.hub;
        }
        this._hub.publish(topic, data);
    }

    /**
     * Cancel all timers and pollers associated with showing error messages.
     * @private
     */
    var _cancelTimers = function () {
        //clearTimeout(_tunnelLoadingTimeoutId);
    };</script></head>

<body class="js-focus-visible"><div id="spinner"><div class="spinner-xl-RhGAw flex align-item-center justify-content-ce absolute height100 width100 overlay top-z-index hidden"><div class="spinner-spinner-37uMm "></div></div></div><div id="toaster_box"><div class="ft-sz-14 flex flex-col align-item-end fixed toaster-toaster-2jm1M"></div></div>
	<div id="react-workspace"><div name="_Webapp0"></div></div>
	<div id="main-div"><div class="header"><div id="cd-logo" class="header-left-div " style="width: 420px;"><div class="flex align-item-center"><svg focusable="false" version="1.1" xmlns="http://www.w3.org/2000/svg" height="1000" width="1843.8" viewBox="0 0 1843.8 1000" fill="#049FD9" style="height: 32px; width: 100px;"><path d="M530.8 971.7h78.6V657.3h-78.6v314.4zM178.2 810.6c0 100.2 73.3 161.1 162.4 161.1 35.4 0 62.4-8.4 72.2-11.1v-83.5c-3.4 1.9-29.3 16.5-66.5 16.5-52.8 0-82-36.8-82-83 0-47.7 30.7-83 82-83 37.9 0 63.4 15 66.5 16.7v-83.5c-7.4-2.2-35-11.2-72.2-11.2-96.4 0-162.4 68.1-162.4 161zm826.8 0c0 100.2 81.8 161.1 170.9 161.1 35.2 0 62.3-8.4 72.2-11.1v-83.5c-3.5 1.9-29.4 16.5-66.7 16.5-52.7 0-90.3-36.8-90.3-83 0-47.7 39.1-83 90.3-83 38 0 63.5 15 66.7 16.7v-83.5c-7.5-2.2-35-11.2-72.2-11.2-96.5 0-170.9 68.1-170.9 161zm406.9 0c0-45.2 34.9-81.8 81.9-81.8 46.9 0 82 36.6 82 81.8 0 45.2-35.1 81.8-82 81.8-47 0-81.9-36.6-81.9-81.8zm-83.9 0c0 88.9 69.3 161.1 165.9 161.1 96.5 0 165.9-72.1 165.9-161.1 0-88.8-69.4-161-165.9-161-96.6 0-165.9 72.1-165.9 161zm-616-63.8c0 51.5 36.8 77.1 80.9 91 4.9 1.5 12.1 3.8 16.9 5.4 19.6 6.1 35.3 15.1 35.3 30.9 0 17.7-23.2 29.1-62.6 29.1-34.6 0-67.9-9.8-74.8-11.6v71.6c3.9.8 43.3 8.5 85.5 8.5 60.6 0 135.1-26.3 135.1-104.4 0-37.8-23.5-72.8-74.8-89l-21.9-6.8c-13-4.1-36.3-10.7-36.3-29.7 0-14.9 15.2-25.5 47-25.5 27.4 0 60.8 9.2 61.9 9.5v-66.4c-2.4-.6-38.6-9.9-77.2-9.9-73 0-115 39.1-115 97.3zM19.8 319.6c0-23 13.9-41.6 36.9-41.6s41.7 18.7 41.7 41.6v97.2c0 23-18.7 41.5-41.7 41.5s-36.9-18.6-36.9-41.5v-97.2zm854.9 0c0-23 21.2-41.6 44.2-41.6s44.2 18.7 44.2 41.6v97.2c0 23-21.2 41.5-44.2 41.5s-44.2-18.6-44.2-41.5v-97.2zm864.7 0c0-23 18.7-41.6 41.7-41.6s37 18.7 37 41.6v97.2c0 23-13.9 41.5-37 41.5s-41.7-18.6-41.7-41.5v-97.2zM1307.1 69.9c0-23 22.8-41.6 45.8-41.6s42.6 18.7 42.6 41.6v416.2c0 23-19.6 41.6-42.6 41.6s-45.8-18.7-45.8-41.6V69.9zm-864.8 0c0-23 22.8-41.6 45.8-41.6s42.6 18.7 42.6 41.6v416.2c0 23-19.6 41.6-42.6 41.6s-45.8-18.7-45.8-41.6V69.9zM226.1 208.7c0-23 21.7-41.6 44.7-41.6s43.7 18.6 43.7 41.6v208.1c0 23-20.7 41.6-43.7 41.6s-44.7-18.7-44.7-41.6V208.7zm432.4 0c0-23 23.3-41.6 46.3-41.6s42.2 18.6 42.2 41.6v208.1c0 23-19.2 41.6-42.2 41.6s-46.3-18.7-46.3-41.6V208.7zm432.4 0c0-23 19.1-41.6 42.1-41.6s46.3 18.6 46.3 41.6v208.1c0 23-23.2 41.6-46.3 41.6s-42.1-18.7-42.1-41.6V208.7zm432.4 0c0-23 20.7-41.6 43.7-41.6s44.7 18.6 44.7 41.6v208.1c0 23-21.7 41.6-44.7 41.6s-43.7-18.7-43.7-41.6V208.7z"></path></svg><span class="pad-left-1r font-20px">Cisco Unified Intelligence Center</span></div></div><div id="identity_gadget" class="header-right-div " style="width: 235px;"><div id="remote_iframe_0_userPrefsDialog" class="gadgets-gadget-user-prefs-dialog"></div><div class="gadgets-gadget-content"><iframe id="remote_iframe_0" name="remote_iframe_0" class="gadgets-gadget" src="about:blank" frameborder="no" scrolling="no" height="100%" width="100%"></iframe></div></div></div><div id="bodyDiv" class="body-div"><div id="leftNav"><div role="navigation" aria-label="Menu bar" tabindex="0" class="cd-nav "><button tabindex="0" id="up-arrow-section" aria-label="Scroll Up"><svg focusable="false" version="1.1" xmlns="http://www.w3.org/2000/svg" height="1000" width="1531.3" viewBox="0 0 1531.3 1000" fill="#fff" style="height: 21px; width: 35px;"><path d="M570.2 640.4c-17.2 0-23-10.7-12.8-23.7l192.1-247.3c10.2-13.1 26.8-13.1 37 0l192.1 247.3c10.2 13.1 4.5 23.7-12.7 23.7H570.2z"></path></svg></button><div class="cd-nav-item level0 w-100 "><ul role="menubar" aria-label="Menu bar" id="leftNavUl" class="w-130"><li class="w-100 "><a href="#/home" role="menuitem" class="w-100 pd-r-0" title="Home" target="_self"><i tabindex="-1" class="icon icon-dim flex align-item-center justify-content-ce"><svg focusable="false" version="1.1" xmlns="http://www.w3.org/2000/svg" height="1000" width="1000" viewBox="0 0 1000 1000" fill="#fff" style="height: 25px; width: 25px;"><path d="M125 375v583.3c0 23 18.7 41.7 41.7 41.7h229.1V604.2h208.4V1000h229.1c23 0 41.7-18.7 41.7-41.7V375L500 0 125 375z"></path></svg></i><span>Home</span></a></li><li class="w-100 "><a href="#/dashboards" role="menuitem" class="w-100 pd-r-0" title="Dashboards" target="_self"><i tabindex="-1" class="icon icon-dim flex align-item-center justify-content-ce"><svg focusable="false" version="1.1" xmlns="http://www.w3.org/2000/svg" height="1000" width="1000" viewBox="0 0 1000 1000" fill="#fff" style="height: 25px; width: 25px;"><path d="M500 125C223.9 125 0 349.7 0 626.9 0 718.6 21.1 801.1 63.8 875h872.4c42.7-73.9 63.8-156.4 63.8-248.1C1000 349.7 776.1 125 500 125zm46.3 573.4c-35.5 20.5-80.9 8.3-101.3-27.2-3.5-6-5.7-12.4-7.4-18.8L327.1 368.2l42.8-24.7 190.8 237.8c4.8 4.7 9.2 9.7 12.7 15.9 20.5 35.5 8.3 80.8-27.1 101.3z"></path></svg></i><span>Dashboards</span></a></li><li class="active w-100 "><a href="#/reports" role="menuitem" class="w-100 pd-r-0" title="Reports" target="_self"><i tabindex="-1" class="icon icon-dim flex align-item-center justify-content-ce"><svg focusable="false" version="1.1" xmlns="http://www.w3.org/2000/svg" height="1000" width="1000" viewBox="0 0 1000 1000" fill="#fff" style="height: 25px; width: 25px;"><path d="M791.7 0H208.3c-22.9 0-41.6 18.8-41.6 41.7v916.6c0 23 18.7 41.7 41.6 41.7h583.4c22.9 0 41.6-18.7 41.6-41.7V41.7c0-22.9-18.7-41.7-41.6-41.7zM458.3 729.2h-125c-23 0-41.6-18.7-41.6-41.7s18.6-41.7 41.6-41.7h125c23 0 41.7 18.7 41.7 41.7s-18.7 41.7-41.7 41.7zm208.4-187.5H333.3c-23 0-41.6-18.7-41.6-41.7s18.6-41.7 41.6-41.7h333.4c23 0 41.6 18.7 41.6 41.7s-18.6 41.7-41.6 41.7zm0-187.5H333.3c-23 0-41.6-18.7-41.6-41.7s18.6-41.7 41.6-41.7h333.4c23 0 41.6 18.7 41.6 41.7s-18.6 41.7-41.6 41.7z"></path></svg></i><span>Reports</span></a></li><li class="w-100 "><a href="#/reportdefinitions" role="menuitem" class="w-100 pd-r-0" title="Report Definitions" target="_self"><i tabindex="-1" class="icon icon-dim flex align-item-center justify-content-ce"><svg focusable="false" version="1.1" xmlns="http://www.w3.org/2000/svg" height="64" width="64" viewBox="0 0 64 64" fill="#fff" style="height: 25px; width: 25px;"><g id="Alert_Badge"> </g> <g id="Circle_Bar_Chart"> </g> <g id="Care_Filled"> </g> <g id="Circle_Care"> </g> <g id="Circle_Column_Chart"> </g> <g id="Circle_Gauge"> </g> <g id="Circle_Line_Chart"> </g> <g id="Circle_Note"> </g> <g id="Circle_Pie_Chart"> </g> <g id="Dashboard"> </g> <g id="Edit_Time"> </g> <g id="Error_Badge"> </g> <g id="Node"> </g> <g id="Recent"> </g> <g id="Report_Definition"> <g> <circle cx="9.454" cy="9.455" r="3.636"></circle> <path d="M61.091,0H2.909C1.31,0,0,1.31,0,2.909v16h64v-16C64,1.31,62.689,0,61.091,0z M9.454,13.091 c-2.008,0-3.636-1.628-3.636-3.636c0-2.01,1.628-3.637,3.636-3.637c2.009,0,3.637,1.627,3.637,3.637 C13.091,11.463,11.463,13.091,9.454,13.091z"></path> <path d="M42,64h19.091C62.689,64,64,62.689,64,61.091v-16h-7.532C56.805,46.339,57,47.646,57,49 C57,57.284,50.286,64,42,64z"></path> <path d="M27,49c0-1.354,0.196-2.661,0.532-3.909H0v16C0,62.689,1.31,64,2.909,64H42C33.717,64,27,57.284,27,49z"></path> <path d="M0,39.271h30.595C33.346,36.05,37.432,34,42,34c4.57,0,8.654,2.05,11.406,5.271H64V24.727H0V39.271z"></path> <path d="M36.342,52.674c0.494,0.503,0.494,1.312-0.002,1.812c-0.492,0.498-1.293,0.498-1.787-0.002l-5.41-5.482 l5.412-5.486c0.492-0.498,1.293-0.5,1.785,0c0.248,0.25,0.373,0.577,0.373,0.905s-0.123,0.656-0.369,0.905l-3.627,3.676 L36.342,52.674z"></path> <path d="M45.1,44.938l-3.947,9.158c-0.276,0.647-1.023,0.939-1.666,0.655c-0.32-0.144-0.555-0.401-0.676-0.708 c-0.119-0.305-0.123-0.654,0.016-0.979l3.947-9.162c0.277-0.644,1.021-0.938,1.666-0.652c0.319,0.145,0.556,0.402,0.674,0.708 C45.234,44.264,45.236,44.614,45.1,44.938z"></path> <path d="M49.445,54.484c-0.494,0.5-1.295,0.5-1.789,0.002c-0.494-0.502-0.494-1.311,0-1.812l3.625-3.672 l-3.625-3.676c-0.248-0.249-0.371-0.574-0.371-0.905c0-0.325,0.123-0.653,0.371-0.905c0.494-0.5,1.295-0.498,1.787,0l5.414,5.486 L49.445,54.484z"></path> </g> </g> <g id="Social"> </g> <g id="Web"> </g></svg></i><span>Report Definitions</span></a></li><li class="w-100 "><a href="#/vl" role="menuitem" class="w-100 pd-r-0" title="Value Lists" target="_self"><i tabindex="-1" class="icon icon-dim flex align-item-center justify-content-ce"><svg focusable="false" version="1.1" xmlns="http://www.w3.org/2000/svg" height="1000" width="1000" viewBox="0 0 1000 1000" fill="#fff" style="height: 25px; width: 25px;"><path d="M333.3 187.5h583.4c23 0 41.6-18.7 41.6-41.7s-18.6-41.6-41.6-41.6H333.3c-23 0-41.6 18.6-41.6 41.6s18.6 41.7 41.6 41.7zm583.4 625H333.3c-23 0-41.6 18.7-41.6 41.7s18.6 41.6 41.6 41.6h583.4c23 0 41.6-18.6 41.6-41.6s-18.6-41.7-41.6-41.7zm0-354.2H333.3c-23 0-41.6 18.7-41.6 41.7s18.6 41.7 41.6 41.7h583.4c23 0 41.6-18.7 41.6-41.7s-18.6-41.7-41.6-41.7zM208.3 145.8c0 46.1-37.3 83.4-83.3 83.4s-83.3-37.3-83.3-83.4c0-46 37.3-83.3 83.3-83.3s83.3 37.3 83.3 83.3zm0 354.2c0 46-37.3 83.3-83.3 83.3S41.7 546 41.7 500 79 416.7 125 416.7s83.3 37.3 83.3 83.3zm0 354.2c0 46-37.3 83.3-83.3 83.3s-83.3-37.3-83.3-83.3c0-46.1 37.3-83.4 83.3-83.4s83.3 37.3 83.3 83.4z"></path></svg></i><span>Value Lists</span></a></li><li class="w-100 folder "><button title="Configure" class="w-100 pd-r-0"><i tabindex="-1" class="icon icon-dim flex align-item-center justify-content-ce"><svg focusable="false" version="1.1" xmlns="http://www.w3.org/2000/svg" height="1000" width="1000" viewBox="0 0 1000 1000" fill="#fff" style="height: 25px; width: 25px;"><path d="M1000 542v-83.3l-208.3-69.6c-2.2-5.7-4.5-11.4-7-16.9l98.6-196.1-58.9-58.9-196.8 98.2c-5.4-2.4-10.9-4.6-16.5-6.8L541.7.4h-83.4l-69.5 208.2c-5.5 2.2-11 4.3-16.5 6.8L176 117.2l-58.9 58.9 98.1 196.2c-2.5 5.4-4.7 10.9-6.9 16.6L-.1 458.7V542L208 611.1c2.2 5.7 4.4 11.3 6.9 16.9l-97.8 196.4 59 58.9 195.7-98.2c5.5 2.5 11.2 4.8 17 7l69.4 207.5h83.4l68.8-207.3c6-2.2 11.8-4.6 17.6-7.2l195.8 97.7 58.9-59-98-195.4c2.6-5.8 4.9-11.6 7.2-17.5l208-68.9zM500 729.5c-126.6 0-229.2-102.6-229.2-229.1S373.4 271.2 500 271.2s229.1 102.6 229.1 229.2S626.5 729.5 500 729.5z"></path></svg></i><span>Configure</span></button><div class="cd-nav-item "><ul><li class=" "><a href="#/userpermissions" title="Permissions" target="_self"><span>Permissions</span></a></li><li class=" "><a href="#/users" title="Users" target="_self"><span>Users</span></a></li><li class=" "><a href="#/groups" title="Groups" target="_self"><span>Groups</span></a></li><li class=" "><a href="#/datasources" title="Data Sources" target="_self"><span>Data Sources</span></a></li></ul></div></li><li class="w-100 "><a href="#/schedulers" role="menuitem" class="w-100 pd-r-0" title="Schedules" target="_self"><i tabindex="-1" class="icon icon-dim flex align-item-center justify-content-ce"><svg focusable="false" version="1.1" xmlns="http://www.w3.org/2000/svg" height="1000" width="1000" viewBox="0 0 1000 1000" fill="#fff" style="height: 25px; width: 25px;"><path d="M500 0C223.9 0 0 223.9 0 500s223.9 500 500 500 500-223.9 500-500S776.1 0 500 0zm133.6 675.3c-8.1 8.1-18.8 12.2-29.4 12.2s-21.3-4.1-29.5-12.2L458.3 558.9V291.7c0-23 18.7-41.7 41.7-41.7s41.7 18.7 41.7 41.7v232.7l91.9 92c16.3 16.2 16.3 42.6 0 58.9z"></path></svg></i><span>Schedules</span></a></li></ul></div><button tabindex="0" id="down-arrow-section" aria-label="Scroll Down" style="display: none;" class="down-arrow-top-34px"><svg focusable="false" version="1.1" xmlns="http://www.w3.org/2000/svg" height="1000" width="1531.3" viewBox="0 0 1531.3 1000" fill="#fff" style="height: 21px; width: 35px;"><path d="M965.8 359.6c17.3 0 23 10.7 12.8 23.7L786.5 630.6c-10.2 13.1-26.8 13.1-37 0L557.4 383.3c-10.1-13-4.4-23.7 12.8-23.7h395.6z"></path></svg></button><button class="knob-container l-knob z-5 disp_none right-80 " aria-pressed="true" aria-label="Show / Hide Menu bar"><div class="knob"></div></button></div></div><div id="contentArea" style="position: relative;"><div id="alert-banner-top"></div><div id="alert-banner"></div><div style="opacity: 1; height: 100%;"><div class="cd-grid-layout" style="height: 100%; width: 100%;"><div class="cd-grid-item display-none" style="height: 100%; width: 100%;"><div class="style-cd-gadget-card-1EIH- cd-gadget display-none" id="home_gadget" data-group-id="1" style="height: 100%;"><div id="remote_iframe_1_userPrefsDialog" class="gadgets-gadget-user-prefs-dialog"></div><div class="gadgets-gadget-content"><iframe id="remote_iframe_1" name="remote_iframe_1" class="gadgets-gadget" src="about:blank" frameborder="no" scrolling="no" height="100%" width="100%"></iframe></div></div></div><div class="cd-grid-item display-none" style="height: 100%; width: 100%;"><div class="style-cd-gadget-card-1EIH- cd-gadget display-none" id="dashboard_gadget" data-group-id="2" style="height: 100%;"><div id="remote_iframe_2_userPrefsDialog" class="gadgets-gadget-user-prefs-dialog"></div><div class="gadgets-gadget-content"><iframe id="remote_iframe_2" name="remote_iframe_2" class="gadgets-gadget" src="about:blank" frameborder="no" scrolling="no" height="100%" width="100%"></iframe></div></div></div><div class="cd-grid-item " style="height: 100%; width: 100%;"><div class="style-cd-gadget-card-1EIH- cd-gadget " id="report_gadget" data-group-id="3" style="height: 100%;"><div id="remote_iframe_3_userPrefsDialog" class="gadgets-gadget-user-prefs-dialog"></div><div class="gadgets-gadget-content"><iframe id="remote_iframe_3" name="remote_iframe_3" class="gadgets-gadget" src="about:blank" frameborder="no" scrolling="no" height="100%" width="100%"></iframe></div></div></div><div class="cd-grid-item display-none" style="height: 100%; width: 100%;"><div style="height: 100%;"><iframe src="about:blank" aria-hidden="true" tabindex="-1" frameborder="0" style="display: block; opacity: 0; position: absolute; top: 0px; left: 0px; height: 100%; width: 100%; overflow: hidden; pointer-events: none; z-index: -1;"></iframe><div class="style-cd-gadget-card-2JKXD cd-gadget display-none" id="report_definition_component" data-group-id="4" style="height: 100%;"><iframe class="componentFrame" src="/cuicui/components/index.html?dev=false&amp;page=rd"></iframe></div></div></div><div class="cd-grid-item display-none" style="height: 100%; width: 100%;"><div style="height: 100%;"><iframe src="about:blank" aria-hidden="true" tabindex="-1" frameborder="0" style="display: block; opacity: 0; position: absolute; top: 0px; left: 0px; height: 100%; width: 100%; overflow: hidden; pointer-events: none; z-index: -1;"></iframe><div class="style-cd-gadget-card-2JKXD cd-gadget display-none" id="vl_component" data-group-id="5" style="height: 100%;"><iframe class="componentFrame" src="/cuicui/components/index.html?dev=false&amp;page=vl"></iframe></div></div></div><div class="cd-grid-item display-none" style="height: 100%; width: 100%;"><div style="height: 100%;"><iframe src="about:blank" aria-hidden="true" tabindex="-1" frameborder="0" style="display: block; opacity: 0; position: absolute; top: 0px; left: 0px; height: 100%; width: 100%; overflow: hidden; pointer-events: none; z-index: -1;"></iframe><div class="style-cd-gadget-card-2JKXD cd-gadget display-none" id="userpermissions_component" data-group-id="6" style="height: 100%;"><iframe class="componentFrame" src="/cuicui/components/index.html?dev=false&amp;page=userpermissions"></iframe></div></div></div><div class="cd-grid-item display-none" style="height: 100%; width: 100%;"><div style="height: 100%;"><iframe src="about:blank" aria-hidden="true" tabindex="-1" frameborder="0" style="display: block; opacity: 0; position: absolute; top: 0px; left: 0px; height: 100%; width: 100%; overflow: hidden; pointer-events: none; z-index: -1;"></iframe><div class="style-cd-gadget-card-2JKXD cd-gadget display-none" id="users_list_component" data-group-id="7" style="height: 100%;"><iframe class="componentFrame" src="/cuicui/components/index.html?dev=false&amp;page=users"></iframe></div></div></div><div class="cd-grid-item display-none" style="height: 100%; width: 100%;"><div style="height: 100%;"><iframe src="about:blank" aria-hidden="true" tabindex="-1" frameborder="0" style="display: block; opacity: 0; position: absolute; top: 0px; left: 0px; height: 100%; width: 100%; overflow: hidden; pointer-events: none; z-index: -1;"></iframe><div class="style-cd-gadget-card-2JKXD cd-gadget display-none" id="groups_components" data-group-id="8" style="height: 100%;"><iframe class="componentFrame" src="/cuicui/components/index.html?dev=false&amp;page=groups"></iframe></div></div></div><div class="cd-grid-item display-none" style="height: 100%; width: 100%;"><div style="height: 100%;"><iframe src="about:blank" aria-hidden="true" tabindex="-1" frameborder="0" style="display: block; opacity: 0; position: absolute; top: 0px; left: 0px; height: 100%; width: 100%; overflow: hidden; pointer-events: none; z-index: -1;"></iframe><div class="style-cd-gadget-card-2JKXD cd-gadget display-none" id="ds_list_component" data-group-id="9" style="height: 100%;"><iframe class="componentFrame" src="/cuicui/components/index.html?dev=false&amp;page=datasources"></iframe></div></div></div><div class="cd-grid-item display-none" style="height: 100%; width: 100%;"><div style="height: 100%;"><iframe src="about:blank" aria-hidden="true" tabindex="-1" frameborder="0" style="display: block; opacity: 0; position: absolute; top: 0px; left: 0px; height: 100%; width: 100%; overflow: hidden; pointer-events: none; z-index: -1;"></iframe><div class="style-cd-gadget-card-2JKXD cd-gadget display-none" id="schedulers_component" data-group-id="10" style="height: 100%;"><iframe class="componentFrame" src="/cuicui/components/index.html?dev=false&amp;page=schedulers"></iframe></div></div></div></div></div><div class="erd_scroll_detection_container erd_scroll_detection_container_animation_active" style="visibility: hidden; display: inline; width: 0px; height: 0px; z-index: -1; overflow: hidden; margin: 0px; padding: 0px;"><div dir="ltr" class="erd_scroll_detection_container" style="position: absolute; flex: 0 0 auto; overflow: hidden; z-index: -1; visibility: hidden; width: 100%; height: 100%; left: 0px; top: 0px;"><div class="erd_scroll_detection_container" style="position: absolute; flex: 0 0 auto; overflow: hidden; z-index: -1; visibility: hidden; inset: -16px -15px -15px -16px;"><div style="position: absolute; flex: 0 0 auto; overflow: scroll; z-index: -1; visibility: hidden; width: 100%; height: 100%;"><div style="position: absolute; left: 0px; top: 0px; width: 1307px; height: 921px;"></div></div><div style="position: absolute; flex: 0 0 auto; overflow: scroll; z-index: -1; visibility: hidden; width: 100%; height: 100%;"><div style="position: absolute; width: 200%; height: 200%;"></div></div></div></div></div></div></div></div>
	<link rel="stylesheet" type="text/css" href="/cuicui/scripts/css/cd.layout.css?nocache=1758049574067">
	<link rel="stylesheet" type="text/css" href="/cuicui/scripts/css/cd.component.css?nocache=1758049574067">
	<script type="text/javascript" src="/cuicui/scripts/js/cd.v.js?nocache=1758049574067"></script>
	<script type="text/javascript" src="/cuicui/scripts/js/cd.component.js?nocache=1758049574067"></script>
<div class="modal" id="focusdiv" style="height: 100%; width: 100%; display: none; position: absolute; right: 0px; left: 0px;"><div class="open hide" id="id-gt-div"><style>select::-ms-expand{display:none;}</style><ul id="id-gt-ul" role="menu" class="dropdown-menu visible" style="position: absolute; width: 235px; top: 49px; left: 1131px;"><li id="locale-btn1"><a style="height: 3.2em;"><select id="languageSelector" tabindex="0" style="-webkit-appearance:none;-moz-appearance:none;border-style:solid;border-width:1px;border-color:#D7D7D8;padding:7px;height:2.3rem;font-size:0.8rem;background: url(/cuicui/images/chevron_Icon.png) no-repeat 96% 0;color: #3B3A36;border-radius: 2px;background-size: .8em;background-position-y: center !important;background-position:96%;color:#6A6B6C;font-family:CiscoSansTT Extra Light"><option label="English (U.S.)" value="en_US">English (U.S.)</option></select></a></li><li id="synchronize-cluster-btn1"><a tabindex="1" id="sc_anchor" style="font-size:0.8rem;color:#6A6B6C;font-family:CiscoSansTT Extra Light"><i class="icon"></i>Synchronize Cluster</a></li><li id="signout-btn1" style="undefined"><a tabindex="1" id="so_anchor" style="font-size:0.8rem;color:#6A6B6C;font-family:CiscoSansTT Extra Light"><i class="icon"></i>Sign Out</a></li></ul></div></div></body></html>