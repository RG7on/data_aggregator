<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Data Aggregator â€” Control Panel</title>
<style>
  :root { --bg: #0d1117; --surface: #161b22; --surface2: #1c2128; --border: #30363d;
           --text: #c9d1d9; --muted: #8b949e; --accent: #58a6ff; --green: #3fb950;
           --red: #f85149; --yellow: #d29922; --orange: #db6d28; --radius: 8px; }
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
         background: var(--bg); color: var(--text); line-height: 1.6; padding: 24px; max-width: 1040px; margin: auto; }
  h1 { font-size: 24px; margin-bottom: 4px; }
  .subtitle { color: var(--muted); font-size: 14px; margin-bottom: 24px; }
  h2 { font-size: 18px; margin: 0 0 12px; display: flex; align-items: center; gap: 8px; }
  h2 .badge { font-size: 11px; padding: 2px 8px; border-radius: 12px; background: var(--border); color: var(--muted); font-weight: 400; }
  h3 { font-size: 15px; color: var(--accent); margin: 16px 0 8px; }
  .card { background: var(--surface); border: 1px solid var(--border); border-radius: var(--radius); padding: 20px; margin-bottom: 16px; }
  .field { margin-bottom: 14px; }
  .field label { display: block; font-size: 13px; color: var(--muted); margin-bottom: 4px; }
  .field input[type="text"], .field input[type="number"], .field input[type="password"], .field select, .field textarea {
    width: 100%; padding: 8px 12px; background: var(--bg); border: 1px solid var(--border);
    border-radius: 6px; color: var(--text); font-size: 14px; font-family: inherit; }
  .field input:focus, .field select:focus, .field textarea:focus { outline: none; border-color: var(--accent); }
  .field textarea { min-height: 72px; resize: vertical; font-family: 'Cascadia Code', 'Fira Code', monospace; font-size: 13px; }
  .field .hint { font-size: 12px; color: var(--muted); margin-top: 2px; }
  .row { display: flex; gap: 12px; }
  .row > .field { flex: 1; }
  .toggle-switch { display: flex; align-items: center; gap: 10px; margin-bottom: 14px; }
  .toggle-switch input[type="checkbox"] { width: 36px; height: 20px; appearance: none; background: var(--border);
    border-radius: 10px; position: relative; cursor: pointer; transition: .2s; flex-shrink: 0; }
  .toggle-switch input[type="checkbox"]::after { content: ''; position: absolute; width: 16px; height: 16px;
    background: var(--muted); border-radius: 50%; top: 2px; left: 2px; transition: .2s; }
  .toggle-switch input[type="checkbox"]:checked { background: var(--green); }
  .toggle-switch input[type="checkbox"]:checked::after { left: 18px; background: #fff; }
  .toggle-switch label { font-size: 14px; cursor: pointer; }
  .btn-bar { display: flex; gap: 10px; margin-top: 24px; position: sticky; bottom: 0;
             background: var(--bg); padding: 16px 0; border-top: 1px solid var(--border); z-index: 50; }
  .btn { padding: 10px 20px; border: none; border-radius: 6px; cursor: pointer; font-weight: 600; font-size: 14px; transition: .15s; }
  .btn-primary { background: var(--green); color: #fff; }
  .btn-primary:hover { filter: brightness(1.1); }
  .btn-secondary { background: var(--border); color: var(--text); }
  .btn-secondary:hover { background: #3d444d; }
  .btn-sm { padding: 6px 14px; font-size: 13px; }
  .btn-icon { padding: 6px 10px; font-size: 16px; background: transparent; color: var(--muted); border: 1px solid var(--border); border-radius: 6px; }
  .btn-icon:hover { color: var(--red); border-color: var(--red); }
  .toast { position: fixed; bottom: 24px; right: 24px; padding: 12px 20px; border-radius: 8px;
           font-size: 14px; font-weight: 500; opacity: 0; transition: opacity .3s; pointer-events: none; z-index: 100; }
  .toast.show { opacity: 1; }
  .toast.success { background: var(--green); color: #fff; }
  .toast.error { background: var(--red); color: #fff; }
  .toast.info { background: var(--accent); color: #fff; }
  .tabs { display: flex; border-bottom: 1px solid var(--border); margin-bottom: 20px; gap: 2px; }
  .tab { padding: 10px 18px; cursor: pointer; color: var(--muted); border-bottom: 2px solid transparent;
         transition: .2s; font-size: 14px; white-space: nowrap; }
  .tab:hover { color: var(--text); }
  .tab.active { color: var(--accent); border-bottom-color: var(--accent); }
  .tab-content { display: none; }
  .tab-content.active { display: block; }
  code { background: var(--bg); padding: 2px 6px; border-radius: 4px; font-size: 13px; }
  .help { background: var(--surface2); border: 1px solid var(--border); border-radius: var(--radius);
          padding: 16px; margin-bottom: 16px; font-size: 13px; color: var(--muted); }
  .help strong { color: var(--text); }

  /* Report cards */
  .report-card { background: var(--surface2); border: 1px solid var(--border); border-radius: var(--radius);
                 padding: 16px; margin-bottom: 12px; }
  .report-card.disabled { opacity: 0.6; }
  .report-card-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; }
  .report-card-header .label-tag { font-size: 14px; font-weight: 600; color: var(--accent);
    background: rgba(88,166,255,0.1); padding: 3px 10px; border-radius: 4px; }
  .report-card .inline-row { display: grid; grid-template-columns: 160px 1fr; gap: 10px; margin-bottom: 8px; align-items: center; }
  .report-card .inline-row label { font-size: 13px; color: var(--muted); }
  .report-card .inline-row input { padding: 6px 10px; background: var(--bg); border: 1px solid var(--border);
    border-radius: 5px; color: var(--text); font-size: 13px; }
  .report-card .inline-row input:focus { outline: none; border-color: var(--accent); }

  /* Status badge */
  .status-bar { display: flex; align-items: center; gap: 8px; padding: 8px 12px; margin-top: 10px;
    background: var(--bg); border-radius: 6px; font-size: 12px; color: var(--muted); }
  .status-dot { width: 8px; height: 8px; border-radius: 50%; flex-shrink: 0; }
  .status-dot.success { background: var(--green); }
  .status-dot.error { background: var(--red); }
  .status-dot.no_data { background: var(--yellow); }
  .status-dot.pending { background: var(--border); }
  .status-dot.skipped { background: var(--accent); }

  /* Dashboard */
  .dashboard-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 12px; margin-bottom: 20px; }
  .stat-card { background: var(--surface); border: 1px solid var(--border); border-radius: var(--radius);
               padding: 16px; text-align: center; }
  .stat-card .stat-value { font-size: 28px; font-weight: 700; color: var(--accent); }
  .stat-card .stat-label { font-size: 12px; color: var(--muted); margin-top: 4px; }
  .log-table { width: 100%; border-collapse: collapse; font-size: 13px; }
  .log-table th { text-align: left; padding: 8px 12px; border-bottom: 1px solid var(--border); color: var(--muted); font-weight: 500; }
  .log-table td { padding: 8px 12px; border-bottom: 1px solid var(--border); }
  .log-table tr:hover { background: var(--surface2); }
  .status-pill { display: inline-block; padding: 2px 8px; border-radius: 10px; font-size: 11px; font-weight: 600; }
  .status-pill.success { background: rgba(63,185,80,0.15); color: var(--green); }
  .status-pill.error { background: rgba(248,81,73,0.15); color: var(--red); }
  .status-pill.no_data { background: rgba(210,153,34,0.15); color: var(--yellow); }
  .status-pill.skipped { background: rgba(88,166,255,0.15); color: var(--accent); }

  .server-status { font-size: 12px; color: var(--green); display: flex; align-items: center; gap: 6px; }
  .server-status .dot { width: 6px; height: 6px; border-radius: 50%; background: var(--green); }
  .server-status.offline .dot { background: var(--red); }
  .server-status.offline { color: var(--red); }

  /* Filter wizard panel */
  .filter-panel { padding: 12px 14px; background: var(--bg); border: 1px solid var(--border);
    border-radius: 6px; }
  .filter-panel h4 { font-size: 13px; color: var(--accent); margin: 0 0 10px; display: flex; align-items: center; gap: 6px; }

  /* Collapsible panel wrapper */
  .filter-panel-collapsible { margin-top: 12px; border: 1px solid var(--border); border-radius: 6px; background: var(--bg); overflow: hidden; }
  .filter-panel-collapsible > .filter-panel { border: none; border-radius: 0; }
  .filter-panel-toggle { padding: 10px 14px; font-size: 13px; font-weight: 600; color: var(--accent); cursor: pointer;
    display: flex; align-items: center; gap: 6px; list-style: none; user-select: none; }
  .filter-panel-toggle::-webkit-details-marker { display: none; }
  .filter-panel-toggle::after { content: 'â–¶'; font-size: 10px; transition: transform 0.2s; color: var(--muted); margin-left: 8px; }
  .filter-panel-toggle:not(:has(.filter-clear))::after { margin-left: auto; }
  details[open] > .filter-panel-toggle::after { transform: rotate(90deg); }
  .filter-panel-toggle:hover { background: rgba(88,166,255,0.05); }
  .filter-panel-toggle .filter-clear { margin-left: auto; }
  .filter-step { margin-bottom: 10px; padding: 8px 10px; background: var(--surface); border-radius: 5px; }
  .filter-step .step-label { font-size: 11px; color: var(--muted); font-weight: 600; text-transform: uppercase;
    letter-spacing: 0.05em; margin-bottom: 6px; }
  .filter-field { display: grid; grid-template-columns: 140px 1fr; gap: 8px; align-items: center; margin-bottom: 6px; }
  .filter-field label { font-size: 12px; color: var(--muted); overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
  .filter-field input, .filter-field select { padding: 5px 8px; background: var(--bg); border: 1px solid var(--border);
    border-radius: 4px; color: var(--text); font-size: 12px; font-family: inherit; }
  .filter-field input:focus, .filter-field select:focus { outline: none; border-color: var(--accent); }
  .filter-field select[multiple] { min-height: 60px; }
  .filter-field .hint { font-size: 10px; color: var(--muted); grid-column: 2; margin-top: -4px; }
  .filter-field .vl-badge { display: inline-block; padding: 1px 6px; font-size: 10px; border-radius: 3px;
    background: rgba(88,166,255,0.12); color: var(--accent); margin-left: 4px; }
  .filter-sub { margin-left: 0; padding: 6px 0 2px; }
  .filter-sub .sub-row { display: flex; gap: 8px; align-items: center; margin-bottom: 5px; flex-wrap: wrap; }
  .filter-sub .sub-row label { font-size: 11px; color: var(--muted); min-width: 56px; }
  .filter-sub .sub-row input[type="date"], .filter-sub .sub-row input[type="time"] {
    padding: 4px 6px; background: var(--bg); border: 1px solid var(--border); border-radius: 4px;
    color: var(--text); font-size: 12px; font-family: inherit; }
  .filter-sub .sub-row input:focus { outline: none; border-color: var(--accent); }
  .filter-sub .sub-row select { padding: 4px 6px; background: var(--bg); border: 1px solid var(--border);
    border-radius: 4px; color: var(--text); font-size: 12px; }
  .filter-sub .sub-row span.to { font-size: 11px; color: var(--muted); }
  .vl-section { margin-top: 6px; }
  .vl-section .vl-toolbar { display: flex; gap: 8px; align-items: center; margin-bottom: 6px; flex-wrap: wrap; }
  .vl-section .vl-toolbar input[type="text"] { flex: 1; min-width: 140px; padding: 4px 8px; background: var(--bg);
    border: 1px solid var(--border); border-radius: 4px; color: var(--text); font-size: 12px; }
  .vl-section .vl-toolbar button { padding: 3px 10px; font-size: 11px; border: 1px solid var(--border);
    background: var(--surface); color: var(--muted); border-radius: 4px; cursor: pointer; white-space: nowrap; }
  .vl-section .vl-toolbar button:hover { color: var(--accent); border-color: var(--accent); }
  .vl-section .vl-count { font-size: 11px; color: var(--muted); margin-left: auto; white-space: nowrap; }
  .vl-section .vl-checklist { max-height: 220px; overflow-y: auto; border: 1px solid var(--border);
    border-radius: 4px; background: var(--bg); padding: 2px 0; }
  .vl-section .vl-checklist label { display: flex; align-items: center; gap: 6px; padding: 3px 10px;
    font-size: 12px; cursor: pointer; user-select: none; }
  .vl-section .vl-checklist label:hover { background: var(--surface2); }
  .vl-section .vl-checklist input[type="checkbox"] { width: 14px; height: 14px; accent-color: var(--accent);
    cursor: pointer; flex-shrink: 0; }
  .vl-section .vl-checklist .vl-group-header { padding: 4px 10px; font-size: 11px; font-weight: 600;
    color: var(--accent); background: var(--surface); border-bottom: 1px solid var(--border); position: sticky; top: 0; }
  .vl-groups { display: flex; flex-wrap: wrap; gap: 4px; margin-bottom: 6px; }
  .vl-groups .vl-group-btn { display: inline-flex; align-items: center; gap: 4px; padding: 4px 10px;
    font-size: 11px; border: 1px solid var(--border); border-radius: 4px; background: var(--surface);
    color: var(--text); cursor: pointer; user-select: none; transition: .15s; }
  .vl-groups .vl-group-btn:hover { border-color: var(--accent); color: var(--accent); }
  .vl-groups .vl-group-btn .vl-g-count { color: var(--muted); font-size: 10px; }
  .vl-groups .vl-group-btn.active { background: rgba(88,166,255,0.15); border-color: var(--accent); color: var(--accent); }

  /* Selected-values summary tags */
  .vl-selected-summary { display: flex; flex-wrap: wrap; gap: 4px; margin: 6px 0; padding: 6px 8px;
    background: rgba(63,185,80,0.06); border: 1px solid rgba(63,185,80,0.2); border-radius: 6px; }
  .vl-selected-summary:empty { display: none; }
  .vl-selected-summary .vl-sel-label { font-size: 11px; font-weight: 600; color: var(--green);
    margin-right: 4px; white-space: nowrap; align-self: center; }
  .vl-selected-summary .vl-sel-tag { display: inline-flex; align-items: center; gap: 3px; font-size: 11px;
    padding: 2px 8px; background: rgba(63,185,80,0.12); color: var(--green); border-radius: 3px;
    border: 1px solid rgba(63,185,80,0.2); }
  .vl-selected-summary .vl-sel-tag .vl-sel-x { cursor: pointer; font-weight: 700; font-size: 13px;
    color: var(--muted); margin-left: 2px; line-height: 1; }
  .vl-selected-summary .vl-sel-tag .vl-sel-x:hover { color: var(--red); }
  .vl-selected-summary .vl-sel-more { font-size: 10px; color: var(--muted); align-self: center; }

  /* Field-filter selected list (with criteria) */
  .ff-selected-list { margin-top: 8px; margin-bottom: 8px; max-height: 400px; overflow-y: auto; }
  .ff-empty-msg { font-size: 12px; color: var(--muted); font-style: italic; margin: 8px 0; }
  .ff-selected-item { border: 1px solid var(--border); border-radius: 6px; padding: 8px; margin-bottom: 8px;
    background: var(--surface); }
  .ff-si-header { display: flex; align-items: center; gap: 6px; margin-bottom: 6px; }
  .ff-si-label { font-weight: 600; font-size: 13px; color: var(--text); }
  .ff-si-fid { font-size: 10px; color: var(--muted); }
  .ff-si-remove { margin-left: auto; background: none; border: none; color: var(--danger); font-size: 18px;
    cursor: pointer; padding: 0 4px; line-height: 1; }
  .ff-si-remove:hover { color: var(--red); }
  .ff-si-criteria { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 8px; }
  .ff-si-criteria > div { display: flex; flex-direction: column; gap: 2px; }
  .ff-si-criteria label { font-size: 11px; color: var(--muted); font-weight: 500; }
  .ff-si-criteria select, .ff-si-criteria input[type="text"] {
    padding: 5px 8px; font-size: 12px; border: 1px solid var(--border); border-radius: 4px;
    background: var(--bg); color: var(--text); }
  .ff-si-criteria select:focus, .ff-si-criteria input[type="text"]:focus {
    outline: none; border-color: var(--accent); }

  /* Field-filter checklist (reuses vl-section styles) */
  .ff-section { margin-top: 6px; }
  .ff-section .ff-toolbar { display: flex; gap: 8px; align-items: center; margin-bottom: 6px; flex-wrap: wrap; }
  .ff-section .ff-toolbar input[type="text"] { flex: 1; min-width: 140px; padding: 4px 8px; background: var(--bg);
    border: 1px solid var(--border); border-radius: 4px; color: var(--text); font-size: 12px; }
  .ff-section .ff-toolbar button { padding: 3px 10px; font-size: 11px; border: 1px solid var(--border);
    background: var(--surface); color: var(--muted); border-radius: 4px; cursor: pointer; white-space: nowrap; }
  .ff-section .ff-toolbar button:hover { color: var(--accent); border-color: var(--accent); }
  .ff-section .ff-count { font-size: 11px; color: var(--muted); margin-left: auto; white-space: nowrap; }
  .ff-section .ff-checklist { max-height: 220px; overflow-y: auto; border: 1px solid var(--border);
    border-radius: 4px; background: var(--bg); padding: 2px 0; }
  .ff-section .ff-checklist label { display: flex; align-items: center; gap: 6px; padding: 3px 10px;
    font-size: 12px; cursor: pointer; user-select: none; }
  .ff-section .ff-checklist label:hover { background: var(--surface2); }
  .ff-section .ff-checklist input[type="checkbox"] { width: 14px; height: 14px; accent-color: var(--accent);
    cursor: pointer; flex-shrink: 0; }
  .ff-section .ff-checklist label .ff-field-id { font-size: 10px; color: var(--muted); margin-left: auto; }

  /* Wizard step tabs (multi-step wizards) */
  .wizard-step-tabs { display: flex; gap: 0; margin-bottom: 10px; border-bottom: 2px solid var(--border); }
  .wizard-step-tabs .wst-tab { padding: 8px 14px; font-size: 12px; font-weight: 600; color: var(--muted);
    cursor: pointer; border-bottom: 2px solid transparent; margin-bottom: -2px; transition: .15s;
    user-select: none; display: flex; align-items: center; gap: 5px; }
  .wizard-step-tabs .wst-tab:hover { color: var(--accent); }
  .wizard-step-tabs .wst-tab.active { color: var(--accent); border-bottom-color: var(--accent); }
  .wizard-step-tabs .wst-tab .wst-arrow { font-size: 10px; color: var(--border); margin-right: -5px; }
  .wizard-step-body { display: none; }
  .wizard-step-body.active { display: block; }

  .btn-discover { padding: 5px 12px; font-size: 12px; font-weight: 600; border: 1px solid var(--accent);
    background: rgba(88,166,255,0.1); color: var(--accent); border-radius: 5px; cursor: pointer;
    display: inline-flex; align-items: center; gap: 4px; transition: .15s; }
  .btn-discover:hover { background: rgba(88,166,255,0.2); }
  .btn-discover:disabled { opacity: 0.5; cursor: wait; }
  .btn-discover .spinner { display: inline-block; width: 12px; height: 12px; border: 2px solid var(--border);
    border-top-color: var(--accent); border-radius: 50%; animation: spin 0.8s linear infinite; }
  @keyframes spin { to { transform: rotate(360deg); } }
  
  /* â”€â”€ Highlight new report animation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  @keyframes highlightFade {
    0% { box-shadow: 0 0 0 3px rgba(88,166,255,0.6); }
    100% { box-shadow: 0 0 0 3px rgba(88,166,255,0); }
  }
  .report-card.highlight-new {
    animation: highlightFade 1s ease-out;
  }
  
  .filter-clear { font-size: 11px; color: var(--muted); cursor: pointer; margin-left: auto; }
  .filter-clear:hover { color: var(--red); }

  /* â”€â”€ SMAX Properties â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  .smax-prop-row { display: flex; justify-content: space-between; align-items: center; padding: 4px 0; font-size: 13px; }
  .smax-prop-label { font-weight: 600; color: var(--muted); min-width: 110px; }
  .smax-prop-badge { background: rgba(88,166,255,0.15); color: var(--accent); padding: 2px 8px; border-radius: 4px; font-size: 12px; }
  .smax-filter-row { display: flex; align-items: flex-start; gap: 6px; padding: 5px 0; border-bottom: 1px solid var(--border); font-size: 13px; }
  .smax-filter-row:last-child { border-bottom: none; }
  .smax-filter-label { font-weight: 600; color: var(--accent); min-width: 120px; flex-shrink: 0; }
  .smax-filter-sep { color: var(--muted); }
  .smax-filter-value { color: var(--fg); }
  .smax-presets { margin-top: 4px; }
  .smax-preset-tag { display: inline-block; font-size: 11px; padding: 1px 6px; background: rgba(88,166,255,0.1); color: var(--accent); border-radius: 3px; margin: 2px 2px 0 0; }
  .smax-chip { display: inline-block; font-size: 12px; padding: 2px 8px; background: var(--surface2); border: 1px solid var(--border); border-radius: 4px; margin: 2px 2px 0 0; }
  .smax-neg-badge { font-size: 10px; font-weight: 700; color: var(--red); background: rgba(248,81,73,0.15); padding: 1px 5px; border-radius: 3px; }
  .smax-op-badge { font-size: 10px; font-weight: 600; color: var(--accent); background: rgba(88,166,255,0.1); padding: 1px 5px; border-radius: 3px; }
  .smax-enum-opts { margin-top: 4px; display: flex; flex-wrap: wrap; gap: 4px; }
  .smax-enum-opt { display: inline-block; font-size: 11px; padding: 2px 6px; border-radius: 3px; background: var(--surface2); border: 1px solid var(--border); color: var(--muted); }
  .smax-enum-opt.active { background: rgba(63,185,80,0.15); color: var(--green); border-color: var(--green); }

  /* â”€â”€ Data Type Badges â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  .data-type-badge { font-size: 10px; font-weight: 600; padding: 2px 8px; border-radius: 10px; text-transform: uppercase; letter-spacing: 0.3px; }
  .data-type-badge.ongoing { background: rgba(88,166,255,0.15); color: var(--accent); border: 1px solid rgba(88,166,255,0.3); }
  .data-type-badge.historical { background: rgba(210,153,34,0.15); color: #d29a22; border: 1px solid rgba(210,153,34,0.3); }
</style>
</head>
<body>

<div style="display:flex; justify-content:space-between; align-items:flex-start;">
  <div>
    <h1>âš™ï¸ Data Aggregator Control Panel</h1>
    <p class="subtitle">Configure workers, manage reports, and monitor scrape status.</p>
  </div>
  <div class="server-status" id="server-status">
    <span class="dot"></span>
    <span id="server-status-text">Connected</span>
  </div>
</div>

<div class="tabs">
  <div class="tab active" data-tab="dashboard">Dashboard</div>
  <div class="tab" data-tab="global">Global</div>
  <div class="tab" data-tab="workers-settings">Workers Settings</div>
  <div class="tab" data-tab="cuic">CUIC Worker</div>
  <div class="tab" data-tab="smax">SMAX Worker</div>
  <div class="tab" data-tab="export">Export / Import</div>
</div>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<!--  DASHBOARD TAB                                                         -->
<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<div class="tab-content active" id="tab-dashboard">
  <div class="dashboard-grid">
    <div class="stat-card">
      <div class="stat-value" id="stat-total-reports">-</div>
      <div class="stat-label">Configured Reports</div>
    </div>
    <div class="stat-card">
      <div class="stat-value" id="stat-last-run">-</div>
      <div class="stat-label">Last Scrape</div>
    </div>
    <div class="stat-card">
      <div class="stat-value" id="stat-success-rate">-</div>
      <div class="stat-label">Success Rate</div>
    </div>
    <div class="stat-card">
      <div class="stat-value" id="stat-total-rows">-</div>
      <div class="stat-label">Total Rows (Last Run)</div>
    </div>
  </div>

  <div class="card" style="display:flex;align-items:center;gap:16px;padding:14px 20px;">
    <button class="btn-discover" id="manual-scrape-btn" onclick="startManualScrape()" style="font-size:14px;padding:10px 24px;">
      â–¶ Start Scrape Now
    </button>
    <span id="manual-scrape-status" style="font-size:13px;color:var(--muted)">Run all enabled workers manually</span>
  </div>

  <div class="card">
    <h2>Recent Scrape History</h2>
    <div style="max-height:400px; overflow-y:auto;">
      <table class="log-table">
        <thead><tr><th>Time</th><th>Source</th><th>Report</th><th>Status</th><th>Rows</th><th>Duration</th><th>Message</th></tr></thead>
        <tbody id="scrape-log-body"><tr><td colspan="7" style="text-align:center;color:var(--muted)">Loading...</td></tr></tbody>
      </table>
    </div>
  </div>
</div>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<!--  GLOBAL TAB                                                            -->
<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<div class="tab-content" id="tab-global">
  <div class="card">
    <h2>Browser</h2>
    <div class="toggle-switch">
      <input type="checkbox" id="g-headless" checked>
      <label for="g-headless">Headless mode <span style="color:var(--muted)">(no visible browser window)</span></label>
    </div>
    <div class="toggle-switch">
      <input type="checkbox" id="g-system-chrome" checked>
      <label for="g-system-chrome">Use system Chrome</label>
    </div>
  </div>

  <div class="card">
    <h2>Screenshots</h2>
    <div class="toggle-switch">
      <input type="checkbox" id="g-screenshot-steps">
      <label for="g-screenshot-steps">Screenshot every step <span style="color:var(--muted)">(slow but useful for debugging)</span></label>
    </div>
    <div class="toggle-switch">
      <input type="checkbox" id="g-screenshot-errors" checked>
      <label for="g-screenshot-errors">Screenshot on errors</label>
    </div>
  </div>

  <div class="card">
    <h2>Logging & Storage</h2>
    <div class="row">
      <div class="field">
        <label>Log Level</label>
        <select id="g-log-level">
          <option value="DEBUG">DEBUG</option>
          <option value="INFO" selected>INFO</option>
          <option value="WARNING">WARNING</option>
          <option value="ERROR">ERROR</option>
        </select>
      </div>
      <div class="field">
        <label>Data Retention (days)</label>
        <input type="number" id="g-retention" value="90" min="1">
      </div>
    </div>
    <div class="row">
      <div class="field">
        <label>Output Directory</label>
        <input type="text" id="g-output-dir" value="output">
        <div class="hint">Relative to project root</div>
      </div>
      <div class="field">
        <label>Log Directory</label>
        <input type="text" id="g-log-dir" value="logs">
      </div>
    </div>
    <div class="field">
      <label>Shared Drive CSV Path</label>
      <input type="text" id="g-shared-drive" value="" placeholder="\\\\server\\share\\kpi_snapshots.csv">
      <div class="hint">UNC path to auto-export CSV for Power BI. Leave empty to disable.</div>
    </div>
  </div>
</div>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<!--  WORKERS SETTINGS TAB                                                  -->
<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<div class="tab-content" id="tab-workers-settings">
  <div class="card">
    <h2>CUIC Worker <span class="badge">workers/cuic/</span></h2>
    <div class="toggle-switch">
      <input type="checkbox" id="cuic-enabled" checked>
      <label for="cuic-enabled">Enabled</label>
    </div>

    <h3>Connection</h3>
    <div class="field">
      <label>CUIC URL</label>
      <input type="text" id="cuic-url" value="https://148.151.32.77:8444/cuicui/Main.jsp">
    </div>
    <div class="row">
      <div class="field">
        <label>Username</label>
        <input type="text" id="cuic-user" value="">
      </div>
      <div class="field">
        <label>Password</label>
        <input type="password" id="cuic-pass" value="">
      </div>
    </div>

    <h3>Timeouts (ms)</h3>
    <div class="help">Lower values = faster, but may cause failures on slow networks. Raise if the worker times out.</div>
    <div class="row">
      <div class="field"><label>Navigation</label><input type="number" id="cuic-t-nav" value="30000"></div>
      <div class="field"><label>Short wait</label><input type="number" id="cuic-t-short" value="1500"></div>
    </div>
    <div class="row">
      <div class="field"><label>Medium wait</label><input type="number" id="cuic-t-medium" value="2500"></div>
      <div class="field"><label>Long wait</label><input type="number" id="cuic-t-long" value="8000"></div>
    </div>
  </div>

  <div class="card">
    <h2>SMAX Worker <span class="badge">smax_worker.py</span></h2>
    <div class="toggle-switch">
      <input type="checkbox" id="smax-enabled">
      <label for="smax-enabled">Enabled</label>
    </div>

    <h3>Connection</h3>
    <div class="field">
      <label>Base URL</label>
      <input type="text" id="smax-url" value="https://smax.corp.pdo.om">
    </div>
    <div class="row">
      <div class="field"><label>Username</label><input type="text" id="smax-user" value=""></div>
      <div class="field"><label>Password</label><input type="password" id="smax-pass" value=""></div>
    </div>

    <h3>Timeouts (ms)</h3>
    <div class="row">
      <div class="field"><label>Page Load</label><input type="number" id="smax-t-load" value="120000"></div>
      <div class="field"><label>Element Wait</label><input type="number" id="smax-t-elem" value="30000"></div>
    </div>
    <div class="row">
      <div class="field"><label>Tab Stagger Delay</label><input type="number" id="smax-t-stagger" value="2000"></div>
      <div class="field"><label>Max Retries</label><input type="number" id="smax-retries" value="2" min="0"></div>
    </div>
  </div>
</div>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<!--  CUIC TAB                                                              -->
<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<div class="tab-content" id="tab-cuic">
  <div class="card">
    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:16px;">
      <h2 style="margin:0">Reports</h2>
      <button class="btn btn-secondary btn-sm" onclick="addCuicReport()">+ Add Report</button>
    </div>
    <div class="help">
      Each report specifies a <strong>folder path</strong> and <strong>report name</strong> as they appear in the CUIC reports list.
      Use <code>/</code> to separate nested folders (e.g. <code>Stock/CCE/CCE_AF_Historical</code>).
      The <strong>label</strong> is a short unique identifier used for tracking (e.g. <code>agent_hist</code>).
    </div>
    <div id="cuic-reports-list"></div>
  </div>
</div>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<!--  SMAX TAB                                                              -->
<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<div class="tab-content" id="tab-smax">
  <div class="card">
    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:16px;">
      <h2 style="margin:0">Reports</h2>
      <button class="btn btn-secondary btn-sm" onclick="addSmaxReport()">+ Add Report</button>
    </div>
    <div class="help">
      Each report needs a <strong>URL</strong> (the full SMAX report link) and a <strong>label</strong> (short unique identifier for tracking).
      Use <strong>Discover Properties</strong> to read the report's filters, group-by, function, and other settings from the live page.
    </div>
    <div id="smax-reports-list"></div>
  </div>
</div>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<!--  EXPORT / IMPORT TAB                                                   -->
<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<div class="tab-content" id="tab-export">
  <div class="help">
    <strong>How to use:</strong> Click "Generate JSON" to see the current configuration.
    You can also paste JSON below and click "Load into form" to update the form.
  </div>
  <div class="card">
    <h2>settings.json</h2>
    <div class="field"><textarea id="out-settings" rows="16" readonly></textarea></div>
    <button class="btn btn-secondary btn-sm" onclick="copyToClipboard('out-settings')">ğŸ“‹ Copy</button>
  </div>
  <div class="card">
    <h2>credentials.json</h2>
    <div class="field"><textarea id="out-credentials" rows="8" readonly></textarea></div>
    <button class="btn btn-secondary btn-sm" onclick="copyToClipboard('out-credentials')">ğŸ“‹ Copy</button>
  </div>
  <div style="margin-top:16px">
    <h3>Load from JSON</h3>
    <div class="row">
      <div class="field">
        <label>Paste settings.json</label>
        <textarea id="in-settings" rows="6" placeholder='Paste settings.json content here...'></textarea>
      </div>
      <div class="field">
        <label>Paste credentials.json</label>
        <textarea id="in-credentials" rows="6" placeholder='Paste credentials.json content here...'></textarea>
      </div>
    </div>
    <button class="btn btn-secondary btn-sm" onclick="loadFromJSON()">â¬†ï¸ Load into form</button>
  </div>
</div>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<!--  SAVE BAR                                                              -->
<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<div class="btn-bar">
  <button class="btn btn-primary" onclick="saveAll()">ğŸ’¾ Save Settings</button>
  <button class="btn btn-secondary" onclick="generateJSON()">ğŸ“„ Generate JSON</button>
  <button class="btn btn-secondary" onclick="resetDefaults()">â†©ï¸ Reset Defaults</button>
</div>

<div class="toast" id="toast"></div>

<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  STATE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let cuicReports = [];
let smaxReports = [];
let scrapeStatus = {};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  TAB SWITCHING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
document.querySelectorAll('.tab').forEach(tab => {
  tab.addEventListener('click', () => {
    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
    document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
    tab.classList.add('active');
    document.getElementById('tab-' + tab.dataset.tab).classList.add('active');
  });
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  TOAST
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function showToast(msg, type = 'success') {
  const t = document.getElementById('toast');
  t.textContent = msg;
  t.className = 'toast show ' + type;
  setTimeout(() => t.classList.remove('show'), 3000);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  CUIC REPORT CARDS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function renderCuicReports() {
  const container = document.getElementById('cuic-reports-list');
  if (cuicReports.length === 0) {
    container.innerHTML = '<p style="color:var(--muted);text-align:center;padding:20px">No reports configured. Click "+ Add Report" to get started.</p>';
    return;
  }
  container.innerHTML = cuicReports.map((r, i) => {
    // Check if this is a new empty report (no folder/name and no filters discovered)
    const isEmpty = !r.folder && !r.name && (!r.filters || Object.keys(r.filters).length === 0);
    
    if (isEmpty) {
      // Minimal card: just report path + validate button
      return `<div class="report-card">
        <div class="report-card-header">
          <span class="label-tag" style="color:var(--muted);font-style:italic">New Report</span>
          <button class="btn btn-icon btn-sm" onclick="removeCuicReport(${i})" title="Remove">\uD83D\uDDD1\uFE0F</button>
        </div>
        <div class="inline-row"><label>Report Path</label><input value="${attr((r.folder ? r.folder + '/' : '') + (r.name || ''))}" onchange="updateCuicReportPath(${i}, this.value)" placeholder="e.g. Test/Z Call Type Historical All Fields" style="grid-column:2"></div>
        <div style="margin-top:10px;display:flex;align-items:center;gap:8px;">
          <button class="btn-discover" id="discover-btn-${i}" onclick="discoverFilters(${i})">
            \u25B6 Validate Path
          </button>
          <span style="font-size:11px;color:var(--muted)">Opens browser to validate the report path and read filters</span>
        </div>
      </div>`;
    }
    
    // Full card with all details
    const st = scrapeStatus['cuic:' + r.label];
    let statusHtml = '<div class="status-bar"><span class="status-dot pending"></span> Never scraped</div>';
    if (st) {
      const icon = st.status === 'success' ? '\u2705' : st.status === 'error' ? '\u274C' : '\u26A0\uFE0F';
      const dur = st.duration_s ? st.duration_s.toFixed(1) + 's' : '';
      const msg = st.message ? ' \u2014 ' + esc(st.message) : '';
      statusHtml = `<div class="status-bar"><span class="status-dot ${st.status}"></span>
        <span>${icon} ${esc(st.timestamp)} \u00B7 ${st.row_count || 0} rows \u00B7 ${dur}${msg}</span></div>`;
    }
    const filterHtml = renderFilterPanel(r, i);
    return `<div class="report-card ${r.enabled ? '' : 'disabled'}">
      <div class="report-card-header">
        <div style="display:flex;align-items:center;gap:8px">
          <span class="label-tag">${esc(r.label || 'unnamed')}</span>
          <span class="data-type-badge ${r.data_type === 'historical' ? 'historical' : 'ongoing'}">${r.data_type === 'historical' ? '\ud83d\udce6 Historical' : '\ud83d\udce1 Ongoing'}</span>
        </div>
        <div style="display:flex;gap:6px;align-items:center">
          <div class="toggle-switch" style="margin:0">
            <input type="checkbox" id="rpt-en-${i}" ${r.enabled ? 'checked' : ''}
              onchange="cuicReports[${i}].enabled=this.checked;renderCuicReports()">
            <label for="rpt-en-${i}" style="font-size:12px">Enabled</label>
          </div>
          <button class="btn btn-icon btn-sm" onclick="removeCuicReport(${i})" title="Remove">\uD83D\uDDD1\uFE0F</button>
        </div>
      </div>
      <div class="inline-row"><label>Report Path</label><input value="${attr((r.folder ? r.folder + '/' : '') + (r.name || ''))}" onchange="updateCuicReportPath(${i}, this.value)" placeholder="e.g. Test/Z Call Type Historical All Fields"></div>
      <div class="inline-row"><label>Label</label><input value="${attr(r.label)}" onchange="cuicReports[${i}].label=this.value" placeholder="Auto-generated from report name"></div>
      <div class="inline-row"><label>Data Type</label>
        <select onchange="cuicReports[${i}].data_type=this.value;renderCuicReports()" style="padding:6px 10px;background:var(--bg);border:1px solid var(--border);border-radius:var(--radius);color:var(--fg);font-size:13px">
          <option value="ongoing" ${(r.data_type||'ongoing')==='ongoing'?'selected':''}>ğŸ“¡ Ongoing (re-scrape every run)</option>
          <option value="historical" ${r.data_type==='historical'?'selected':''}>ğŸ“¦ Historical (scrape once)</option>
        </select>
      </div>
      <div style="margin-top:10px;display:flex;align-items:center;gap:8px;">
        <button class="btn-discover" id="discover-btn-${i}" onclick="discoverFilters(${i})">
          \u25B6 Re-validate Path
        </button>
        <span style="font-size:11px;color:var(--muted)">Re-open browser to update report filters</span>
      </div>
      ${filterHtml}
      ${statusHtml}
    </div>`;
  }).join('');
}

function addCuicReport() {
  // Check if there's already an empty report (no folder or name)
  const hasEmptyReport = cuicReports.some(r => !r.folder && !r.name);
  if (hasEmptyReport) {
    showToast('Please fill in the existing empty report first', 'warning');
    return;
  }
  
  cuicReports.unshift({ label: '', folder: '', name: '', enabled: true, data_type: 'ongoing', filters: {} });
  renderCuicReports();
  
  // Highlight the newly added report card
  setTimeout(() => {
    const firstCard = document.getElementById('cuic-reports-list').firstElementChild;
    if (firstCard) {
      firstCard.classList.add('highlight-new');
      // Remove the class after animation completes
      setTimeout(() => firstCard.classList.remove('highlight-new'), 1000);
    }
  }, 50);
}

function removeCuicReport(i) {
  if (cuicReports.length <= 1) { showToast('Keep at least one report', 'error'); return; }
  cuicReports.splice(i, 1);
  renderCuicReports();
}

function esc(s) { return (s||'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;'); }
function attr(s) { return (s||'').replace(/&/g,'&amp;').replace(/"/g,'&quot;'); }

// Helper: Generate label from report name (convert to snake_case)
function generateLabelFromName(name) {
  if (!name) return '';
  return name
    .trim()
    .replace(/[^a-zA-Z0-9]+/g, '_')  // Replace non-alphanumeric with underscore
    .replace(/^_+|_+$/g, '')          // Remove leading/trailing underscores
    .toLowerCase();
}

// Helper: Update CUIC report path (splits into folder/name and auto-updates label if empty)
function updateCuicReportPath(idx, path) {
  const lastSlash = path.lastIndexOf('/');
  if (lastSlash === -1) {
    // No slash, treat entire path as name
    cuicReports[idx].folder = '';
    cuicReports[idx].name = path;
  } else {
    cuicReports[idx].folder = path.substring(0, lastSlash);
    cuicReports[idx].name = path.substring(lastSlash + 1);
  }
  
  // Auto-generate label if it's empty
  if (!cuicReports[idx].label) {
    cuicReports[idx].label = generateLabelFromName(cuicReports[idx].name);
  }
  
  renderCuicReports();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FILTER WIZARD DISCOVERY & RENDERING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function renderFilterPanel(report, idx) {
  const filters = report.filters || {};
  const meta = report._wizard_meta || filters._meta || null;

  if (!meta) {
    // No metadata at all
    if (Object.keys(filters).length > 0) {
      return `<details class="filter-panel-collapsible"><summary class="filter-panel-toggle">\uD83C\uDFA8 Saved Filters (raw)</summary><div class="filter-panel">
        <pre style="font-size:11px;color:var(--muted);overflow-x:auto;">${esc(JSON.stringify(filters,null,2))}</pre>
        <button class="btn-discover" style="margin-top:6px" onclick="discoverFilters(${idx})">\u25B6 Re-discover</button>
      </div></details>`;
    }
    return '';
  }

  const isCuic = meta.type === 'cuic_spab';
  const isMultiStep = meta.type === 'cuic_multistep';
  const icon = isMultiStep ? '\uD83E\uDDE9' : (isCuic ? '\uD83C\uDFAF' : '\uD83C\uDFA8');

  let html = `<details class="filter-panel-collapsible"><summary class="filter-panel-toggle">${icon} Filter Wizard Settings
      <span class="filter-clear" onclick="event.stopPropagation();clearFilters(${idx})">\u2716 Clear all</span>
    </summary><div class="filter-panel">`;

  if (isMultiStep) {
    // â”€â”€ CUIC multi-step wizard (e.g., call_type_hist) â”€â”€
    const steps = meta.steps || [];
    const stepTitles = meta.stepTitles || steps.map((s,i) => 'Step ' + (i+1));
    console.log('[renderFilterPanel] Multi-step meta:', JSON.stringify(meta, null, 2));

    // Step navigation tabs
    html += `<div class="wizard-step-tabs" id="wst-${idx}">`;
    stepTitles.forEach((title, si) => {
      if (si > 0) html += `<span class="wst-arrow">\u25B6</span>`;
      html += `<span class="wst-tab${si===0?' active':''}" onclick="switchWizardTab(${idx},${si})">${esc(title)}</span>`;
    });
    html += `</div>`;

    // Step bodies
    steps.forEach((step, si) => {
      const stepKey = 'step_' + step.step;
      const savedStep = filters[stepKey] || {};
      const activeClass = si === 0 ? ' active' : '';

      html += `<div class="wizard-step-body${activeClass}" id="wsb-${idx}-${si}">`;

      (step.params || []).forEach(p => {
        const pn = p.paramName || '';
        const label = p.label || pn;
        const savedVal = savedStep[pn];

        if (p.type === 'cuic_datetime') {
          const cfg = typeof savedVal === 'string' ? {preset: savedVal}
                    : (savedVal && typeof savedVal === 'object' ? savedVal : {});
          const curPreset = cfg.preset || '';
          const presets = p.datePresets || meta.datePresets || [];
          let opts = presets.map(o => {
            const sel = curPreset === o.value ? 'selected' : '';
            return `<option value="${attr(o.value)}" ${sel}>${esc(o.label)}</option>`;
          }).join('');
          const noSel = !curPreset ? 'selected' : '';
          opts = `<option value="" ${noSel}>\u2014 use default \u2014</option>` + opts;
          const dtId = 'dt-' + idx + '-s' + step.step + '-' + pn.replace(/[^a-zA-Z0-9]/g,'_');

          html += `<div class="filter-field">
            <label title="${attr(pn)}">${esc(label)}</label>
            <select id="${dtId}-preset" onchange="updateMsDatetime(${idx},'${attr(stepKey)}','${attr(pn)}','preset',this.value)">${opts}</select>
          </div>`;

          if (p.hasDateRange) {
            const showDates = curPreset === 'CUSTOM' ? '' : 'style="display:none"';
            const d1 = cfg.date1 || '';
            const d2 = cfg.date2 || '';
            html += `<div class="filter-sub" id="${dtId}-dates" ${showDates}>
              <div class="sub-row">
                <label>From</label>
                <input type="date" value="${attr(d1)}" onchange="updateMsDatetime(${idx},'${attr(stepKey)}','${attr(pn)}','date1',this.value)">
                <span class="to">to</span>
                <input type="date" value="${attr(d2)}" onchange="updateMsDatetime(${idx},'${attr(stepKey)}','${attr(pn)}','date2',this.value)">
              </div>
            </div>`;
          }

          if (p.hasTimeRange) {
            const allTime = cfg.allTime || 1;
            const t1 = cfg.time1 || '';
            const t2 = cfg.time2 || '';
            const showTimes = allTime === 2 ? '' : 'style="display:none"';
            html += `<div class="filter-sub">
              <div class="sub-row">
                <label>Time</label>
                <select onchange="updateMsDatetime(${idx},'${attr(stepKey)}','${attr(pn)}','allTime',parseInt(this.value));
                  document.getElementById('${dtId}-times').style.display=this.value==='2'?'':'none'">
                  <option value="1" ${allTime===1?'selected':''}>All Day</option>
                  <option value="2" ${allTime===2?'selected':''}>Custom</option>
                </select>
              </div>
              <div class="sub-row" id="${dtId}-times" ${showTimes}>
                <label>From</label>
                <input type="time" step="1" value="${attr(t1)}" onchange="updateMsDatetime(${idx},'${attr(stepKey)}','${attr(pn)}','time1',this.value)">
                <span class="to">to</span>
                <input type="time" step="1" value="${attr(t2)}" onchange="updateMsDatetime(${idx},'${attr(stepKey)}','${attr(pn)}','time2',this.value)">
              </div>
            </div>`;
          }

        } else if (p.type === 'cuic_field_filter') {
          // Field Filters â€” multi-select with operator & value per field
          const fields = p.availableFields || [];
          const isAll = savedVal === 'all';
          // savedVal can be: 'all', ['field1','field2'], or [{id:'field1',operator:'EQ',value1:'10'}]
          let selectedConfigs = [];
          if (isAll) {
            selectedConfigs = fields.map(f => ({id: f.fieldId || f.label}));
          } else if (Array.isArray(savedVal)) {
            selectedConfigs = savedVal.map(v => {
              if (typeof v === 'string') return {id: v};
              if (typeof v === 'object' && v.id) return v;
              return null;
            }).filter(Boolean);
          } else if (savedVal === undefined && p.selectedFieldIds && p.selectedFieldIds.length > 0) {
            // Fall back to pre-selected fields from CUIC
            selectedConfigs = p.selectedFieldIds.map(id => ({id}));
          }

          const ffId = 'ff-' + idx + '-s' + step.step + '-' + pn.replace(/[^a-zA-Z0-9]/g,'_');
          const badge = `<span class="vl-badge">${fields.length} fields</span>`;

          html += `<div class="filter-field">
            <label title="${attr(pn)}">${esc(label)} ${badge}</label>
            <span id="${ffId}-selcount" style="font-size:12px;color:${selectedConfigs.length>0?'var(--green)':'var(--muted)'}">${selectedConfigs.length} selected</span>
          </div>`;

          /* â”€â”€ Selected fields with criteria (always rendered, updated in-place) â”€â”€ */
          html += `<div class="ff-selected-list" id="${ffId}-selected" data-ridx="${idx}" data-stepkey="${attr(stepKey)}" data-pn="${attr(pn)}">`;
          if (selectedConfigs.length > 0) {
            selectedConfigs.forEach((cfg, cfgIdx) => {
              const field = fields.find(f => (f.fieldId || f.label) === cfg.id);
              if (!field) return;
              const fLabel = field.label || cfg.id;
              const op = cfg.operator || '';
              const v1 = cfg.value1 || '';
              const v2 = cfg.value2 || '';
              
              html += `<div class="ff-selected-item" data-fid="${attr(cfg.id)}">
                <div class="ff-si-header">
                  <span class="ff-si-label">${esc(fLabel)}</span>
                  <span class="ff-si-fid">(${esc(cfg.id)})</span>
                  <button class="ff-si-remove" onclick="ffRemoveField(${idx},'${attr(stepKey)}','${attr(pn)}','${attr(cfg.id)}')">Ã—</button>
                </div>
                <div class="ff-si-criteria">
                  <div>
                    <label>Operator:</label>
                    <select onchange="ffUpdateField(${idx},'${attr(stepKey)}','${attr(pn)}','${attr(cfg.id)}','operator',this.value)">
                      <option value="">â€” select â€”</option>
                      <option value="EQ"${op==='EQ'?' selected':''}>Equal to</option>
                      <option value="NEQ"${op==='NEQ'||op==='NE'?' selected':''}>Not equal to</option>
                      <option value="G"${op==='G'||op==='GT'?' selected':''}>Greater than</option>
                      <option value="GEQ"${op==='GEQ'||op==='GE'?' selected':''}>Greater or equal</option>
                      <option value="L"${op==='L'||op==='LT'?' selected':''}>Less than</option>
                      <option value="LEQ"${op==='LEQ'||op==='LE'?' selected':''}>Less or equal</option>
                      <option value="BTWN"${op==='BTWN'||op==='BW'?' selected':''}>Between</option>
                    </select>
                  </div>
                  <div>
                    <label>Value:</label>
                    <input type="text" value="${attr(v1)}" placeholder="Value"
                      onchange="ffUpdateField(${idx},'${attr(stepKey)}','${attr(pn)}','${attr(cfg.id)}','value1',this.value)">
                  </div>
                  ${op==='BTWN'||op==='BW'?`<div>
                    <label>To:</label>
                    <input type="text" value="${attr(v2)}" placeholder="Upper bound"
                      onchange="ffUpdateField(${idx},'${attr(stepKey)}','${attr(pn)}','${attr(cfg.id)}','value2',this.value)">
                  </div>`:''}
                </div>
              </div>`;
            });
          } else {
            html += `<p class="ff-empty-msg">No fields selected. Choose fields below to add criteria.</p>`;
          }
          html += `</div>`;

          /* â”€â”€ Available fields checklist â”€â”€ */
          html += `<div class="ff-section" id="${ffId}-section">
            <div class="ff-toolbar">
              <input type="text" id="${ffId}-search" placeholder="ğŸ” Filter fields..."
                oninput="filterFfChecklist('${ffId}',this.value)">
              <button onclick="ffMsCheckAll(${idx},'${attr(stepKey)}','${attr(pn)}','${ffId}')">â˜‘ All</button>
              <button onclick="ffMsUncheckAll(${idx},'${attr(stepKey)}','${attr(pn)}','${ffId}')">â˜ None</button>
            </div>
            <div class="ff-checklist" id="${ffId}-list"
              onchange="ffToggleItem(${idx},'${attr(stepKey)}','${attr(pn)}','${ffId}',event)">`;

          fields.forEach(f => {
            const fid = f.fieldId || f.label;
            const checked = selectedConfigs.some(c => c.id === fid) ? 'checked' : '';
            html += `<label data-name="${attr((f.combined || f.label || '').toLowerCase())}" data-label="${attr(f.label)}">
              <input type="checkbox" value="${attr(fid)}" ${checked}>
              <span>${esc(f.label)}</span>
              <span class="ff-field-id">${esc(f.fieldId)}</span>
            </label>`;
          });

          html += `</div></div>`;


        } else if (p.type === 'cuic_valuelist') {
          const isAll = savedVal === 'all';
          const isSpecific = Array.isArray(savedVal);
          // Fall back to pre-selected values from CUIC when no saved config
          const selectedNames = isSpecific ? savedVal
            : (savedVal === undefined && p.selectedValues && p.selectedValues.length > 0 ? p.selectedValues : []);
          const allNames = p.availableNames || [];
          const badge = `<span class="vl-badge">${allNames.length} available</span>`;
          const vlId = 'vl-' + idx + '-s' + step.step + '-' + pn.replace(/[^a-zA-Z0-9]/g,'_');
          const selCount = isAll ? allNames.length : selectedNames.length;

          html += `<div class="filter-field">
            <label title="${attr(pn)}">${esc(label)} ${badge}</label>
            <span id="${vlId}-selcount" style="font-size:12px;color:${selCount>0?'var(--green)':'var(--muted)'}">${selCount} selected</span>
          </div>`;

          /* â”€â”€ Selected values summary (green tags â€” always rendered, updated in-place) â”€â”€ */
          html += `<div class="vl-selected-summary" id="${vlId}-summary"
            data-type="vl-ms" data-ridx="${idx}" data-stepkey="${attr(stepKey)}" data-pn="${attr(pn)}" data-baseid="${vlId}">`;
          const showNames = isAll ? allNames : selectedNames;
          if (showNames.length > 0) {
            const MAX_TAGS = 20;
            html += `<span class="vl-sel-label">âœ… Selected:</span>`;
            showNames.slice(0, MAX_TAGS).forEach(n => {
              html += `<span class="vl-sel-tag">${esc(n)}<span class="vl-sel-x" onclick="deselectAndRefresh('${vlId}','${attr(n)}')">&times;</span></span>`;
            });
            if (showNames.length > MAX_TAGS) {
              html += `<span class="vl-sel-more">+${showNames.length - MAX_TAGS} more</span>`;
            }
          }
          html += `</div>`;

          const groups = p.availableGroups || [];
          html += `<div class="vl-section" id="${vlId}-section">`;

          if (groups.length) {
            html += `<div class="vl-groups" id="${vlId}-groups">`;
            groups.forEach((g, gi) => {
              const members = g.members || [];
              const allChecked = members.length > 0 && members.every(m => isAll || selectedNames.includes(m));
              html += `<button class="vl-group-btn${allChecked?' active':''}" data-gidx="${gi}"
                onclick="vlMsToggleGroup(${idx},'${attr(stepKey)}','${attr(pn)}','${vlId}',${gi})">
                ${esc(g.name)} <span class="vl-g-count">(${g.count})</span>
              </button>`;
            });
            html += `</div>`;
          }

          html += `<div class="vl-toolbar">
              <input type="text" id="${vlId}-search" placeholder="\uD83D\uDD0D Filter names..."
                oninput="filterVlChecklist('${vlId}',this.value)">
              <button onclick="vlMsCheckAll(${idx},'${attr(stepKey)}','${attr(pn)}','${vlId}')">\u2611 All</button>
              <button onclick="vlMsUncheckAll(${idx},'${attr(stepKey)}','${attr(pn)}','${vlId}')">\u2610 None</button>
              <span class="vl-count" id="${vlId}-count">${selCount} / ${allNames.length}</span>
            </div>
            <div class="vl-checklist" id="${vlId}-list">`;

          allNames.forEach(n => {
            const checked = isAll || selectedNames.includes(n) ? 'checked' : '';
            const memberOf = groups.filter(g => (g.members||[]).includes(n)).map(g => g.name).join(',');
            html += `<label data-name="${attr(n.toLowerCase())}" data-groups="${attr(memberOf)}">
              <input type="checkbox" value="${attr(n)}" ${checked}
                onchange="vlMsToggleItem(${idx},'${attr(stepKey)}','${attr(pn)}','${vlId}')">
              <span>${esc(n)}</span>
            </label>`;
          });

          html += `</div></div>`;

        } else if (p.type === 'checkbox') {
          const checked = savedVal !== undefined ? savedVal : (p.currentValue || false);
          html += `<div class="filter-field">
            <label title="${attr(pn)}">${esc(label)}</label>
            <input type="checkbox" ${checked?'checked':''}
              onchange="updateMsFilter(${idx},'${attr(stepKey)}','${attr(pn)}',this.checked)"
              style="width:auto;">
          </div>`;

        } else {
          const val = savedVal !== undefined ? savedVal : (p.currentValue || '');
          const inputType = p.type === 'number' ? 'number' : 'text';
          html += `<div class="filter-field">
            <label title="${attr(pn)}">${esc(label)}</label>
            <input type="${inputType}" value="${attr(String(val))}"
              onchange="updateMsFilter(${idx},'${attr(stepKey)}','${attr(pn)}',this.value)">
          </div>`;
        }
      });

      html += `</div>`; // close wizard-step-body
    });

    html += '</div></details>';
    return html;
  }

  if (isCuic) {
    // â”€â”€ CUIC AngularJS params (flat param-name keys) â”€â”€
    const params = meta.params || [];
    params.forEach(p => {
      const pn = p.paramName || '';
      const label = p.label || pn;
      const savedVal = filters[pn];

      if (p.type === 'cuic_datetime') {
        // Saved value can be a string preset or an object {preset, date1, date2, allTime, time1, time2}
        const cfg = typeof savedVal === 'string' ? {preset: savedVal}
                  : (savedVal && typeof savedVal === 'object' ? savedVal : {});
        const curPreset = cfg.preset || '';

        // Date Range preset dropdown
        const presets = p.datePresets || [];
        let opts = presets.map(o => {
          const sel = curPreset === o.value ? 'selected' : '';
          return `<option value="${attr(o.value)}" ${sel}>${esc(o.label)}</option>`;
        }).join('');
        const noSel = !curPreset ? 'selected' : '';
        opts = `<option value="" ${noSel}>\u2014 use default \u2014</option>` + opts;

        const dtId = 'dt-' + idx + '-' + pn.replace(/[^a-zA-Z0-9]/g,'_');
        html += `<div class="filter-field">
          <label title="${attr(pn)}">${esc(label)}</label>
          <select id="${dtId}-preset" onchange="updateCuicDatetime(${idx},'${attr(pn)}','preset',this.value)">${opts}</select>
        </div>`;

        // Custom date range (shown when preset = CUSTOM)
        if (p.hasDateRange) {
          const showDates = curPreset === 'CUSTOM' ? '' : 'style="display:none"';
          const d1 = cfg.date1 || '';
          const d2 = cfg.date2 || '';
          html += `<div class="filter-sub" id="${dtId}-dates" ${showDates}>
            <div class="sub-row">
              <label>From</label>
              <input type="date" value="${attr(d1)}" onchange="updateCuicDatetime(${idx},'${attr(pn)}','date1',this.value)">
              <span class="to">to</span>
              <input type="date" value="${attr(d2)}" onchange="updateCuicDatetime(${idx},'${attr(pn)}','date2',this.value)">
            </div>
          </div>`;
        }

        // Time range (All Day / Custom)
        if (p.hasTimeRange) {
          const allTime = cfg.allTime || 1;
          const t1 = cfg.time1 || '';
          const t2 = cfg.time2 || '';
          const showTimes = allTime === 2 ? '' : 'style="display:none"';
          html += `<div class="filter-sub">
            <div class="sub-row">
              <label>Time</label>
              <select onchange="updateCuicDatetime(${idx},'${attr(pn)}','allTime',parseInt(this.value));
                document.getElementById('${dtId}-times').style.display=this.value==='2'?'':'none'">
                <option value="1" ${allTime===1?'selected':''}>All Day</option>
                <option value="2" ${allTime===2?'selected':''}>Custom</option>
              </select>
            </div>
            <div class="sub-row" id="${dtId}-times" ${showTimes}>
              <label>From</label>
              <input type="time" step="1" value="${attr(t1)}" onchange="updateCuicDatetime(${idx},'${attr(pn)}','time1',this.value)">
              <span class="to">to</span>
              <input type="time" step="1" value="${attr(t2)}" onchange="updateCuicDatetime(${idx},'${attr(pn)}','time2',this.value)">
            </div>
          </div>`;
        }

      } else if (p.type === 'cuic_field_filter') {
        // Field Filters â€” searchable multi-select checklist (SPAB)
        const fields = p.availableFields || [];
        const isAll = savedVal === 'all';
        const isSpecific = Array.isArray(savedVal);
        // Fall back to pre-selected fields from CUIC when no saved config
        const selectedIds = isSpecific ? savedVal
          : (savedVal === undefined && p.selectedFieldIds && p.selectedFieldIds.length > 0 ? p.selectedFieldIds : []);
        const ffId = 'ff-' + idx + '-' + pn.replace(/[^a-zA-Z0-9]/g,'_');
        const selCount = isAll ? fields.length : selectedIds.length;
        const badge = `<span class="vl-badge">${fields.length} fields</span>`;
        const ffLabelMapSp = {};
        fields.forEach(f => { ffLabelMapSp[f.fieldId || f.label] = f.label; });

        html += `<div class="filter-field">
          <label title="${attr(pn)}">${esc(label)} ${badge}</label>
          <span id="${ffId}-selcount" style="font-size:12px;color:${selCount>0?'var(--green)':'var(--muted)'}">${selCount} selected</span>
        </div>`;

        /* â”€â”€ Selected fields summary (green tags â€” always rendered) â”€â”€ */
        html += `<div class="vl-selected-summary" id="${ffId}-summary"
          data-type="ff" data-ridx="${idx}" data-pn="${attr(pn)}" data-baseid="${ffId}"
          data-labelmap='${JSON.stringify(ffLabelMapSp).replace(/'/g,"&#39;")}'>`;
        const showFieldsSp = isAll ? fields : fields.filter(f => selectedIds.includes(f.fieldId || f.label));
        if (showFieldsSp.length > 0) {
          const MAX_TAGS = 20;
          html += `<span class="vl-sel-label">âœ… Selected:</span>`;
          showFieldsSp.slice(0, MAX_TAGS).forEach(f => {
            const fid = f.fieldId || f.label;
            html += `<span class="vl-sel-tag">${esc(f.label)}<span class="vl-sel-x" onclick="deselectAndRefresh('${ffId}','${attr(fid)}')">&times;</span></span>`;
          });
          if (showFieldsSp.length > MAX_TAGS) {
            html += `<span class="vl-sel-more">+${showFieldsSp.length - MAX_TAGS} more</span>`;
          }
        }
        html += `</div>`;

        html += `<div class="ff-section" id="${ffId}-section">
          <div class="ff-toolbar">
            <input type="text" id="${ffId}-search" placeholder="\uD83D\uDD0D Filter fields..."
              oninput="filterFfChecklist('${ffId}',this.value)">
            <button onclick="ffCheckAll(${idx},'${attr(pn)}','${ffId}')">â˜‘ All</button>
            <button onclick="ffUncheckAll(${idx},'${attr(pn)}','${ffId}')">â˜ None</button>
            <span class="ff-count" id="${ffId}-count">${selCount} / ${fields.length}</span>
          </div>
          <div class="ff-checklist" id="${ffId}-list">`;

        fields.forEach(f => {
          const fid = f.fieldId || f.label;
          const checked = isAll || selectedIds.includes(fid) ? 'checked' : '';
          html += `<label data-name="${attr((f.combined || f.label || '').toLowerCase())}" data-label="${attr(f.label)}">
            <input type="checkbox" value="${attr(fid)}" ${checked}
              onchange="ffSpabToggleItem(${idx},'${attr(pn)}','${ffId}')">
            <span>${esc(f.label)}</span>
            <span class="ff-field-id">${esc(f.fieldId)}</span>
          </label>`;
        });

        html += `</div></div>`;

      } else if (p.type === 'cuic_valuelist') {
        // Value list with checkbox grid
        const isAll = savedVal === 'all';
        const isSpecific = Array.isArray(savedVal);
        // Fall back to pre-selected values from CUIC when no saved config
        const selectedNames = isSpecific ? savedVal
          : (savedVal === undefined && p.selectedValues && p.selectedValues.length > 0 ? p.selectedValues : []);
        const allNames = p.availableNames || [];
        const badge = `<span class="vl-badge">${allNames.length} available</span>`;
        const vlId = 'vl-' + idx + '-' + pn.replace(/[^a-zA-Z0-9]/g,'_');
        const selCount = isAll ? allNames.length : selectedNames.length;

        html += `<div class="filter-field">
          <label title="${attr(pn)}">${esc(label)} ${badge}</label>
          <span id="${vlId}-selcount" style="font-size:12px;color:${selCount>0?'var(--green)':'var(--muted)'}">${selCount} selected</span>
        </div>`;

        /* â”€â”€ Selected values summary (green tags â€” always rendered) â”€â”€ */
        html += `<div class="vl-selected-summary" id="${vlId}-summary"
          data-type="vl" data-ridx="${idx}" data-pn="${attr(pn)}" data-baseid="${vlId}">`;
        const showNamesSp = isAll ? allNames : selectedNames;
        if (showNamesSp.length > 0) {
          const MAX_TAGS = 20;
          html += `<span class="vl-sel-label">âœ… Selected:</span>`;
          showNamesSp.slice(0, MAX_TAGS).forEach(n => {
            html += `<span class="vl-sel-tag">${esc(n)}<span class="vl-sel-x" onclick="deselectAndRefresh('${vlId}','${attr(n)}')">&times;</span></span>`;
          });
          if (showNamesSp.length > MAX_TAGS) {
            html += `<span class="vl-sel-more">+${showNamesSp.length - MAX_TAGS} more</span>`;
          }
        }
        html += `</div>`;

        // Groups + Toolbar: search + select all / deselect all
        const groups = p.availableGroups || [];
        html += `<div class="vl-section" id="${vlId}-section">`;

        // Group toggle buttons
        if (groups.length) {
          html += `<div class="vl-groups" id="${vlId}-groups">`;
          groups.forEach((g, gi) => {
            const members = g.members || [];
            const allChecked = members.length > 0 && members.every(m => isAll || selectedNames.includes(m));
            html += `<button class="vl-group-btn${allChecked?' active':''}" data-gidx="${gi}"
              onclick="vlToggleGroup(${idx},'${attr(pn)}','${vlId}',${gi})">
              ${esc(g.name)} <span class="vl-g-count">(${g.count})</span>
            </button>`;
          });
          html += `</div>`;
        }

        html += `<div class="vl-toolbar">
            <input type="text" id="${vlId}-search" placeholder="\uD83D\uDD0D Filter names..."
              oninput="filterVlChecklist('${vlId}',this.value)">
            <button onclick="vlCheckAll(${idx},'${attr(pn)}','${vlId}')">\u2611 All</button>
            <button onclick="vlUncheckAll(${idx},'${attr(pn)}','${vlId}')">\u2610 None</button>
            <span class="vl-count" id="${vlId}-count">${selCount} / ${allNames.length}</span>
          </div>
          <div class="vl-checklist" id="${vlId}-list">`;

        // Build a set of group members for highlighting
        const groupMemberSet = new Set();
        groups.forEach(g => (g.members || []).forEach(m => groupMemberSet.add(m)));

        // All items as checkboxes
        allNames.forEach(n => {
          const checked = isAll || selectedNames.includes(n) ? 'checked' : '';
          // Tag each checkbox with its group memberships for toggle logic
          const memberOf = groups.filter(g => (g.members||[]).includes(n)).map(g => g.name).join(',');
          html += `<label data-name="${attr(n.toLowerCase())}" data-groups="${attr(memberOf)}">
            <input type="checkbox" value="${attr(n)}" ${checked}
              onchange="vlToggleItem(${idx},'${attr(pn)}','${vlId}')">
            <span>${esc(n)}</span>
          </label>`;
        });

        html += `</div>
        </div>`;

      } else if (p.type === 'checkbox') {
        const checked = savedVal !== undefined ? savedVal : (p.currentValue || false);
        html += `<div class="filter-field">
          <label title="${attr(pn)}">${esc(label)}</label>
          <input type="checkbox" ${checked?'checked':''}
            onchange="updateCuicFilter(${idx},'${attr(pn)}',this.checked)"
            style="width:auto;">
        </div>`;

      } else {
        // text / number
        const val = savedVal !== undefined ? savedVal : (p.currentValue || '');
        const inputType = p.type === 'number' ? 'number' : 'text';
        html += `<div class="filter-field">
          <label title="${attr(pn)}">${esc(label)}</label>
          <input type="${inputType}" value="${attr(String(val))}"
            onchange="updateCuicFilter(${idx},'${attr(pn)}',this.value)">
        </div>`;
      }
    });
    html += '</div>';
    return html;
  }

  // â”€â”€ Generic step-based wizard â”€â”€
  (meta.steps || []).forEach(step => {
    const stepKey = 'step_' + step.step;
    const savedStep = filters[stepKey] || {};
    html += `<div class="filter-step">
      <div class="step-label">Step ${step.step}</div>`;

    (step.fields || []).forEach(field => {
      const key = field.id || field.name || field.label || '';
      if (!key) return;
      const savedVal = savedStep[key];
      const displayLabel = field.label || field.name || field.id;

      if (field.type === 'select') {
        const isMulti = field.multiple ? 'multiple' : '';
        let opts = (field.options || []).map(o => {
          const sel = savedVal !== undefined
            ? (Array.isArray(savedVal) ? savedVal.includes(o.value) : savedVal === o.value)
            : o.selected;
          return `<option value="${attr(o.value)}" ${sel?'selected':''}>${esc(o.text)}</option>`;
        }).join('');
        html += `<div class="filter-field">
          <label title="${attr(key)}">${esc(displayLabel)}</label>
          <select ${isMulti} onchange="updateFilterValue(${idx},'${stepKey}','${attr(key)}',this)">${opts}</select>
        </div>`;
      } else if (field.type === 'checkbox') {
        const checked = savedVal !== undefined ? savedVal : field.value;
        html += `<div class="filter-field">
          <label title="${attr(key)}">${esc(displayLabel)}</label>
          <input type="checkbox" ${checked?'checked':''}
            onchange="updateFilterValue(${idx},'${stepKey}','${attr(key)}',this)"
            style="width:auto;">
        </div>`;
      } else {
        const val = savedVal !== undefined ? savedVal : (field.value || '');
        const inputType = field.inputType || 'text';
        html += `<div class="filter-field">
          <label title="${attr(key)}">${esc(displayLabel)}</label>
          <input type="${inputType}" value="${attr(String(val))}"
            onchange="updateFilterValue(${idx},'${stepKey}','${attr(key)}',this)">
        </div>`;
      }
    });
    html += '</div>';
  });
  html += '</div></details>';
  return html;
}

/* â”€â”€ CUIC flat filter update â”€â”€ */
function updateCuicFilter(reportIdx, paramName, value) {
  const report = cuicReports[reportIdx];
  if (!report.filters) report.filters = {};
  if (value === '' || value === undefined) {
    delete report.filters[paramName];
  } else {
    report.filters[paramName] = value;
  }
}

/* â”€â”€ CUIC datetime update (builds object: {preset, date1, date2, allTime, time1, time2}) â”€â”€ */
function updateCuicDatetime(reportIdx, paramName, field, value) {
  const report = cuicReports[reportIdx];
  if (!report.filters) report.filters = {};

  let cur = report.filters[paramName];
  // Normalize to object
  if (typeof cur === 'string') cur = {preset: cur};
  if (!cur || typeof cur !== 'object') cur = {};

  cur[field] = value;

  // When preset changes, toggle custom date fields visibility
  if (field === 'preset') {
    const dtId = 'dt-' + reportIdx + '-' + paramName.replace(/[^a-zA-Z0-9]/g,'_');
    const datesEl = document.getElementById(dtId + '-dates');
    if (datesEl) datesEl.style.display = value === 'CUSTOM' ? '' : 'none';
  }

  // If only preset and it's not CUSTOM, store as simple string
  const keys = Object.keys(cur).filter(k => cur[k] !== undefined && cur[k] !== '');
  if (keys.length === 1 && keys[0] === 'preset' && cur.preset !== 'CUSTOM') {
    report.filters[paramName] = cur.preset || undefined;
    if (!cur.preset) delete report.filters[paramName];
  } else {
    report.filters[paramName] = cur;
  }
}

/* â”€â”€ CUIC valuelist: toggle a single checkbox â”€â”€ */
function vlToggleItem(reportIdx, paramName, vlId) {
  const report = cuicReports[reportIdx];
  if (!report.filters) report.filters = {};
  const listEl = document.getElementById(vlId + '-list');
  if (!listEl) return;
  const checked = Array.from(listEl.querySelectorAll('input[type=checkbox]:checked')).map(cb => cb.value);
  const total = listEl.querySelectorAll('input[type=checkbox]').length;
  report.filters[paramName] = checked.length === total ? 'all' : checked;
  // Update count
  const countEl = document.getElementById(vlId + '-count');
  if (countEl) countEl.textContent = checked.length + ' / ' + total;
  // Update group button highlights
  vlUpdateGroupButtons(vlId, reportIdx, paramName);
  // Refresh summary tags in-place
  _refreshSummaryTags(vlId);
}

/* â”€â”€ CUIC valuelist: check all (visible) â”€â”€ */
function vlCheckAll(reportIdx, paramName, vlId) {
  const listEl = document.getElementById(vlId + '-list');
  if (!listEl) return;
  listEl.querySelectorAll('label').forEach(lbl => {
    if (lbl.style.display !== 'none') {
      const cb = lbl.querySelector('input[type=checkbox]');
      if (cb) cb.checked = true;
    }
  });
  vlToggleItem(reportIdx, paramName, vlId);
}

/* â”€â”€ CUIC valuelist: uncheck all (visible) â”€â”€ */
function vlUncheckAll(reportIdx, paramName, vlId) {
  const listEl = document.getElementById(vlId + '-list');
  if (!listEl) return;
  listEl.querySelectorAll('label').forEach(lbl => {
    if (lbl.style.display !== 'none') {
      const cb = lbl.querySelector('input[type=checkbox]');
      if (cb) cb.checked = false;
    }
  });
  vlToggleItem(reportIdx, paramName, vlId);
}

/* â”€â”€ CUIC valuelist: filter checklist by search text â”€â”€ */
function filterVlChecklist(vlId, query) {
  const listEl = document.getElementById(vlId + '-list');
  if (!listEl) return;
  const q = (query || '').toLowerCase();
  listEl.querySelectorAll('label').forEach(lbl => {
    const name = lbl.getAttribute('data-name') || '';
    lbl.style.display = (!q || name.includes(q)) ? '' : 'none';
  });
}

/* â”€â”€ CUIC valuelist: toggle a group (select/deselect all its members) â”€â”€ */
function vlToggleGroup(reportIdx, paramName, vlId, groupIdx) {
  const report = cuicReports[reportIdx];
  const meta = report._wizard_meta || (report.filters && report.filters._meta) || {};
  const params = meta.params || [];
  const p = params.find(pp => pp.paramName === paramName);
  if (!p) return;
  const group = (p.availableGroups || [])[groupIdx];
  if (!group || !group.members) return;

  const listEl = document.getElementById(vlId + '-list');
  if (!listEl) return;

  // Determine current state: if all members are checked, uncheck them; otherwise check all
  const memberSet = new Set(group.members);
  const memberCbs = Array.from(listEl.querySelectorAll('input[type=checkbox]'))
    .filter(cb => memberSet.has(cb.value));
  const allChecked = memberCbs.every(cb => cb.checked);

  memberCbs.forEach(cb => cb.checked = !allChecked);

  // Update data model
  vlToggleItem(reportIdx, paramName, vlId);

  // Update group button active state
  vlUpdateGroupButtons(vlId, reportIdx, paramName);
}

/* â”€â”€ Update group button active/inactive styling â”€â”€ */
function vlUpdateGroupButtons(vlId, reportIdx, paramName) {
  const groupsEl = document.getElementById(vlId + '-groups');
  if (!groupsEl) return;
  const report = cuicReports[reportIdx];
  const meta = report._wizard_meta || (report.filters && report.filters._meta) || {};
  const params = meta.params || [];
  const p = params.find(pp => pp.paramName === paramName);
  if (!p) return;

  const listEl = document.getElementById(vlId + '-list');
  if (!listEl) return;
  const checkedVals = new Set(Array.from(listEl.querySelectorAll('input[type=checkbox]:checked')).map(cb => cb.value));

  groupsEl.querySelectorAll('.vl-group-btn').forEach(btn => {
    const gi = parseInt(btn.getAttribute('data-gidx'));
    const g = (p.availableGroups || [])[gi];
    if (!g || !g.members) return;
    const allIn = g.members.every(m => checkedVals.has(m));
    btn.classList.toggle('active', allIn);
  });
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   MULTI-STEP WIZARD HELPERS
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

/* â”€â”€ Find a param in multi-step meta by stepKey + paramName â”€â”€ */
function _findMsParam(meta, stepKey, paramName) {
  const stepNum = parseInt(stepKey.replace('step_', ''));
  const step = (meta.steps || []).find(s => s.step === stepNum);
  if (!step) return null;
  return (step.params || []).find(p => p.paramName === paramName) || null;
}

/* â”€â”€ Switch wizard step tab â”€â”€ */
function switchWizardTab(idx, tabIdx) {
  const tabs = document.getElementById('wst-' + idx);
  if (!tabs) return;
  tabs.querySelectorAll('.wst-tab').forEach((t, i) => t.classList.toggle('active', i === tabIdx));
  let si = 0, body;
  while ((body = document.getElementById('wsb-' + idx + '-' + si))) {
    body.classList.toggle('active', si === tabIdx);
    si++;
  }
}

/* â”€â”€ Multi-step: basic filter update â”€â”€ */
function updateMsFilter(reportIdx, stepKey, paramName, value) {
  const report = cuicReports[reportIdx];
  if (!report.filters) report.filters = {};
  if (!report.filters[stepKey]) report.filters[stepKey] = {};
  if (value === '' || value === undefined) {
    delete report.filters[stepKey][paramName];
  } else {
    report.filters[stepKey][paramName] = value;
  }
}

/* â”€â”€ Multi-step: datetime update â”€â”€ */
function updateMsDatetime(reportIdx, stepKey, paramName, field, value) {
  const report = cuicReports[reportIdx];
  if (!report.filters) report.filters = {};
  if (!report.filters[stepKey]) report.filters[stepKey] = {};

  let cur = report.filters[stepKey][paramName];
  if (typeof cur === 'string') cur = {preset: cur};
  if (!cur || typeof cur !== 'object') cur = {};
  cur[field] = value;

  if (field === 'preset') {
    const sn = stepKey.replace('step_','');
    const dtId = 'dt-' + reportIdx + '-s' + sn + '-' + paramName.replace(/[^a-zA-Z0-9]/g,'_');
    const datesEl = document.getElementById(dtId + '-dates');
    if (datesEl) datesEl.style.display = value === 'CUSTOM' ? '' : 'none';
  }

  const keys = Object.keys(cur).filter(k => cur[k] !== undefined && cur[k] !== '');
  if (keys.length === 1 && keys[0] === 'preset' && cur.preset !== 'CUSTOM') {
    report.filters[stepKey][paramName] = cur.preset || undefined;
    if (!cur.preset) delete report.filters[stepKey][paramName];
  } else {
    report.filters[stepKey][paramName] = cur;
  }
}

/* â”€â”€ Multi-step valuelist: toggle single item â”€â”€ */
function vlMsToggleItem(reportIdx, stepKey, paramName, vlId) {
  const report = cuicReports[reportIdx];
  if (!report.filters) report.filters = {};
  if (!report.filters[stepKey]) report.filters[stepKey] = {};
  const listEl = document.getElementById(vlId + '-list');
  if (!listEl) return;
  const checked = Array.from(listEl.querySelectorAll('input[type=checkbox]:checked')).map(cb => cb.value);
  const total = listEl.querySelectorAll('input[type=checkbox]').length;
  report.filters[stepKey][paramName] = checked.length === total ? 'all' : checked;
  const countEl = document.getElementById(vlId + '-count');
  if (countEl) countEl.textContent = checked.length + ' / ' + total;
  vlMsUpdateGroupButtons(vlId, reportIdx, stepKey, paramName);
  // Refresh summary tags in-place
  _refreshSummaryTags(vlId);
}

/* â”€â”€ Multi-step valuelist: check all visible â”€â”€ */
function vlMsCheckAll(reportIdx, stepKey, paramName, vlId) {
  const listEl = document.getElementById(vlId + '-list');
  if (!listEl) return;
  listEl.querySelectorAll('label').forEach(lbl => {
    if (lbl.style.display !== 'none') {
      const cb = lbl.querySelector('input[type=checkbox]');
      if (cb) cb.checked = true;
    }
  });
  vlMsToggleItem(reportIdx, stepKey, paramName, vlId);
}

/* â”€â”€ Multi-step valuelist: uncheck all visible â”€â”€ */
function vlMsUncheckAll(reportIdx, stepKey, paramName, vlId) {
  const listEl = document.getElementById(vlId + '-list');
  if (!listEl) return;
  listEl.querySelectorAll('label').forEach(lbl => {
    if (lbl.style.display !== 'none') {
      const cb = lbl.querySelector('input[type=checkbox]');
      if (cb) cb.checked = false;
    }
  });
  vlMsToggleItem(reportIdx, stepKey, paramName, vlId);
}

/* â”€â”€ Multi-step valuelist: toggle group â”€â”€ */
function vlMsToggleGroup(reportIdx, stepKey, paramName, vlId, groupIdx) {
  const report = cuicReports[reportIdx];
  const meta = report._wizard_meta || (report.filters && report.filters._meta) || {};
  const p = _findMsParam(meta, stepKey, paramName);
  if (!p) return;
  const group = (p.availableGroups || [])[groupIdx];
  if (!group || !group.members) return;

  const listEl = document.getElementById(vlId + '-list');
  if (!listEl) return;
  const memberSet = new Set(group.members);
  const memberCbs = Array.from(listEl.querySelectorAll('input[type=checkbox]'))
    .filter(cb => memberSet.has(cb.value));
  const allChecked = memberCbs.every(cb => cb.checked);
  memberCbs.forEach(cb => cb.checked = !allChecked);
  vlMsToggleItem(reportIdx, stepKey, paramName, vlId);
}

/* â”€â”€ Multi-step valuelist: update group button styles â”€â”€ */
function vlMsUpdateGroupButtons(vlId, reportIdx, stepKey, paramName) {
  const groupsEl = document.getElementById(vlId + '-groups');
  if (!groupsEl) return;
  const report = cuicReports[reportIdx];
  const meta = report._wizard_meta || (report.filters && report.filters._meta) || {};
  const p = _findMsParam(meta, stepKey, paramName);
  if (!p) return;

  const listEl = document.getElementById(vlId + '-list');
  if (!listEl) return;
  const checkedVals = new Set(Array.from(listEl.querySelectorAll('input[type=checkbox]:checked')).map(cb => cb.value));

  groupsEl.querySelectorAll('.vl-group-btn').forEach(btn => {
    const gi = parseInt(btn.getAttribute('data-gidx'));
    const g = (p.availableGroups || [])[gi];
    if (!g || !g.members) return;
    const allIn = g.members.every(m => checkedVals.has(m));
    btn.classList.toggle('active', allIn);
  });
}

/* â”€â”€ Unified deselect: uncheck a value and refresh summary in-place â”€â”€ */
function deselectAndRefresh(baseId, value) {
  const listEl = document.getElementById(baseId + '-list');
  if (listEl) {
    const cb = listEl.querySelector(`input[type=checkbox][value="${CSS.escape(value)}"]`);
    if (cb) {
      cb.checked = false;
      // Trigger the onchange to update the data model
      cb.dispatchEvent(new Event('change', {bubbles: true}));
    }
  }
}

/* â”€â”€ Rebuild summary tags from checklist state (no full re-render) â”€â”€ */
function _refreshSummaryTags(baseId) {
  const summaryEl = document.getElementById(baseId + '-summary');
  const selcountEl = document.getElementById(baseId + '-selcount');
  const listEl = document.getElementById(baseId + '-list');
  if (!summaryEl || !listEl) return;

  const checkedCbs = Array.from(listEl.querySelectorAll('input[type=checkbox]:checked'));
  const checkedVals = checkedCbs.map(cb => cb.value);
  const MAX_TAGS = 20;

  // Determine label for each checked value
  // For field-filters: use data-labelmap on summary div; for valuelists: value IS the label
  let labelMap = null;
  try { labelMap = JSON.parse(summaryEl.getAttribute('data-labelmap') || 'null'); } catch(e) {}

  // Build tags HTML
  let html = '';
  if (checkedVals.length > 0) {
    html += `<span class="vl-sel-label">\u2705 Selected:</span>`;
    checkedVals.slice(0, MAX_TAGS).forEach(v => {
      const displayLabel = (labelMap && labelMap[v]) ? labelMap[v] : v;
      html += `<span class="vl-sel-tag">${esc(displayLabel)}<span class="vl-sel-x" onclick="deselectAndRefresh('${baseId}','${attr(v)}')">&times;</span></span>`;
    });
    if (checkedVals.length > MAX_TAGS) {
      html += `<span class="vl-sel-more">+${checkedVals.length - MAX_TAGS} more</span>`;
    }
  }
  summaryEl.innerHTML = html;

  // Update the "N selected" count span
  if (selcountEl) {
    selcountEl.textContent = checkedVals.length + ' selected';
    selcountEl.style.color = checkedVals.length > 0 ? 'var(--green)' : 'var(--muted)';
  }
}

/* â”€â”€ Field-filter: toggle checkbox (multi-step) â”€â”€ */
function ffToggleItem(reportIdx, stepKey, paramName, ffId, event) {
  if (!event || !event.target) return;
  const cb = event.target;
  if (cb.tagName !== 'INPUT' || cb.type !== 'checkbox') return;
  
  const report = cuicReports[reportIdx];
  if (!report.filters) report.filters = {};
  if (!report.filters[stepKey]) report.filters[stepKey] = {};
  
  const fid = cb.value;
  let configs = report.filters[stepKey][paramName] || [];
  // Normalize to array of objects
  if (!Array.isArray(configs)) configs = [];
  configs = configs.map(c => typeof c === 'string' ? {id: c} : c);
  
  if (cb.checked) {
    // Add field if not already present
    if (!configs.find(c => c.id === fid)) {
      configs.push({id: fid, operator: '', value1: ''});
    }
  } else {
    // Remove field
    configs = configs.filter(c => c.id !== fid);
  }
  
  report.filters[stepKey][paramName] = configs;
  _refreshFieldFilterSelected(reportIdx, stepKey, paramName, ffId);
}

/* â”€â”€ Field-filter: check all visible â”€â”€ */
function ffMsCheckAll(reportIdx, stepKey, paramName, ffId) {
  const report = cuicReports[reportIdx];
  if (!report.filters) report.filters = {};
  if (!report.filters[stepKey]) report.filters[stepKey] = {};
  
  const listEl = document.getElementById(ffId + '-list');
  if (!listEl) return;
  
  let configs = report.filters[stepKey][paramName] || [];
  if (!Array.isArray(configs)) configs = [];
  configs = configs.map(c => typeof c === 'string' ? {id: c} : c);
  
  listEl.querySelectorAll('label').forEach(lbl => {
    if (lbl.style.display !== 'none') {
      const cb = lbl.querySelector('input[type=checkbox]');
      if (cb && !cb.checked) {
        cb.checked = true;
        const fid = cb.value;
        if (!configs.find(c => c.id === fid)) {
          configs.push({id: fid, operator: '', value1: ''});
        }
      }
    }
  });
  
  report.filters[stepKey][paramName] = configs;
  _refreshFieldFilterSelected(reportIdx, stepKey, paramName, ffId);
}

/* â”€â”€ Field-filter: uncheck all visible â”€â”€ */
function ffMsUncheckAll(reportIdx, stepKey, paramName, ffId) {
  const report = cuicReports[reportIdx];
  if (!report.filters) report.filters = {};
  if (!report.filters[stepKey]) report.filters[stepKey] = {};
  
  const listEl = document.getElementById(ffId + '-list');
  if (!listEl) return;
  
  let configs = report.filters[stepKey][paramName] || [];
  if (!Array.isArray(configs)) configs = [];
  configs = configs.map(c => typeof c === 'string' ? {id: c} : c);
  
  const visibleIds = [];
  listEl.querySelectorAll('label').forEach(lbl => {
    if (lbl.style.display !== 'none') {
      const cb = lbl.querySelector('input[type=checkbox]');
      if (cb) {
        cb.checked = false;
        visibleIds.push(cb.value);
      }
    }
  });
  
  configs = configs.filter(c => !visibleIds.includes(c.id));
  report.filters[stepKey][paramName] = configs;
  _refreshFieldFilterSelected(reportIdx, stepKey, paramName, ffId);
}

/* â”€â”€ Field-filter: remove a field from selected list â”€â”€ */
function ffRemoveField(reportIdx, stepKey, paramName, fieldId) {
  const report = cuicReports[reportIdx];
  if (!report.filters || !report.filters[stepKey]) return;
  
  let configs = report.filters[stepKey][paramName] || [];
  if (!Array.isArray(configs)) return;
  configs = configs.map(c => typeof c === 'string' ? {id: c} : c);
  configs = configs.filter(c => c.id !== fieldId);
  
  report.filters[stepKey][paramName] = configs;
  
  // Also uncheck the checkbox
  const ffId = `ff-${reportIdx}-s${stepKey.replace('step_','')}-${paramName.replace(/[^a-zA-Z0-9]/g,'_')}`;
  const listEl = document.getElementById(ffId + '-list');
  if (listEl) {
    const cb = listEl.querySelector(`input[value="${fieldId}"]`);
    if (cb) cb.checked = false;
  }
  
  _refreshFieldFilterSelected(reportIdx, stepKey, paramName, ffId);
}

/* â”€â”€ Field-filter: update operator or value for a field â”€â”€ */
function ffUpdateField(reportIdx, stepKey, paramName, fieldId, prop, val) {
  const report = cuicReports[reportIdx];
  if (!report.filters || !report.filters[stepKey]) return;
  
  let configs = report.filters[stepKey][paramName] || [];
  if (!Array.isArray(configs)) return;
  configs = configs.map(c => typeof c === 'string' ? {id: c} : c);
  
  const cfg = configs.find(c => c.id === fieldId);
  if (cfg) {
    cfg[prop] = val;
    report.filters[stepKey][paramName] = configs;
    
    // Refresh UI when operator changes (to show/hide second value field for "Between")
    if (prop === 'operator') {
      const ffId = `ff-${reportIdx}-s${stepKey.replace('step_','')}-${paramName.replace(/[^a-zA-Z0-9]/g,'_')}`;
      _refreshFieldFilterSelected(reportIdx, stepKey, paramName, ffId);
    }
  }
}

/* â”€â”€ Refresh field filter selected list (summary) â”€â”€ */
function _refreshFieldFilterSelected(reportIdx, stepKey, paramName, ffId) {
  const report = cuicReports[reportIdx];
  const configs = report.filters[stepKey]?.[paramName] || [];
  const normalConfigs = Array.isArray(configs) 
    ? configs.map(c => typeof c === 'string' ? {id: c} : c)
    : [];
  
  const countEl = document.getElementById(ffId + '-selcount');
  if (countEl) {
    countEl.textContent = `${normalConfigs.length} selected`;
    countEl.style.color = normalConfigs.length > 0 ? 'var(--green)' : 'var(--muted)';
  }
  
  // Re-render the selected list
  const selectedDiv = document.getElementById(ffId + '-selected');
  if (!selectedDiv) {
    console.warn('[FF] Selected div not found:', ffId + '-selected');
    return;
  }
  
  const ridx = selectedDiv.dataset.ridx;
  const skey = selectedDiv.dataset.stepkey;
  const pn = selectedDiv.dataset.pn;
  
  // Get field metadata from wizard meta (with fallback to filters._meta)
  const meta = report._wizard_meta || (report.filters && report.filters._meta) || {};
  const steps = meta.steps || [];
  const stepNum = parseInt(skey.replace('step_', ''));
  const step = steps.find(s => s.step === stepNum);
  if (!step) {
    console.warn('[FF] Step not found in metadata. reportIdx:', reportIdx, 'stepNum:', stepNum, 'meta.steps:', steps);
    // Fallback: render with field IDs only
    _renderFieldFilterCardsSimple(normalConfigs, selectedDiv, ridx, skey, pn);
    return;
  }
  
  const param = step.params.find(p => p.paramName === pn);
  if (!param) {
    console.warn('[FF] Param not found in step. paramName:', pn, 'step.params:', step.params?.map(p => p.paramName));
    // Fallback: render with field IDs only
    _renderFieldFilterCardsSimple(normalConfigs, selectedDiv, ridx, skey, pn);
    return;
  }
  const fields = param.availableFields || [];
  
  let html = '';
  if (normalConfigs.length > 0) {
    normalConfigs.forEach(cfg => {
      const field = fields.find(f => (f.fieldId || f.label) === cfg.id);
      if (!field) return;
      const fLabel = field.label || cfg.id;
      const op = cfg.operator || '';
      const v1 = cfg.value1 || '';
      const v2 = cfg.value2 || '';
      
      html += `<div class="ff-selected-item" data-fid="${cfg.id.replace(/"/g,'&quot;')}">
        <div class="ff-si-header">
          <span class="ff-si-label">${fLabel.replace(/</g,'&lt;').replace(/>/g,'&gt;')}</span>
          <span class="ff-si-fid">(${cfg.id.replace(/</g,'&lt;').replace(/>/g,'&gt;')})</span>
          <button class="ff-si-remove" onclick="ffRemoveField(${ridx},'${skey}','${pn}','${cfg.id.replace(/'/g,"\\'").replace(/"/g,'&quot;')}')">Ã—</button>
        </div>
        <div class="ff-si-criteria">
          <div>
            <label>Operator:</label>
            <select onchange="ffUpdateField(${ridx},'${skey}','${pn}','${cfg.id.replace(/'/g,"\\'").replace(/"/g,'&quot;')}','operator',this.value)">
              <option value="">â€” select â€”</option>
              <option value="EQ"${op==='EQ'?' selected':''}>Equal to</option>
              <option value="NEQ"${op==='NEQ'||op==='NE'?' selected':''}>Not equal to</option>
              <option value="G"${op==='G'||op==='GT'?' selected':''}>Greater than</option>
              <option value="GEQ"${op==='GEQ'||op==='GE'?' selected':''}>Greater or equal</option>
              <option value="L"${op==='L'||op==='LT'?' selected':''}>Less than</option>
              <option value="LEQ"${op==='LEQ'||op==='LE'?' selected':''}>Less or equal</option>
              <option value="BTWN"${op==='BTWN'||op==='BW'?' selected':''}>Between</option>
            </select>
          </div>
          <div>
            <label>Value:</label>
            <input type="text" value="${String(v1).replace(/"/g,'&quot;')}" placeholder="Value"
              onchange="ffUpdateField(${ridx},'${skey}','${pn}','${cfg.id.replace(/'/g,"\\'").replace(/"/g,'&quot;')}','value1',this.value)">
          </div>
          ${op==='BW'?`<div>
            <label>To:</label>
            <input type="text" value="${String(v2).replace(/"/g,'&quot;')}" placeholder="Upper bound"
              onchange="ffUpdateField(${ridx},'${skey}','${pn}','${cfg.id.replace(/'/g,"\\'").replace(/"/g,'&quot;')}','value2',this.value)">
          </div>`:''}
        </div>
      </div>`;
    });
  } else {
    html = '<p class="ff-empty-msg">No fields selected. Choose fields below to add criteria.</p>';
  }
  
  selectedDiv.innerHTML = html;
}

/* â”€â”€ Fallback renderer when metadata is not available â”€â”€ */
function _renderFieldFilterCardsSimple(normalConfigs, selectedDiv, ridx, skey, pn) {
  let html = '';
  if (normalConfigs.length > 0) {
    normalConfigs.forEach(cfg => {
      const fLabel = cfg.id; // Use ID as label when metadata unavailable
      const op = cfg.operator || '';
      const v1 = cfg.value1 || '';
      const v2 = cfg.value2 || '';
      
      html += `<div class="ff-selected-item" data-fid="${cfg.id.replace(/"/g,'&quot;')}">
        <div class="ff-si-header">
          <span class="ff-si-label">${fLabel.replace(/</g,'&lt;').replace(/>/g,'&gt;')}</span>
          <span class="ff-si-fid" style="color: orange;">(metadata unavailable - run discovery)</span>
          <button class="ff-si-remove" onclick="ffRemoveField(${ridx},'${skey}','${pn}','${cfg.id.replace(/'/g,"\\'").replace(/"/g,'&quot;')}')">Ã—</button>
        </div>
        <div class="ff-si-criteria">
          <div>
            <label>Operator:</label>
            <select onchange="ffUpdateField(${ridx},'${skey}','${pn}','${cfg.id.replace(/'/g,"\\'").replace(/"/g,'&quot;')}','operator',this.value)">
              <option value="">â€” select â€”</option>
              <option value="EQ"${op==='EQ'?' selected':''}>Equal to</option>
              <option value="NEQ"${op==='NEQ'||op==='NE'?' selected':''}>Not equal to</option>
              <option value="G"${op==='G'||op==='GT'?' selected':''}>Greater than</option>
              <option value="GEQ"${op==='GEQ'||op==='GE'?' selected':''}>Greater or equal</option>
              <option value="L"${op==='L'||op==='LT'?' selected':''}>Less than</option>
              <option value="LEQ"${op==='LEQ'||op==='LE'?' selected':''}>Less or equal</option>
              <option value="BTWN"${op==='BTWN'||op==='BW'?' selected':''}>Between</option>
            </select>
          </div>
          <div>
            <label>Value:</label>
            <input type="text" value="${String(v1).replace(/"/g,'&quot;')}" placeholder="Value"
              onchange="ffUpdateField(${ridx},'${skey}','${pn}','${cfg.id.replace(/'/g,"\\'").replace(/"/g,'&quot;')}','value1',this.value)">
          </div>
          ${op==='BTWN'||op==='BW'?`<div>
            <label>To:</label>
            <input type="text" value="${String(v2).replace(/"/g,'&quot;')}" placeholder="Upper bound"
              onchange="ffUpdateField(${ridx},'${skey}','${pn}','${cfg.id.replace(/'/g,"\\'").replace(/"/g,'&quot;')}','value2',this.value)">
          </div>`:''}
        </div>
      </div>`;
    });
  } else {
    html = '<p class="ff-empty-msg">No fields selected. Choose fields below to add criteria.</p>';
  }
  selectedDiv.innerHTML = html;
}

/* â”€â”€ SPAB field-filter (old flat format): toggle single item â”€â”€ */
function ffSpabToggleItem(reportIdx, paramName, ffId) {
  const report = cuicReports[reportIdx];
  if (!report.filters) report.filters = {};
  const listEl = document.getElementById(ffId + '-list');
  if (!listEl) return;
  const checked = Array.from(listEl.querySelectorAll('input[type=checkbox]:checked')).map(cb => cb.value);
  const total = listEl.querySelectorAll('input[type=checkbox]').length;
  report.filters[paramName] = checked.length === total ? 'all' : checked;
  const countEl = document.getElementById(ffId + '-count');
  if (countEl) countEl.textContent = checked.length + ' / ' + total;
  // Refresh summary tags in-place
  _refreshSummaryTags(ffId);
}

/* â”€â”€ SPAB field-filter: check all visible â”€â”€ */
function ffCheckAll(reportIdx, paramName, ffId) {
  const listEl = document.getElementById(ffId + '-list');
  if (!listEl) return;
  listEl.querySelectorAll('label').forEach(lbl => {
    if (lbl.style.display !== 'none') {
      const cb = lbl.querySelector('input[type=checkbox]');
      if (cb) cb.checked = true;
    }
  });
  ffSpabToggleItem(reportIdx, paramName, ffId);
}

/* â”€â”€ SPAB field-filter: uncheck all visible â”€â”€ */
function ffUncheckAll(reportIdx, paramName, ffId) {
  const listEl = document.getElementById(ffId + '-list');
  if (!listEl) return;
  listEl.querySelectorAll('label').forEach(lbl => {
    if (lbl.style.display !== 'none') {
      const cb = lbl.querySelector('input[type=checkbox]');
      if (cb) cb.checked = false;
    }
  });
  ffSpabToggleItem(reportIdx, paramName, ffId);
}

/* â”€â”€ Field-filter: filter checklist by search text â”€â”€ */
function filterFfChecklist(ffId, query) {
  const listEl = document.getElementById(ffId + '-list');
  if (!listEl) return;
  const q = query.toLowerCase().trim();
  listEl.querySelectorAll('label').forEach(lbl => {
    const name = lbl.getAttribute('data-name') || '';
    lbl.style.display = (!q || name.includes(q)) ? '' : 'none';
  });
}

/* â”€â”€ Generic step-based filter update â”€â”€ */
function updateFilterValue(reportIdx, stepKey, fieldKey, el) {
  const report = cuicReports[reportIdx];
  if (!report.filters) report.filters = {};
  if (!report.filters[stepKey]) report.filters[stepKey] = {};

  if (el.type === 'checkbox') {
    report.filters[stepKey][fieldKey] = el.checked;
  } else if (el.tagName === 'SELECT' && el.multiple) {
    report.filters[stepKey][fieldKey] = Array.from(el.selectedOptions).map(o => o.value);
  } else {
    report.filters[stepKey][fieldKey] = el.value;
  }
}

function clearFilters(reportIdx) {
  const report = cuicReports[reportIdx];
  const meta = report._wizard_meta || (report.filters && report.filters._meta) || null;
  report.filters = {};
  if (meta) report.filters._meta = meta;
  renderCuicReports();
  showToast('Filters cleared for ' + (report.label || 'report'), 'info');
}

async function discoverFilters(reportIdx) {
  const report = cuicReports[reportIdx];
  const btn = document.getElementById('discover-btn-' + reportIdx);

  if (!report.folder || !report.name) {
    showToast('Set folder and report name first', 'error');
    return;
  }

  const origHtml = btn.innerHTML;
  btn.innerHTML = '<span class="spinner"></span> Discovering...';
  btn.disabled = true;
  showToast('Launching browser to discover wizard fields... This may take 30-60s.', 'info');

  try {
    const res = await fetch('/api/discover-filters', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({ folder: report.folder, name: report.name })
    });
    const data = await res.json();
    console.log('[discoverFilters] Raw response:', JSON.stringify(data, null, 2));

    if (data.error) {
      showToast('Discovery error: ' + data.error, 'error');
      return;
    }

    if (!data.steps || data.steps.length === 0) {
      showToast('No wizard steps found', 'error');
      return;
    }

    const isCuic = data.type === 'cuic_spab';
    const isMultiStep = data.type === 'cuic_multistep';

    if (isMultiStep) {
      // â”€â”€ CUIC multi-step wizard â”€â”€
      const steps = data.steps || [];
      const metaObj = {
        type: 'cuic_multistep',
        steps: steps,
        stepTitles: data.stepTitles || steps.map(s => s.title || 'Step ' + s.step),
        datePresets: data.datePresets || []
      };
      report._wizard_meta = metaObj;
      // Reset filters to fresh discovery state (keep only _meta)
      const oldFilters = report.filters || {};
      report.filters = { _meta: metaObj };

      // Pre-populate per-step defaults from discovery
      let totalParams = 0;
      steps.forEach(step => {
        const stepKey = 'step_' + step.step;
        report.filters[stepKey] = {};
        (step.params || []).forEach(p => {
          totalParams++;
          const pn = p.paramName;
          if (!pn) return;
          if (p.type === 'cuic_datetime' && p.currentPreset) {
            report.filters[stepKey][pn] = p.currentPreset;
          }
          // Pre-select values that were already selected in CUIC
          if (p.type === 'cuic_valuelist' && p.selectedValues && p.selectedValues.length > 0) {
            report.filters[stepKey][pn] = p.selectedValues;
          }
          // Pre-select field filters that were already selected in CUIC
          if (p.type === 'cuic_field_filter' && p.selectedFieldIds && p.selectedFieldIds.length > 0) {
            report.filters[stepKey][pn] = p.selectedFieldIds;
          }
        });
      });
      showToast(`Discovered ${steps.length} wizard step(s) with ${totalParams} parameter(s)!`, 'success');

    } else if (isCuic) {
      // â”€â”€ CUIC format: flat param-name keys â”€â”€
      const params = data.params || [];
      const metaObj = {
        type: 'cuic_spab',
        params: params,
        datePresets: data.datePresets || []
      };
      report._wizard_meta = metaObj;
      // Reset filters to fresh discovery state (keep only _meta)
      report.filters = { _meta: metaObj };

      // Pre-populate with defaults from discovery
      params.forEach(p => {
        const pn = p.paramName;
        if (!pn) return;
        // Set sensible defaults
        if (p.type === 'cuic_datetime' && p.currentPreset) {
          report.filters[pn] = p.currentPreset;
        }
        // Pre-select values that were already selected in CUIC
        if (p.type === 'cuic_valuelist' && p.selectedValues && p.selectedValues.length > 0) {
          report.filters[pn] = p.selectedValues;
        }
      });
      showToast(`Discovered ${params.length} CUIC parameter(s)!`, 'success');

    } else {
      // â”€â”€ Generic step-based format â”€â”€
      report._wizard_meta = { steps: data.steps };
      // Reset filters to fresh discovery state (keep only _meta)
      report.filters = { _meta: { steps: data.steps } };

      data.steps.forEach(step => {
        const stepKey = 'step_' + step.step;
        report.filters[stepKey] = {};
        (step.fields || []).forEach(field => {
          const key = field.id || field.name || field.label;
          if (!key) return;
          report.filters[stepKey][key] = field.value;
        });
      });
      showToast(`Discovered ${data.steps.length} wizard step(s)!`, 'success');
    }

    renderCuicReports();
    
    // Auto-set label from report name if label is empty
    if (!report.label && report.name) {
      report.label = generateLabelFromName(report.name);
      renderCuicReports();
    }

  } catch(e) {
    showToast('Discovery failed: ' + e.message, 'error');
  } finally {
    btn.innerHTML = origHtml;
    btn.disabled = false;
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  SMAX REPORT CARDS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function renderSmaxReports() {
  const container = document.getElementById('smax-reports-list');
  if (!container) return;
  if (smaxReports.length === 0) {
    container.innerHTML = '<p style="color:var(--muted);text-align:center;padding:20px">No reports configured. Click "+ Add Report" to get started.</p>';
    return;
  }
  container.innerHTML = smaxReports.map((r, i) => {
    // Check if this is a new empty report (no label/properties yet)
    const isEmpty = !r.label && !r.properties?.report_name;
    
    if (isEmpty) {
      // Minimal card: just URL + discover button
      return `<div class="report-card">
        <div class="report-card-header">
          <span class="label-tag" style="color:var(--muted);font-style:italic">New Report</span>
          <button class="btn btn-icon btn-sm" onclick="removeSmaxReport(${i})" title="Remove">\uD83D\uDDD1\uFE0F</button>
        </div>
        <div class="inline-row"><label>Report URL</label><input value="${attr(r.url)}" onchange="smaxReports[${i}].url=this.value" placeholder="https://smax.corp.pdo.om/reports/report/..." style="grid-column:2"></div>
        <div style="margin-top:10px;display:flex;align-items:center;gap:8px;">
          <button class="btn-discover" id="smax-discover-btn-${i}" onclick="discoverSmaxProperties(${i})">
            \u25B6 Validate Link
          </button>
          <span style="font-size:11px;color:var(--muted)">Opens browser to validate the URL and fetch report properties</span>
        </div>
      </div>`;
    }

    // Full card with all details
    const st = scrapeStatus['smax:' + r.label];
    let statusHtml = '<div class="status-bar"><span class="status-dot pending"></span> Never scraped</div>';
    if (st) {
      const icon = st.status === 'success' ? '\u2705' : st.status === 'error' ? '\u274C' : '\u26A0\uFE0F';
      const dur = st.duration_s ? st.duration_s.toFixed(1) + 's' : '';
      const msg = st.message ? ' \u2014 ' + esc(st.message) : '';
      statusHtml = `<div class="status-bar"><span class="status-dot ${st.status}"></span>
        <span>${icon} ${esc(st.timestamp)} \u00B7 ${st.row_count || 0} rows \u00B7 ${dur}${msg}</span></div>`;
    }
    const propsHtml = renderSmaxPropertiesPanel(r, i);
    return `<div class="report-card ${r.enabled ? '' : 'disabled'}">
      <div class="report-card-header">
        <div style="display:flex;align-items:center;gap:8px">
          <span class="label-tag">${esc(r.label || 'unnamed')}</span>
          <span class="data-type-badge ${r.data_type === 'historical' ? 'historical' : 'ongoing'}">${r.data_type === 'historical' ? '\ud83d\udce6 Historical' : '\ud83d\udce1 Ongoing'}</span>
        </div>
        <div style="display:flex;gap:6px;align-items:center">
          <div class="toggle-switch" style="margin:0">
            <input type="checkbox" id="smax-rpt-en-${i}" ${r.enabled ? 'checked' : ''}
              onchange="smaxReports[${i}].enabled=this.checked;renderSmaxReports()">
            <label for="smax-rpt-en-${i}" style="font-size:12px">Enabled</label>
          </div>
          <button class="btn btn-icon btn-sm" onclick="removeSmaxReport(${i})" title="Remove">\uD83D\uDDD1\uFE0F</button>
        </div>
      </div>
      <div class="inline-row"><label>Label</label><input value="${attr(r.label)}" onchange="smaxReports[${i}].label=this.value" placeholder="e.g. sla_fcr_month"></div>
      <div class="inline-row"><label>Report URL</label><input value="${attr(r.url)}" onchange="smaxReports[${i}].url=this.value" placeholder="https://smax.corp.pdo.om/reports/report/..."></div>
      <div class="inline-row"><label>Data Type</label>
        <select onchange="smaxReports[${i}].data_type=this.value;renderSmaxReports()" style="padding:6px 10px;background:var(--bg);border:1px solid var(--border);border-radius:var(--radius);color:var(--fg);font-size:13px">
          <option value="ongoing" ${(r.data_type||'ongoing')==='ongoing'?'selected':''}>ğŸ“¡ Ongoing (re-scrape every run)</option>
          <option value="historical" ${r.data_type==='historical'?'selected':''}>ğŸ“¦ Historical (scrape once)</option>
        </select>
      </div>
      <div style="margin-top:10px;display:flex;align-items:center;gap:8px;">
        <button class="btn-discover" id="smax-discover-btn-${i}" onclick="discoverSmaxProperties(${i})">
          \u25B6 Re-validate Link
        </button>
        <span style="font-size:11px;color:var(--muted)">Re-open browser to update report properties</span>
      </div>
      ${propsHtml}
      ${statusHtml}
    </div>`;
  }).join('');
}

function addSmaxReport() {
  // Check if there's already an empty report (no label or URL)
  const hasEmptyReport = smaxReports.some(r => !r.label && !r.url);
  if (hasEmptyReport) {
    showToast('Please fill in the existing empty report first', 'warning');
    return;
  }
  
  smaxReports.unshift({ label: '', url: '', enabled: true, data_type: 'ongoing', properties: {} });
  renderSmaxReports();
  
  // Highlight the newly added report card
  setTimeout(() => {
    const firstCard = document.getElementById('smax-reports-list').firstElementChild;
    if (firstCard) {
      firstCard.classList.add('highlight-new');
      // Remove the class after animation completes
      setTimeout(() => firstCard.classList.remove('highlight-new'), 1000);
    }
  }, 50);
}

function removeSmaxReport(i) {
  smaxReports.splice(i, 1);
  renderSmaxReports();
}

function renderSmaxPropertiesPanel(report, idx) {
  const props = report.properties || {};
  if (!props.report_name && !props.filters) return '';

  let html = '<details class="filter-panel-collapsible"><summary class="filter-panel-toggle">\uD83D\uDCC4 Report Properties</summary><div class="filter-panel">';

  // Report metadata
  if (props.report_name) html += `<div class="smax-prop-row"><span class="smax-prop-label">Report Name</span><span>${esc(props.report_name)}</span></div>`;
  if (props.record_type) html += `<div class="smax-prop-row"><span class="smax-prop-label">Record Type</span><span class="smax-prop-badge">${esc(props.record_type)}</span></div>`;
  if (props.group_by && props.group_by.length) html += `<div class="smax-prop-row"><span class="smax-prop-label">Group By</span><span>${props.group_by.map(g => esc(g)).join(', ')}</span></div>`;
  if (props.func && (props.func.main || props.func.secondary)) {
    const funcStr = [props.func.main, props.func.secondary].filter(Boolean).join(' by ');
    html += `<div class="smax-prop-row"><span class="smax-prop-label">Function</span><span>${esc(funcStr)}</span></div>`;
  }
  if (props.chart_function) html += `<div class="smax-prop-row"><span class="smax-prop-label">Chart Function</span><span>${esc(props.chart_function)}</span></div>`;

  // Filters
  const filters = props.filters || [];
  if (filters.length) {
    html += '<div style="margin-top:10px"><strong style="font-size:12px;color:var(--muted);text-transform:uppercase;letter-spacing:0.5px">Filters</strong></div>';
    filters.forEach(f => {
      const negBadge = f.negated ? '<span class="smax-neg-badge">NOT</span> ' : '';
      const opBadge = f.operator && f.operator !== 'Is' ? `<span class="smax-op-badge">${esc(f.operator)}</span> ` : '';
      let valueHtml = '';

      if (f.type === 'date') {
        valueHtml = `<span class="smax-filter-value">${esc(f.display_value || '')}</span>`;
        if (f.date_presets && f.date_presets.length) {
          valueHtml += `<div class="smax-presets">Presets: ${f.date_presets.map(p => '<span class="smax-preset-tag">' + esc(p.label) + '</span>').join(' ')}</div>`;
        }
      } else if (f.type === 'enum') {
        valueHtml = negBadge + esc(f.display_value || '');
        if (f.enum_options && f.enum_options.length) {
          valueHtml += '<div class="smax-enum-opts">' + f.enum_options.map(o =>
            `<span class="smax-enum-opt${o.checked ? ' active' : ''}">${esc(o.label)}</span>`
          ).join(' ') + '</div>';
        }
      } else if (f.selected_values && f.selected_values.length) {
        // Render selected_values as chips (for dropdown, entity_picker, or any with array)
        valueHtml = f.selected_values.map(v => '<span class="smax-chip">' + esc(v) + '</span>').join(' ');
      } else if (f.display_value && f.display_value.includes(',')) {
        // Fallback: if display_value has commas, split and render as chips
        const vals = f.display_value.split(',').map(v => v.trim()).filter(Boolean);
        valueHtml = vals.map(v => '<span class="smax-chip">' + esc(v) + '</span>').join(' ');
      } else {
        valueHtml = esc(f.display_value || '');
      }

      html += `<div class="smax-filter-row">
        <span class="smax-filter-label">${esc(f.field_label || f.field_id || '?')}</span>
        <span class="smax-filter-sep">:</span>
        <span>${opBadge}${f.type !== 'enum' ? negBadge : ''}${valueHtml}</span>
      </div>`;
    });
  }

  // Chart legend
  if (props.chart_legend && props.chart_legend.length) {
    html += '<div style="margin-top:10px"><strong style="font-size:12px;color:var(--muted);text-transform:uppercase;letter-spacing:0.5px">Chart Legend</strong></div>';
    props.chart_legend.forEach(item => {
      html += `<div class="smax-prop-row"><span>${esc(item.label)}</span><span style="color:var(--accent)">${esc(item.value || '')}</span></div>`;
    });
  }

  html += `<div style="margin-top:8px"><button class="btn-discover" style="font-size:11px;padding:4px 10px" onclick="discoverSmaxProperties(${idx})">\u25B6 Re-discover</button>
    <button class="btn-discover" style="font-size:11px;padding:4px 10px;margin-left:4px" onclick="clearSmaxProperties(${idx})">\u2716 Clear</button></div>`;
  html += '</div></details>';
  return html;
}

function clearSmaxProperties(idx) {
  smaxReports[idx].properties = {};
  renderSmaxReports();
  showToast('Properties cleared', 'info');
}

// â”€â”€ Auto-detect data type from report properties â”€â”€
function suggestDataType(props) {
  // Look at date filter display values and presets for time-range keywords
  const filters = props.filters || [];
  const dateFilters = filters.filter(f => f.type === 'date');
  if (!dateFilters.length) return null;

  // Collect all text from date filter values and preset labels
  const allText = dateFilters.map(f => {
    const parts = [f.display_value || ''];
    (f.date_presets || []).forEach(p => parts.push(p.label || ''));
    return parts.join(' ');
  }).join(' ').toLowerCase();

  // Historical indicators: past/fixed time periods
  const historicalPatterns = /previous\s+month|last\s+month|previous\s+year|last\s+year|previous\s+quarter|last\s+quarter|yesterday/;
  // Ongoing indicators: current/rolling time periods
  const ongoingPatterns = /this\s+month|current\s+month|today|this\s+year|current\s+year|this\s+quarter|current\s+quarter|this\s+week|current\s+week|rolling/;

  const hasHistorical = historicalPatterns.test(allText);
  const hasOngoing = ongoingPatterns.test(allText);

  // If only historical keywords found, suggest historical
  if (hasHistorical && !hasOngoing) return 'historical';
  // If ongoing keywords found, prefer ongoing
  if (hasOngoing) return 'ongoing';
  // Can't determine
  return null;
}

async function discoverSmaxProperties(idx) {
  const report = smaxReports[idx];
  const btn = document.getElementById('smax-discover-btn-' + idx);

  if (!report.url) {
    showToast('Set the report URL first', 'error');
    return;
  }

  const origHtml = btn.innerHTML;
  btn.innerHTML = '<span class="spinner"></span> Discovering...';
  btn.disabled = true;
  showToast('Launching browser to read report properties... This may take 30-60s.', 'info');

  try {
    const res = await fetch('/api/discover-smax-properties', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({ url: report.url })
    });
    const data = await res.json();

    if (data.error) {
      showToast('Discovery error: ' + data.error, 'error');
      return;
    }

    // Store discovered properties
    report.properties = data;

    // Auto-set label from report name if label is empty
    if (!report.label && data.report_name) {
      report.label = generateLabelFromName(data.report_name);
    }

    // Auto-suggest data_type from date filter presets
    const suggested = suggestDataType(data);
    if (suggested) {
      report.data_type = suggested;
    }

    const filterCount = (data.filters || []).length;
    const typeLabel = report.data_type === 'historical' ? ' (auto-detected: historical)' : ' (auto-detected: ongoing)';
    showToast(`Discovered: "${data.report_name || 'report'}" with ${filterCount} filter(s)${suggested ? typeLabel : ''}!`, 'success');
    renderSmaxReports();

  } catch(e) {
    showToast('Discovery failed: ' + e.message, 'error');
  } finally {
    btn.innerHTML = origHtml;
    btn.disabled = false;
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  BUILD / POPULATE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function syncReportInputs() {
  document.querySelectorAll('#cuic-reports-list .report-card').forEach((card, i) => {
    const inputs = card.querySelectorAll('.inline-row input');
    // inputs[0] = Report Path (combined folder/name), inputs[1] = Label (full cards only)
    if (inputs[0]) {
      const path = inputs[0].value.trim();
      const lastSlash = path.lastIndexOf('/');
      if (lastSlash === -1) {
        cuicReports[i].folder = '';
        cuicReports[i].name = path;
      } else {
        cuicReports[i].folder = path.substring(0, lastSlash);
        cuicReports[i].name = path.substring(lastSlash + 1);
      }
    }
    if (inputs[1]) cuicReports[i].label = inputs[1].value;
  });
  document.querySelectorAll('#smax-reports-list .report-card').forEach((card, i) => {
    const inputs = card.querySelectorAll('.inline-row input');
    if (inputs[0]) smaxReports[i].label = inputs[0].value;
    if (inputs[1]) smaxReports[i].url   = inputs[1].value;
  });
}

function buildSettings() {
  syncReportInputs();
  return {
    global: {
      headless:             document.getElementById('g-headless').checked,
      use_system_chrome:    document.getElementById('g-system-chrome').checked,
      screenshot_steps:     document.getElementById('g-screenshot-steps').checked,
      screenshot_errors:    document.getElementById('g-screenshot-errors').checked,
      log_level:            document.getElementById('g-log-level').value,
      output_dir:           document.getElementById('g-output-dir').value,
      log_dir:              document.getElementById('g-log-dir').value,
      data_retention_days:  parseInt(document.getElementById('g-retention').value) || 90,
      shared_drive_csv:     document.getElementById('g-shared-drive').value
    },
    workers: {
      cuic: {
        enabled:            document.getElementById('cuic-enabled').checked,
        url:                document.getElementById('cuic-url').value,
        reports:            cuicReports.map(r => {
          const f = Object.assign({}, r.filters || {});
          if (r._wizard_meta) f._meta = r._wizard_meta;
          return { label: r.label, folder: r.folder, name: r.name, enabled: r.enabled !== false, data_type: r.data_type || 'ongoing', filters: f };
        }),
        timeout_nav_ms:     parseInt(document.getElementById('cuic-t-nav').value) || 30000,
        timeout_short_ms:   parseInt(document.getElementById('cuic-t-short').value) || 1500,
        timeout_medium_ms:  parseInt(document.getElementById('cuic-t-medium').value) || 2500,
        timeout_long_ms:    parseInt(document.getElementById('cuic-t-long').value) || 8000
      },
      smax: {
        enabled:              document.getElementById('smax-enabled').checked,
        base_url:             document.getElementById('smax-url').value,
        reports:              smaxReports.map(r => ({
          label: r.label, url: r.url, enabled: r.enabled !== false,
          data_type: r.data_type || 'ongoing',
          properties: r.properties || {}
        })),
        page_load_timeout_ms: parseInt(document.getElementById('smax-t-load').value) || 120000,
        element_wait_timeout_ms: parseInt(document.getElementById('smax-t-elem').value) || 30000,
        tab_stagger_delay_ms: parseInt(document.getElementById('smax-t-stagger').value) || 2000,
        max_retries:          parseInt(document.getElementById('smax-retries').value) || 2
      }
    }
  };
}

function buildCredentials() {
  return {
    cuic: { username: document.getElementById('cuic-user').value, password: document.getElementById('cuic-pass').value },
    smax: { username: document.getElementById('smax-user').value, password: document.getElementById('smax-pass').value }
  };
}

function populateSettings(s) {
  const g = s.global || {};
  setBool('g-headless', g.headless, true);
  setBool('g-system-chrome', g.use_system_chrome, true);
  setBool('g-screenshot-steps', g.screenshot_steps, false);
  setBool('g-screenshot-errors', g.screenshot_errors, true);
  setVal('g-log-level', g.log_level || 'INFO');
  setVal('g-output-dir', g.output_dir || 'output');
  setVal('g-log-dir', g.log_dir || 'logs');
  setVal('g-retention', g.data_retention_days || 90);
  setVal('g-shared-drive', g.shared_drive_csv || '');

  const cuic = (s.workers || {}).cuic || {};
  setBool('cuic-enabled', cuic.enabled, true);
  setVal('cuic-url', cuic.url || 'https://148.151.32.77:8444/cuicui/Main.jsp');
  cuicReports = (cuic.reports || []).map(r => {
    const rep = { label: r.label||'', folder: r.folder||'', name: r.name||'', enabled: r.enabled !== false, data_type: r.data_type || 'ongoing', filters: r.filters||{} };
    if (rep.filters._meta) rep._wizard_meta = rep.filters._meta;
    return rep;
  });
  if (!cuicReports.length) cuicReports.push({ label:'call_type_hist', folder:'Test', name:'Z Call Type Historical All Fields', enabled:true, filters:{} });
  renderCuicReports();
  setVal('cuic-t-nav', cuic.timeout_nav_ms || 30000);
  setVal('cuic-t-short', cuic.timeout_short_ms || 1500);
  setVal('cuic-t-medium', cuic.timeout_medium_ms || 2500);
  setVal('cuic-t-long', cuic.timeout_long_ms || 8000);

  const smax = (s.workers || {}).smax || {};
  setBool('smax-enabled', smax.enabled, false);
  setVal('smax-url', smax.base_url || 'https://smax.corp.pdo.om');
  // Support both new 'reports' format and legacy 'report_urls' list
  if (smax.reports && smax.reports.length) {
    smaxReports = smax.reports.map(r => ({ label: r.label||'', url: r.url||'', enabled: r.enabled !== false, data_type: r.data_type || 'ongoing', properties: r.properties||{} }));
  } else if (smax.report_urls && smax.report_urls.length) {
    smaxReports = smax.report_urls.map((u, i) => ({ label: 'report_' + (i+1), url: u, enabled: true, data_type: 'ongoing', properties: {} }));
  } else {
    smaxReports = [];
  }
  renderSmaxReports();
  setVal('smax-t-load', smax.page_load_timeout_ms || 120000);
  setVal('smax-t-elem', smax.element_wait_timeout_ms || 30000);
  setVal('smax-t-stagger', smax.tab_stagger_delay_ms || 2000);
  setVal('smax-retries', smax.max_retries || 2);
}

function populateCredentials(c) {
  setVal('cuic-user', (c.cuic||{}).username||'');
  setVal('cuic-pass', (c.cuic||{}).password||'');
  setVal('smax-user', (c.smax||{}).username||'');
  setVal('smax-pass', (c.smax||{}).password||'');
}

function setBool(id, val, def) { document.getElementById(id).checked = val !== undefined ? val : def; }
function setVal(id, val) { const el = document.getElementById(id); if (el) el.value = val; }

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  SAVE / LOAD VIA API
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function saveAll() {
  try {
    const [r1, r2] = await Promise.all([
      fetch('/api/settings',    { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(buildSettings()) }),
      fetch('/api/credentials', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(buildCredentials()) })
    ]);
    if (r1.ok && r2.ok) showToast('Settings saved!');
    else showToast('Save failed: ' + (await r1.text()) + (await r2.text()), 'error');
  } catch(e) {
    showToast('Server offline â€” use Export tab to copy JSON manually', 'error');
  }
}

// â”€â”€ Manual scrape trigger â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function startManualScrape() {
  const btn = document.getElementById('manual-scrape-btn');
  const statusEl = document.getElementById('manual-scrape-status');
  try {
    // Save settings first so workers use the latest config
    await saveAll();

    btn.disabled = true;
    btn.textContent = 'â³ Starting...';
    statusEl.textContent = 'Saving settings and starting scrape...';
    statusEl.style.color = 'var(--accent)';

    const res = await fetch('/api/run-scrape', { method: 'POST' });
    const data = await res.json();

    if (res.ok) {
      btn.textContent = 'â³ Scrape Running...';
      statusEl.textContent = 'Scrape is running in the background. Checking progress...';
      statusEl.style.color = 'var(--green)';
      showToast('Scrape started! Running in background...', 'success');

      // Poll for completion
      const pollInterval = setInterval(async () => {
        try {
          const checkRes = await fetch('/api/scrape-running');
          const checkData = await checkRes.json();
          if (!checkData.running) {
            clearInterval(pollInterval);
            btn.disabled = false;
            btn.textContent = 'â–¶ Start Scrape Now';
            statusEl.textContent = 'Scrape completed! Refreshing data...';
            statusEl.style.color = 'var(--green)';
            // Reload scrape log and status
            await loadFromServer();
            setTimeout(() => { statusEl.textContent = 'Run all enabled workers manually'; statusEl.style.color = 'var(--muted)'; }, 5000);
          }
        } catch(e) { /* keep polling */ }
      }, 3000);

    } else {
      btn.disabled = false;
      btn.textContent = 'â–¶ Start Scrape Now';
      statusEl.textContent = data.error || 'Failed to start scrape';
      statusEl.style.color = 'var(--red)';
      showToast(data.error || 'Failed to start scrape', 'error');
    }
  } catch(e) {
    btn.disabled = false;
    btn.textContent = 'â–¶ Start Scrape Now';
    statusEl.textContent = 'Server offline';
    statusEl.style.color = 'var(--red)';
    showToast('Server offline â€” cannot start scrape', 'error');
  }
}

async function loadFromServer() {
  try {
    const [sRes, cRes, statusRes, logRes] = await Promise.all([
      fetch('/api/settings'), fetch('/api/credentials'),
      fetch('/api/scrape-status').catch(()=>null),
      fetch('/api/scrape-log?limit=50').catch(()=>null)
    ]);
    if (sRes.ok) populateSettings(await sRes.json());
    if (cRes.ok) populateCredentials(await cRes.json());
    if (statusRes?.ok) {
      const data = await statusRes.json();
      scrapeStatus = {};
      (data||[]).forEach(s => scrapeStatus[s.source+':'+s.report_label] = s);
      renderCuicReports();
      renderSmaxReports();
      updateDashboard(data);
    }
    if (logRes?.ok) renderScrapeLog(await logRes.json());
    document.getElementById('server-status').classList.remove('offline');
    document.getElementById('server-status-text').textContent = 'Connected';
  } catch(e) {
    console.warn('Server not available', e);
    document.getElementById('server-status').classList.add('offline');
    document.getElementById('server-status-text').textContent = 'Offline';
    resetDefaults();
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  DASHBOARD
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function updateDashboard(statusData) {
  document.getElementById('stat-total-reports').textContent = cuicReports.length + smaxReports.length;
  if (!statusData?.length) {
    document.getElementById('stat-last-run').textContent = 'Never';
    document.getElementById('stat-success-rate').textContent = '-';
    document.getElementById('stat-total-rows').textContent = '0';
    return;
  }
  document.getElementById('stat-last-run').textContent = statusData[0].timestamp || '-';
  const ok = statusData.filter(s => s.status === 'success').length;
  document.getElementById('stat-success-rate').textContent = Math.round(ok/statusData.length*100) + '%';
  document.getElementById('stat-total-rows').textContent = statusData.reduce((s,r) => s + (r.row_count||0), 0).toLocaleString();
}

function renderScrapeLog(log) {
  const tb = document.getElementById('scrape-log-body');
  if (!log?.length) { tb.innerHTML = '<tr><td colspan="7" style="text-align:center;color:var(--muted)">No scrape history yet.</td></tr>'; return; }
  tb.innerHTML = log.map(r => `<tr>
    <td>${esc(r.timestamp)}</td><td>${esc(r.source)}</td><td>${esc(r.report_label)}</td>
    <td><span class="status-pill ${r.status}">${r.status}</span></td>
    <td>${r.row_count||0}</td><td>${r.duration_s?r.duration_s.toFixed(1)+'s':'-'}</td>
    <td style="max-width:200px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap" title="${attr(r.message)}">${esc(r.message||'')}</td>
  </tr>`).join('');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  EXPORT / IMPORT / DEFAULTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function generateJSON() {
  document.getElementById('out-settings').value = JSON.stringify(buildSettings(), null, 2);
  document.getElementById('out-credentials').value = JSON.stringify(buildCredentials(), null, 2);
  document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
  document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
  document.querySelector('[data-tab="export"]').classList.add('active');
  document.getElementById('tab-export').classList.add('active');
  showToast('JSON generated!');
}

function loadFromJSON() {
  try {
    const st = document.getElementById('in-settings').value.trim();
    const ct = document.getElementById('in-credentials').value.trim();
    if (st) populateSettings(JSON.parse(st));
    if (ct) populateCredentials(JSON.parse(ct));
    showToast('Form populated from JSON');
  } catch(e) { showToast('Invalid JSON: ' + e.message, 'error'); }
}

function resetDefaults() {
  populateSettings({
    global: { headless:true, use_system_chrome:true, screenshot_steps:false, screenshot_errors:true,
              log_level:'INFO', output_dir:'output', log_dir:'logs', data_retention_days:90, shared_drive_csv:'' },
    workers: {
      cuic: { enabled:true, url:'https://148.151.32.77:8444/cuicui/Main.jsp',
              reports:[{label:'call_type_hist',folder:'Test',name:'Z Call Type Historical All Fields',enabled:true,filters:{}},
                      {label:'agent_hist',folder:'Stock/CCE/CCE_AF_Historical',name:'Agent Historical All Fields',enabled:true,filters:{}}],
              timeout_nav_ms:30000, timeout_short_ms:1500, timeout_medium_ms:2500, timeout_long_ms:8000 },
      smax: { enabled:false, base_url:'https://smax.corp.pdo.om', reports:[],
              page_load_timeout_ms:120000, element_wait_timeout_ms:30000, tab_stagger_delay_ms:2000, max_retries:2 }
    }
  });
  populateCredentials({cuic:{username:'',password:''},smax:{username:'',password:''}});
  showToast('Reset to defaults', 'info');
}

function copyToClipboard(id) {
  const el = document.getElementById(id); el.select(); document.execCommand('copy');
  showToast('Copied!');
}

// â”€â”€ Init â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
loadFromServer();
</script>
</body>
</html>
